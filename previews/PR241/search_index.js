var documenterSearchIndex = {"docs":
[{"location":"api/#Public-API-Functions","page":"API","title":"Public API Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TODO","category":"page"},{"location":"api/#Private-API-Functions","page":"API","title":"Private API Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TODO","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Continuous-Time-Jump-Processes-and-Gillespie-Methods","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"In this tutorial we will describe how to define and simulate continuous-time jump processes, also known in biological fields as stochastic chemical kinetics (i.e. Gillespie) models.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"note: Note\nThis tutorial assumes you have read the Ordinary Differential Equations tutorial in DifferentialEquations.jl.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"The discrete stochastic simulations we consider are a form of jump equation with a \"trivial\" (non-existent) differential equation. We will first demonstrate how to build these types of models using the biological modeling functionality of Catalyst.jl, then describe how to build them directly and more generally using DiffEqJump.jl jump types, and finally show how to couple discrete stochastic simulations to differential equation models.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Illustrative-Model:-SIR-disease-dynamics","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Illustrative Model: SIR disease dynamics","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"To illustrate the jump process solvers, we will build an SIR model which matches the tutorial from Gillespie.jl. SIR stands for susceptible, infected, and recovered, and is a model of disease spread. When a susceptible person comes in contact with an infected person, the disease has a chance of infecting the susceptible person. This \"chance\" is determined by the number of susceptible persons and the number of infected persons, since in larger populations there is a greater chance that two people come into contact. Every infected person will in turn have a rate at which they recover. In our model we'll assume there are no births or deaths, and a recovered individual is protected from reinfection.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We'll begin by giving the mathematical equations for the jump processes of the number of susceptible (S(t)), number of infected (I(t)), and number of recovered (R(t)). In the next section we give a more intuitive and biological description of the model for users that are less familiar with jump processes. Let Y_i(t), i = 12, denote independent unit Poisson processes. Our basic mathematical model for the evolution of (S(t)I(t)R(t)), written using Kurtz's time-change representation, is then","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginaligned\nS(t) = S(0) - Y_1left(  int_0^t beta S(s^-) I(s^-)  dsright) \nI(t) = I(0) + Y_1left(  int_0^t beta S(s^-) I(s^-)  dsright)\n        - Y_2 left( int_0^t nu I(s^-)   ds right) \nR(t) = R(0) + Y_2 left( int_0^t nu I(s^-)   ds right)\nendaligned","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice, our model involves two jumps with rate functions, also known as intensities or propensities, given by beta S(t) I(t) and nu I(t) respectively. These model the infection of susceptible individuals and recovery of infected individuals.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Defining-the-SIR-Model-using-Reactions-via-Catalyst","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Defining the SIR Model using Reactions via Catalyst","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"For those less-familiar with the time-change representation, we now give a more intuitive explanation of the model, and then demonstrate how it can be written as a serious of chemical reactions in Catalyst.jl and seamlessly converted into a form that can be used with the DiffEqJump.jl solvers. Users interested in how to directly define jumps using the lower-level DiffEqJump interface can skip to Building and Simulating the Jump Process using the DiffEqJump Low-level Interface.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"The SIR model described above involves two basic chemical reactions,","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginaligned\nS + I oversetbetato 2 I \nI oversetnuto R\nendaligned","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"where beta and nu are the rate constants of the reactions (with units of probability per time). In a jump process (stochastic chemical kinetics) model, we keep track of the non-negative integer number of each species at each time (i.e. (S(t) I(t) R(t)) above). Each reaction has an associated rate function (i.e. intensity or propensity) giving the probability per time it can occur when the system is in state (S(t)I(t)R(t)):","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginmatrix\ntextReaction  textRate Functions \nhline\nS + I oversetbetato 2 I  beta S(t) I(t) \nI oversetnuto R  nu I(t)\nendmatrix","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beta is determined by factors like the type of the disease. It can be interpreted as the probability per time one pair of susceptible and infected people encounter each other, with the susceptible person becoming sick. The overall rate (i.e. probability per time) that some susceptible person gets sick is then given by the rate constant multiplied by the number of possible pairs of susceptible and infected people. This formulation is known as the law of mass action. Similarly, we have that each individual infected person is assumed to recover with probability per time nu, so that the probability per time some infected person becomes recovered is nu times the number of infected people, i.e. nu I(t).","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Rate functions give the probability per time for each of the two types of jumps to occur, and hence determine when the state of our system changes. To fully specify our model we also need to specify how the state changes when a jump occurs, giving what are called affect functions in DiffEqJump. For example, when the S + I to 2 I reaction occurs and some susceptible person becomes infected, the subsequent (instantaneous) state change is that","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginaligned\nS to S - 1  I to I + 1\nendaligned","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Likewise, when the I to R reaction occurs so that some infected person becomes recovered the state change is","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginaligned\nI to I - 1  R to R + 1\nendaligned","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Using Catalyst.jl we can input our full reaction network in a form that can be easily used with DiffEqJump's solvers:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"# ]add Catalyst\nusing Catalyst\nsir_model = @reaction_network begin\n    β, S + I --> 2I\n    ν, I --> R\nend β ν","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice that the order the variables are introduced in the model is S, then I, then R, and thus this is the canonical ordering of the variables.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Building-and-Simulating-the-Jump-Process-from-Catalyst-Models","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Building and Simulating the Jump Process from Catalyst Models","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"First, we have to define some kind of differential equation that we can \"solve\" to simulate the jump process. Since we want integer, discrete changes in the numbers of the different types of people, we will build a DiscreteProblem. We do this by giving the constructor u0, the initial condition, and tspan, the timespan. Here, we will start with 999 susceptible people, 1 infected person, and 0 recovered people, and solve the problem from t=0.0 to t=250.0. We use the parameters β = 0.1/1000 and ν = 0.01. Thus we build the problem via:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"p     = (0.1/1000,0.01)\nu₀    = [999,1,0]\ntspan = (0.0,250.0)\nprob  = DiscreteProblem(sir_model, u₀, tspan, p)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice, the initial populations are integers since we want the exact number of people in the different states.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"The Catalyst reaction network can be converted into various DifferentialEquations.jl problem types, including JumpProblems, ODEProblems, or SDEProblems. To turn it into a jump problem representing the SIR jump process model, we load DiffEqJump and simply do:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using DiffEqJump\njump_prob = JumpProblem(sir_model, prob, Direct())","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Here Direct() indicates that we will determine the random times and types of reactions using Gillespie's Direct stochastic simulation algorithm (SSA). See Constant Rate Jump Aggregators below for other supported SSAs.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We now have a problem that can be evolved in time using the DiffEqJump solvers. Since our model is a pure jump process (no continuously-varying components), we will use SSAStepper() to handle time-stepping the Direct method from jump to jump:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"sol = solve(jump_prob, SSAStepper())","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"This solve command takes the standard commands of the common interface, and the solution object acts just like any other differential equation solution. Thus there exists a plot recipe, which we can plot with:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using Plots; plot(sol)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"(Image: SIR Solution)","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Building-and-Simulating-the-Jump-Process-using-the-DiffEqJump-Low-level-Interface","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Building and Simulating the Jump Process using the DiffEqJump Low-level Interface","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We now show how to directly use DiffEqJump's low-level interface to construct and solve our jump process model for (S(t)I(t)R(t)). Each individual jump that can occur is represented through specifying two pieces of information; a rate function (i.e. intensity or propensity) for the jump and an affect function for the jump. The former gives the probability per time a particular jump can occur given the current state of the system, and hence determines the time at which jumps can happen. The later specifies the instantaneous change in the state of the system when the jump occurs.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"In our SIR model we have two possible jumps that can occur (one for susceptibles becoming infected and one for infected becoming recovered), with the corresponding (mathematical) rates and affects given by","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginmatrix\ntextRates  textAffects\nhline\nbeta S(t) I(t)  S to S - 1 I to I + 1 \nnu I(t)  I to I - 1  R to R + 1\nendmatrix","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"DiffEqJump offers three different ways to represent jumps: MassActionJump, ConstantRateJump, and VariableRateJump. Choosing which to use is a trade off between the desired generality of the rate and affect functions vs. the computational performance of the resulting simulated system. In general","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Jump Type Performance Generality\nMassActionJump Fastest Restrictive rates/affects\nConstantRateJump Somewhat Slower Much more general\nVariableRateJump Slowest Completely general","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"It is recommended to try to encode jumps using the most performant option that supports the desired generality of the underlying rate and affect functions. Below we describe the different jump types, and show how the SIR model can be formulated using first ConstantRateJumps and then MassActionJumps (VariableRateJumps are considered later).","category":"page"},{"location":"tutorials/discrete_stochastic_example/#ConstantRateJumpSect","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Defining the Jumps Directly: ConstantRateJump","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"The constructor for a ConstantRateJump is:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump = ConstantRateJump(rate, affect!)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"where rate is a function rate(u,p,t) and affect! is a function of the integrator affect!(integrator) (for details on the integrator, see the integrator interface docs). Here u corresponds to the current state of the system; for our SIR model u[1]=S(t), u[2]=I(t) and u[3]=R(t). p corresponds to the parameters of the model, just as used for passing parameters to derivative functions in ODE solvers. Thus, to define the two possible jumps for our model we take (with β=.1/1000.0 and ν=.01).","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using DiffEqJump\nβ = 0.1 / 1000.0; ν = .01;\np = (β,ν)\nrate1(u,p,t) = p[1]*u[1]*u[2]  # β*S*I\nfunction affect1!(integrator)\n  integrator.u[1] -= 1         # S -> S - 1\n  integrator.u[2] += 1         # I -> I + 1\nend\njump = ConstantRateJump(rate1,affect1!)\n\nrate2(u,p,t) = p[2]*u[2]      # ν*I\nfunction affect2!(integrator)\n  integrator.u[2] -= 1        # I -> I - 1\n  integrator.u[3] += 1        # R -> R + 1\nend\njump2 = ConstantRateJump(rate2,affect2!)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We will start with 999 susceptible people, 1 infected person, and 0 recovered people, and solve the problem from t=0.0 to t=250.0 so that","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"u₀    = [999,1,0]\ntspan = (0.0,250.0)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice, the initial populations are integers since we want the exact number of people in the different states.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Since we want integer, discrete changes in the numbers of the different types of people, we will build a DiscreteProblem.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"prob = DiscreteProblem(u₀, tspan, p)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We can then use JumpProblem from DiffEqJump to augment the discrete problem with jumps and select the stochastic simulation algorithm (SSA) to use in sampling the jump processes. To create a JumpProblem we would simply do:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump_prob = JumpProblem(prob, Direct(), jump, jump2)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Here Direct() indicates that we will determine the random times and types of jumps that occur using Gillespie's Direct stochastic simulation algorithm (SSA). See Constant Rate Jump Aggregators for other supported SSAs.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We now have a problem that can be evolved in time using the DiffEqJump solvers. Since our model is a pure jump process (no continuously-varying components), we will use SSAStepper() to handle time-stepping the Direct method from jump to jump:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"sol = solve(jump_prob, SSAStepper())","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"This solve command takes the standard commands of the common interface, and the solution object acts just like any other differential equation solution. Thus there exists a plot recipe, which we can plot with:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using Plots; plot(sol)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"(Image: SIR Solution)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note, in systems with more than a few jumps (more than ~10), it can be advantageous to use more sophisticated SSAs than Direct. For such systems it is recommended to use SortingDirect, RSSA or RSSACR, see the list of DiffEqJump SSAs at Constant Rate Jump Aggregators.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#*Caution-about-Constant-Rate-Jumps*","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Caution about Constant Rate Jumps","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"ConstantRateJumps are quite general, but they do have one restriction. They assume that the rate functions are constant at all times between two consecutive jumps of the system. i.e. any species/states or parameters that the rate function depends on must not change between the times at which two consecutive jumps occur. Such conditions are violated if one has a time dependent parameter like beta(t) or if some of the solution components, say u[2], may also evolve through a coupled ODE or SDE (see below for examples). For problems where the rate function may change between consecutive jumps, VariableRateJumps must be used.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Thus in the examples above,","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"rate1(u,p,t) = p[1]*u[1]*u[2]\nrate2(u,p,t) = p[2]*u[2]","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"both must be constant other than changes due to some other ConstantRateJump or MassActionJump (the same restriction applies to MassActionJumps). Since these rates only change when u[1] or u[2] is changed, and u[1] and u[2] only change when one of the jumps occur, this setup is valid. However, a rate of t*p[1]*u[1]*u[2] would not be valid because the rate would change during the interval, as would p[2]*u[1]*u[4] when u[4] is the solution to a continuous problem such as an ODE or SDE. Thus one must be careful to follow this rule when choosing rates.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"If your problem must have the rates depend on a continuously changing quantity, you need to use the VariableRateJump.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#SSAStepper","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"SSAStepper","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Any common interface algorithm can be used to perform the time-stepping since it is implemented over the callback interface. This allows for hybrid systems that mix ODEs, SDEs and jumps. In many cases we may have a pure jump system that only involves ConstantRateJumps and/or MassActionJumps (see below). When that's the case, a substantial performance benefit may be gained by using SSAStepper(). Note, SSAStepper is a more limited time-stepper which only supports discrete events, and does not allow simultaneous coupled ODEs or SDEs. It is, however, very efficient for pure jump problems.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#save_positions_docs","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Reducing Memory Use: Controlling Saving Behavior","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note that jumps act via the callback interface which defaults to saving at each event. The reason is because this is required in order to accurately resolve every discontinuity exactly (and this is what allows for perfectly vertical lines in plots!). However, in many cases when using jump problems you may wish to decrease the saving pressure given by large numbers of jumps. To do this, you set save_positions in the JumpProblem. Just like for other callbacks, this is a tuple (bool1,bool2) which sets whether to save before or after a jump. If we do not want to save at every jump, we would thus pass:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump_prob = JumpProblem(prob, Direct(), jump, jump2, save_positions=(false,false))","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Now the saving controls associated with the integrator are the only ones to note. For example, we can use saveat=0.5 to save at an evenly spaced grid:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"sol = solve(jump_prob, SSAStepper(), saveat=0.5)","category":"page"},{"location":"tutorials/discrete_stochastic_example/#MassActionJumpSect","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Defining the Jumps Directly: MassActionJump","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"For jumps that can be represented as mass action reactions, a further specialization of the jump type is possible that offers improved computational performance; MassActionJump. Suppose the system has N chemical species S_1dotsS_N. A general mass action reaction has the form","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"R_1 S_1 + R_2 S_2 + dots + R_N S_N oversetkrightarrow P_1 S_1 + P_2 S_2 + dots + P_N S_N","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"where the non-negative integers (R_1dotsR_N) denote the reactant stoichiometry of the reaction, and the non-negative integers (P_1dotsP_N) the product stoichiometry. The net stoichiometry is the net change in each chemical species from the reaction occurring one time, given by (P_1-R_1dotsP_N-R_N).","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"As an example, consider again the SIR model defined in the @reaction_network above. The species are then (S,I,R). The first reaction has rate β, reactant stoichiometry (1,1,0), product stoichiometry (0,2,0), and net stoichiometry (-1,1,0). The second reaction has rate ν, reactant stoichiometry (0,1,0), product stoichiometry (0,0,1), and net stoichiometry (0,-1,1).","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We can manually encode this system as a mass action jump by specifying the indexes of the rate constants in p, the reactant stoichiometry, and the net stoichiometry as follows:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"rateidxs = [1, 2]    # i.e. [β,ν]\nreactant_stoich =\n[\n  [1 => 1, 2 => 1],         # 1*S and 1*I\n  [2 => 1]                  # 1*I\n]\nnet_stoich =\n[\n  [1 => -1, 2 => 1],        # -1*S and 1*I\n  [2 => -1, 3 => 1]         # -1*I and 1*R\n]\nmass_act_jump = MassActionJump(reactant_stoich, net_stoich; param_idxs=rateidxs)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice, one typically should define one MassActionJump that encodes each possible jump that can be represented via a mass action reaction. This is in contrast to ConstantRateJumps or VariableRateJumps where separate instances are created for each distinct jump type.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Just like for ConstantRateJumps, to then simulate the system we create a JumpProblem and call solve:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump_prob = JumpProblem(prob, Direct(), mass_act_jump)\nsol = solve(jump_prob, SSAStepper())","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"For more details about MassActionJumps see Defining a Mass Action Jump.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note, for chemical reaction systems, Catalyst.jl automatically groups reactions into their optimal jump representation.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Defining-the-Jumps-Directly:-Mixing-ConstantRateJump-and-MassActionJump","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Defining the Jumps Directly: Mixing ConstantRateJump and MassActionJump","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Suppose we now want to add in to the SIR model another jump that can not be represented as a mass action reaction. We can create a new ConstantRateJump and simulate a hybrid system using both the MassActionJump for the two previous reactions, and the new ConstantRateJump. Let's suppose we want to let susceptible people be born with the following jump rate:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"birth_rate(u,p,t) = 10.0*u[1]/(200. + u[1]) + 10.\nfunction birth_affect!(integrator)\n  integrator.u[1] += 1\nend\nbirth_jump = ConstantRateJump(birth_rate, birth_affect!)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We can then simulate the hybrid system as","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump_prob = JumpProblem(prob, Direct(), mass_act_jump, birth_jump)\nsol = solve(jump_prob, SSAStepper())","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"(Image: gillespie_hybrid_jumps)","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Adding-Jumps-to-a-Differential-Equation","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Adding Jumps to a Differential Equation","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"If we instead used some form of differential equation instead of a DiscreteProblem, we would couple the jumps/reactions to the differential equation. Let's define an ODE problem, where the continuous part only acts on some new 4th component:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using OrdinaryDiffEq\nfunction f(du,u,p,t)\n  du[4] = u[2]*u[3]/100000 - u[1]*u[4]/100000\nend\nu₀   = [999.0,1.0,0.0,100.0]\nprob = ODEProblem(f,u₀,tspan,p)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice we gave the 4th component a starting value of 100.0, and used floating point numbers for the initial condition since some solution components now evolve continuously. The same steps as above will allow us to solve this hybrid equation when using ConstantRateJumps (or MassActionJumps). For example, we can solve it using the Tsit5() method via:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump_prob = JumpProblem(prob,Direct(),jump,jump2)\nsol = solve(jump_prob,Tsit5())","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"(Image: gillespie_ode)","category":"page"},{"location":"tutorials/discrete_stochastic_example/#VariableRateJumpSect","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Adding a VariableRateJump","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Now let's consider adding a reaction whose rate changes continuously with the differential equation. To continue our example, let's let there be a new jump/reaction with rate depending on u[4]","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"rate3(u,p,t) = 1e-2*u[4]\nfunction affect3!(integrator)\n  integrator.u[2] += 1\nend\njump3 = VariableRateJump(rate3,affect3!)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice, since rate3 depends on a variable that evolves continuously, and hence is not constant between jumps, we must use a VariableRateJump.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Solving the equation is exactly the same:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"u₀   = [999.0,1.0,0.0,1.0]\nprob = ODEProblem(f,u₀,tspan,p)\njump_prob = JumpProblem(prob,Direct(),jump,jump2,jump3)\nsol = solve(jump_prob,Tsit5())","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"(Image: variable_rate_gillespie)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note that VariableRateJumps require a continuous problem, like an ODE/SDE/DDE/DAE problem.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Lastly, we are not restricted to ODEs. For example, we can solve the same jump problem except with multiplicative noise on u[4] by using an SDEProblem instead:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using StochasticDiffEq\nfunction g(du,u,p,t)\n  du[4] = 0.1u[4]\nend\n\nprob = SDEProblem(f,g,[999.0,1.0,0.0,1.0],(0.0,250.0), p)\njump_prob = JumpProblem(prob,Direct(),jump,jump2,jump3)\nsol = solve(jump_prob,SRIW1())","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"(Image: sde_gillespie)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"For more details about VariableRateJumps see Defining a Variable Rate Jump.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#RegularJumps-and-Tau-Leaping","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"RegularJumps and Tau-Leaping","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"The previous parts described how to use ConstantRateJumps, MassActionJumps, and VariableRateJumps to add jumps to differential equation algorithms over the callback interface. However, in many cases you do not need to step to every jump time. Instead, regular jumping allows you to pool together jumps and perform larger updates in a statistically-correct but more efficient manner.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"For RegularJumps, we pool together the jumps we wish to perform. Here our rate is a vector equation which computes the rates of each jump process together:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"function rate(out,u,p,t)\n    out[1] = (0.1/1000.0)*u[1]*u[2]\n    out[2] = 0.01u[2]\nend","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"and then we compute the total change matrix c","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"function c(dc,u,p,t,mark)\n    dc[1,1] = -1\n    dc[2,1] = 1\n    dc[2,2] = -1\n    dc[3,2] = 1\nend","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"where each column is a different jump process. We then declare the form of dc and build a RegularJump:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"dc = zeros(3,2)\nrj = RegularJump(rate,c,dc;constant_c=true)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"From there we build a JumpProblem:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"prob = DiscreteProblem([999.0,1.0,0.0],(0.0,250.0))\njump_prob = JumpProblem(prob,Direct(),rj)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note that when a JumpProblem has a RegularJump, special algorithms are required. This is detailed on the jump solvers page. One such algorithm is SimpleTauLeaping, which we use as follows:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"sol = solve(jump_prob,SimpleTauLeaping();dt=1.0)","category":"page"},{"location":"tutorials/jump_diffusion/#Jump-Diffusion-Equations","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"","category":"section"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"note: Note\nThis tutorial assumes you have read the Ordinary Differential Equations tutorial in DifferentialEquations.jl.","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"Jump Diffusion equations are stochastic differential equations with discontinuous jumps. These can be written as:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"du = f(upt)dt + sum_jg_j(upt)dW_j(t) + sum_ih_i(upt)dN_i(t)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"where N_i is a Poisson-counter which denotes jumps of size h_i. In this tutorial we will show how to solve problems with even more general jumps.","category":"page"},{"location":"tutorials/jump_diffusion/#Defining-a-ConstantRateJump-Problem","page":"Jump Diffusion Equations","title":"Defining a ConstantRateJump Problem","text":"","category":"section"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"To start, let's solve an ODE with constant rate jumps. A jump is defined as being \"constant rate\" if the rate is only dependent on values from other constant rate jumps, meaning that its rate must not be coupled with time or the solution to the differential equation. However, these types of jumps are cheaper to compute.","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"(Note: if your rate is only \"slightly\" dependent on the solution of the differential equation, then it may be okay to use a ConstantRateJump. Accuracy loss will be related to the percentage that the rate changes over the jump intervals.)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"Let's solve the following problem. We will have a linear ODE with a Poisson counter of rate 2 (which is the mean and variance), where at each jump the current solution will be halved. To solve this problem, we first define the ODEProblem:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"function f(du,u,p,t)\n  du[1] = u[1]\nend\n\nprob = ODEProblem(f,[0.2],(0.0,10.0))","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"Notice that, even though our equation is on 1 number, we define it using the in-place array form. Variable rate jump equations will require this form. Note that for this tutorial we solve a one-dimensional problem, but the same syntax applies for solving a system of differential equations with multiple jumps.","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"Now we define our rate equation for our jump. Since it's just the constant value 2, we do:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"rate(u,p,t) = 2","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"Now we define the affect! of the jump. This is the same as an affect! from a DiscreteCallback, and thus acts directly on the integrator. Therefore, to make it halve the current value of u, we do:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"affect!(integrator) = (integrator.u[1] = integrator.u[1]/2)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"Then we build our jump:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"jump = ConstantRateJump(rate,affect!)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"Next, we extend our ODEProblem to a JumpProblem by attaching the jump:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"jump_prob = JumpProblem(prob,Direct(),jump)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"We can now solve this extended problem using any ODE solver:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"sol = solve(jump_prob,Tsit5())\nplot(sol)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"(Image: constant_rate_jump)","category":"page"},{"location":"tutorials/jump_diffusion/#Variable-Rate-Jumps","page":"Jump Diffusion Equations","title":"Variable Rate Jumps","text":"","category":"section"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"Now let's define a jump which is coupled to the differential equation. Let's let the rate be the current value of the solution, that is:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"rate(u,p,t) = u[1]","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"Using the same affect!","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"affect!(integrator) = (integrator.u[1] = integrator.u[1]/2)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"we build a VariableRateJump:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"jump = VariableRateJump(rate,affect!)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"To make things interesting, let's copy this jump:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"jump2 = deepcopy(jump)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"so that way we have two independent jump processes. We now couple these jumps to the ODEProblem:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"jump_prob = JumpProblem(prob,Direct(),jump,jump2)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"which we once again solve using an ODE solver:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"sol = solve(jump_prob,Tsit5())\nplot(sol)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"(Image: variable_rate_jump)","category":"page"},{"location":"tutorials/jump_diffusion/#Jump-Diffusion","page":"Jump Diffusion Equations","title":"Jump Diffusion","text":"","category":"section"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"Now we will finally solve the jump diffusion problem. The steps are the same as before, except we now start with a SDEProblem instead of an ODEProblem. Using the same drift function f as before, we add multiplicative noise via:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"function g(du,u,p,t)\n  du[1] = u[1]\nend\n\nprob = SDEProblem(f,g,[0.2],(0.0,10.0))","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"and couple it to the jumps:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"jump_prob = JumpProblem(prob,Direct(),jump,jump2)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"We then solve it using an SDE algorithm:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"sol = solve(jump_prob,SRIW1())\nplot(sol)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"(Image: jump_diffusion)","category":"page"},{"location":"tutorials/jump_diffusion/#Coupling-Jump-Problems","page":"Jump Diffusion Equations","title":"Coupling Jump Problems","text":"","category":"section"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"In many applications one is interested in coupling two stochastic processes. This has applications in Monte Carlo simulations and sensitivity analysis, for example. Currently, the coupling that is implemented for jump processes is known as the split coupling. The split coupling couples two jump processes by coupling the underlying Poisson processes driving the jump components.","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"Suppose prob and prob_control are two problems we wish to couple. Then the coupled problem is obtained by","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"prob_coupled =  SplitCoupledJumpProblem(jump_prob,jump_prob_control,Direct(),coupling_map)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"Here, coupling_map specifies which jumps to couple. If (j,i) is in coupling_map, then the ith jump in prob will be coupled to the jth jump in prob_control. Note that currently SplitCoupledJumpProblem is only implemented for constant rate jump problems.","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"As an example, consider a doubly stochastic Poisson process, that is, a Poisson process whose rate is itself a stochastic process. In particular, we will take the rate to randomly switch between zero and 10 at unit rates:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"rate(u,p,t) = u[2]*10\naffect!(integrator) = integrator.u[1] += 1.\njump1 = ConstantRateJump(rate,affect!)\nrate(u,p,t) = u[2]\naffect!(integrator) = (integrator.u[2] -= 1.;integrator.u[3] += 1.)\njump2 = ConstantRateJump(rate,affect!)\n\nrate(u,p,t) = u[3]\naffect!(integrator) = (integrator.u[2] += 1.;integrator.u[3] -= 1.)\njump3 = ConstantRateJump(rate,affect!)\nprob = DiscreteProblem(u0,tspan)\njump_prob = JumpProblem(prob,Direct(),jump1,jump2,jump3)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"The doubly stochastic poisson process has two sources of randomness: one due to the Poisson process, and another due to random evolution of the rate. This is typical of many multiscale stochastic processes appearing in applications, and it is often useful to compare such a process to one obtained by removing one source of randomness. In present context, this means looking at an ODE with constant jump rates, where the deterministic evolution between jumps is given by the expected value of the Poisson process:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"function f(du,u,p,t)\n  du[1] = u[2]*10\n  du[2] = 0.\n  du[3] = 0.\nend\nprob_control = ODEProblem(f,u0,tspan)\njump_prob_control = JumpProblem(prob_control,Direct(),jump2,jump3)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"Let's couple the two problems by coupling the jumps corresponding the switching of the rate:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"coupling_map = [(2,1),(3,2)]\nprob_coupled =  SplitCoupledJumpProblem(jump_prob,jump_prob_control,Direct(),coupling_map)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"Now prob_coupled will be dealt with like any other JumpProblem:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"sol = solve(prob_coupled,Tsit5())","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Jump Diffusion Equations","title":"Jump Diffusion Equations","text":"(Image: jump_diffusion)","category":"page"},{"location":"jump_types/#Jump-Problems","page":"Jump types and JumProblem","title":"Jump Problems","text":"","category":"section"},{"location":"jump_types/#Mathematical-Specification-of-an-problem-with-jumps","page":"Jump types and JumProblem","title":"Mathematical Specification of an problem with jumps","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"Jumps are defined as a Poisson process which changes states at some rate. When there are multiple possible jumps, the process is a compound Poisson process. On its own, a jump equation is a continuous-time Markov Chain where the time to the next jump is exponentially distributed as calculated by the rate. This type of process, known in biology as \"Gillespie discrete stochastic simulations\" and modeled by the Chemical Master Equation (CME), is the same thing as adding jumps to a DiscreteProblem. However, any differential equation can be extended by jumps as well. For example, we have an ODE with jumps, denoted by","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"fracdudt = f(upt) + sum_ic_i(upt)p_i(t)","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"where p_i is a Poisson counter of rate lambda_i(upt). Extending a stochastic differential equation to have jumps is commonly known as a Jump Diffusion, and is denoted by","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"du = f(upt)dt + sum_jg_j(ut)dW_j(t) + sum_ic_i(upt)dp_i(t)","category":"page"},{"location":"jump_types/#Types-of-Jumps:-Regular,-Variable,-Constant-Rate-and-Mass-Action","page":"Jump types and JumProblem","title":"Types of Jumps: Regular, Variable, Constant Rate and Mass Action","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"A RegularJump is a set of jumps that do not make structural changes to the underlying equation. These kinds of jumps only change values of the dependent variable (u) and thus can be treated in an inexact manner. Other jumps, such as those which change the size of u, require exact handling which is also known as time-adaptive jumping. These can only be specified as a ConstantRateJump, MassActionJump, or a VariableRateJump.","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"We denote a jump as variable rate if its rate function is dependent on values which may change between constant rate jumps. For example, if there are multiple jumps whose rates only change when one of them occur, than that set of jumps is a constant rate jump. If a jump's rate depends on the differential equation, time, or by some value which changes outside of any constant rate jump, then it is denoted as variable.","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"A MassActionJump is a specialized representation for a collection of constant rate jumps that can each be interpreted as a standard mass action reaction. For systems comprised of many mass action reactions, using the MassActionJump type will offer improved performance. Note, only one MassActionJump should be defined per JumpProblem; it is then responsible for handling all mass action reaction type jumps. For systems with both mass action jumps and non-mass action jumps, one can create one MassActionJump to handle the mass action jumps, and create a number of ConstantRateJumps to handle the non-mass action jumps.","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"RegularJumps are optimized for regular jumping algorithms like tau-leaping and hybrid algorithms. ConstantRateJumps and MassActionJumps are optimized for SSA algorithms. ConstantRateJumps, MassActionJumps and VariableRateJumps can be added to standard DiffEq algorithms since they are simply callbacks, while RegularJumps require special algorithms. ","category":"page"},{"location":"jump_types/#Defining-a-Regular-Jump","page":"Jump types and JumProblem","title":"Defining a Regular Jump","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"The constructor for a RegularJump is:","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"RegularJump(rate,c,numjumps;mark_dist = nothing)","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"rate(out,u,p,t) is the function which computes the rate for every regular jump process\nc(du,u,p,t,counts,mark) is calculates the update given counts number of jumps for each jump process in the interval.\nnumjumps is the number of jump processes, i.e. the number of rate equations and the number of counts\nmark_dist is the distribution for the mark.","category":"page"},{"location":"jump_types/#Defining-a-Constant-Rate-Jump","page":"Jump types and JumProblem","title":"Defining a Constant Rate Jump","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"The constructor for a ConstantRateJump is:","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"ConstantRateJump(rate,affect!)","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"rate(u,p,t) is a function which calculates the rate given the time and the state.\naffect!(integrator) is the effect on the equation, using the integrator interface.","category":"page"},{"location":"jump_types/#Defining-a-Mass-Action-Jump","page":"Jump types and JumProblem","title":"Defining a Mass Action Jump","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"The constructor for a MassActionJump is:","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"MassActionJump(reactant_stoich, net_stoich; scale_rates = true, param_idxs=nothing)","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"reactant_stoich is a vector whose kth entry is the reactant stoichiometry of the kth reaction. The reactant stoichiometry for an individual reaction is assumed to be represented as a vector of Pairs, mapping species id to stoichiometric coefficient.\nnet_stoich is assumed to have the same type as reactant_stoich; a vector whose kth entry is the net stoichiometry of the kth reaction. The net stoichiometry for an individual reaction is again represented as a vector of Pairs, mapping species id to the net change in the species when the reaction occurs.\nscale_rates is an optional parameter that specifies whether the rate constants correspond to stochastic rate constants in the sense used by Gillespie, and hence need to be rescaled. The default, scale_rates=true, corresponds to rescaling the passed in rate constants. See below.\nparam_idxs is a vector of the indices within the parameter vector, p, that correspond to the rate constant for each jump.","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"Notes for Mass Action Jumps","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"When using MassActionJump the default behavior is to assume rate constants correspond to stochastic rate constants in the sense used by Gillespie (J. Comp. Phys., 1976, 22 (4)). This means that for a reaction such as 2A oversetkrightarrow B, the jump rate function constructed by MassActionJump would be k*A*(A-1)/2!. For a trimolecular reaction like 3A oversetkrightarrow B the rate function would be k*A*(A-1)*(A-2)/3!. To avoid having the reaction rates rescaled (by 1/2 and 1/6 for these two examples), one can pass the MassActionJump constructor the optional named parameter scale_rates=false, i.e. use\nMassActionJump(reactant_stoich, net_stoich; scale_rates = false, param_idxs)\nZero order reactions can be passed as reactant_stoichs in one of two ways. Consider the varnothing oversetkrightarrow A reaction with rate k=1:\np = [1.]\nreactant_stoich = [[0 => 1]]\nnet_stoich = [[1 => 1]]\njump = MassActionJump(reactant_stoich, net_stoich; param_idxs=[1])\nAlternatively one can create an empty vector of pairs to represent the reaction:\np = [1.]\nreactant_stoich = [Vector{Pair{Int,Int}}()]\nnet_stoich = [[1 => 1]]\njump = MassActionJump(reactant_stoich, net_stoich; param_idxs=[1])\nFor performance reasons, it is recommended to order species indices in stoichiometry vectors from smallest to largest. That is \nreactant_stoich = [[1 => 2, 3 => 1, 4 => 2], [2 => 2, 3 => 2]]\nis preferred over\nreactant_stoich = [[3 => 1, 1 => 2, 4 = > 2], [3 => 2, 2 => 2]]","category":"page"},{"location":"jump_types/#Defining-a-Variable-Rate-Jump","page":"Jump types and JumProblem","title":"Defining a Variable Rate Jump","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"The constructor for a VariableRateJump is:","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"VariableRateJump(rate,affect!;\n                   idxs = nothing,\n                   rootfind=true,\n                   save_positions=(true,true),\n                   interp_points=10,\n                   abstol=1e-12,reltol=0)","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"Note that this is the same as defining a ContinuousCallback, except that instead of the condition function, you provide a rate(u,p,t) function for the rate at a given time and state.","category":"page"},{"location":"jump_types/#Defining-a-Jump-Problem","page":"Jump types and JumProblem","title":"Defining a Jump Problem","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"To define a JumpProblem, you must first define the basic problem. This can be a DiscreteProblem if there is no differential equation, or an ODE/SDE/DDE/DAE if you would like to augment a differential equation with jumps. Denote this previously defined problem as prob. Then the constructor for the jump problem is:","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"JumpProblem(prob,aggregator::Direct,jumps::JumpSet;\n            save_positions = typeof(prob) <: AbstractDiscreteProblem ? (false,true) : (true,true))","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"The aggregator is the method for aggregating the constant jumps. These are defined below. jumps is a JumpSet which is just a gathering of jumps. Instead of passing a JumpSet, one may just pass a list of jumps themselves. For example:","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"JumpProblem(prob,aggregator,jump1,jump2)","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"and the internals will automatically build the JumpSet. save_positions is the save_positions argument built by the aggregation of the constant rate jumps.","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"Note that a JumpProblem/JumpSet can only have 1 RegularJump (since a RegularJump itself describes multiple processes together). Similarly, it can only have one MassActionJump (since it also describes multiple processes together).","category":"page"},{"location":"jump_types/#Constant-Rate-Jump-Aggregators","page":"Jump types and JumProblem","title":"Constant Rate Jump Aggregators","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"Constant rate jump aggregators are the methods by which constant rate jumps, including MassActionJumps, are lumped together. This is required in all algorithms for both speed and accuracy. The current methods are:","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"Direct: the Gillespie Direct method SSA.\nRDirect: A variant of Gillespie's Direct method that uses rejection to sample the next reaction.\nDirectCR: The Composition-Rejection Direct method of Slepoy et al. For large networks and linear chain-type networks it will often give better performance than Direct. (Requires dependency graph, see below.)\nDirectFW: the Gillespie Direct method SSA with FunctionWrappers. This aggregator uses a different internal storage format for collections of ConstantRateJumps. \nFRM: the Gillespie first reaction method SSA. Direct should generally offer better performance and be preferred to FRM.\nFRMFW: the Gillespie first reaction method SSA with FunctionWrappers.\nNRM: The Gibson-Bruck Next Reaction Method. For some reaction network  structures this may offer better performance than Direct (for example,  large, linear chains of reactions). (Requires dependency graph, see below.) \nRSSA: The Rejection SSA (RSSA) method of Thanh et al. With RSSACR, for very large reaction networks it often offers the best performance of all methods. (Requires dependency graph, see below.)\nRSSACR: The Rejection SSA (RSSA) with Composition-Rejection method of Thanh et al. With RSSA, for very large reaction networks it often offers the best performance of all methods. (Requires dependency graph, see below.)\nSortingDirect: The Sorting Direct Method of McCollum et al. It will usually offer performance as good as Direct, and for some systems can offer substantially better performance. (Requires dependency graph, see below.)","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"To pass the aggregator, pass the instantiation of the type. For example:","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"JumpProblem(prob,Direct(),jump1,jump2)","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"will build a problem where the constant rate jumps are solved using Gillespie's Direct SSA method.","category":"page"},{"location":"jump_types/#Constant-Rate-Jump-Aggregators-Requiring-Dependency-Graphs","page":"Jump types and JumProblem","title":"Constant Rate Jump Aggregators Requiring Dependency Graphs","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"Italicized constant rate jump aggregators require the user to pass a dependency graph to JumpProblem. DirectCR, NRM and SortingDirect require a jump-jump dependency graph, passed through the named parameter dep_graph. i.e.","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"JumpProblem(prob,DirectCR(),jump1,jump2; dep_graph=your_dependency_graph)","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"For systems with only MassActionJumps, or those generated from a Catalyst reaction_network, this graph will be auto-generated. Otherwise you must construct the dependency graph manually. Dependency graphs are represented as a Vector{Vector{Int}}, with the ith vector containing the indices of the jumps for which rates must be recalculated when the ith jump occurs. Internally, all MassActionJumps are ordered before ConstantRateJumps (with the latter internally ordered in the same order they were passed in).","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"RSSA and RSSACR require two different types of dependency graphs, passed through the following JumpProblem kwargs:","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"vartojumps_map - A Vector{Vector{Int}} mapping each variable index, i, to a set of jump indices. The jump indices correspond to jumps with rate functions that depend on the value of u[i].\njumptovars_map - A Vector{Vector{Int}}  mapping each jump index to a set  of variable indices. The corresponding variables are those that have their  value, u[i], altered when the jump occurs.","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"For systems generated from a Catalyst reaction_network these will be auto-generated. Otherwise you must explicitly construct and pass in these mappings.","category":"page"},{"location":"jump_types/#Recommendations-for-Constant-Rate-Jumps","page":"Jump types and JumProblem","title":"Recommendations for Constant Rate Jumps","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"For representing and aggregating constant rate jumps ","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"Use a MassActionJump to handle all jumps that can be represented as mass action reactions. This will generally offer the fastest performance. \nUse ConstantRateJumps for any remaining jumps.\nFor a small number of jumps, < ~10, Direct will often perform as well as the other aggregators.\nFor > ~10 jumps SortingDirect will often offer better performance than Direct.\nFor large numbers of jumps with sparse chain like structures and similar jump rates, for example continuous time random walks, RSSACR, DirectCR and then NRM often have the best performance.\nFor very large networks, with many updates per jump, RSSA and RSSACR will often substantially outperform the other methods. ","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"In general, for systems with sparse dependency graphs if Direct is slow, one of SortingDirect, RSSA or RSSACR will usually offer substantially better performance. See DiffEqBenchmarks.jl for benchmarks on several example networks.","category":"page"},{"location":"jump_types/#Remaking-JumpProblems","page":"Jump types and JumProblem","title":"Remaking JumpProblems","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"When running many simulations, it can often be convenient to update the initial condition or simulation parameters without having to create and initialize a new JumpProblem. In such situations remake can be used to change the initial condition, time span, and the parameter vector. Note, the new JumpProblem will alias internal data structures from the old problem, including core components of the SSA aggregators. As such, only the new problem generated by remake should be used for subsequent simulations.","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"As an example, consider the following SIR model:","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"rate1(u,p,t) = (0.1/1000.0)*u[1]*u[2]\nfunction affect1!(integrator)\n  integrator.u[1] -= 1\n  integrator.u[2] += 1\nend\njump = ConstantRateJump(rate1,affect1!)\n\nrate2(u,p,t) = 0.01u[2]\nfunction affect2!(integrator)\n  integrator.u[2] -= 1\n  integrator.u[3] += 1\nend\njump2 = ConstantRateJump(rate2,affect2!)\nu0    = [999,1,0]\np     = (0.1/1000,0.01)\ntspan = (0.0,250.0)\ndprob = DiscreteProblem(u0, tspan, p)\njprob = JumpProblem(dprob, Direct(), jump, jump2)\nsol   = solve(jprob, SSAStepper())","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"We can change any of u0, p and tspan by either making a new DiscreteProblem","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"u02    = [10,1,0]\np2     = (.1/1000, 0.0)\ntspan2 = (0.0,2500.0)\ndprob2 = DiscreteProblem(u02, tspan2, p2)\njprob2 = remake(jprob, prob=dprob2)\nsol2   = solve(jprob2, SSAStepper())","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"or by directly remaking with the new parameters","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"jprob2 = remake(jprob, u0=u02, p=p2, tspan=tspan2)\nsol2   = solve(jprob2, SSAStepper())","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"To avoid ambiguities, the following will give an error","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"jprob2 = remake(jprob, prob=dprob2, u0=u02)","category":"page"},{"location":"jump_types/","page":"Jump types and JumProblem","title":"Jump types and JumProblem","text":"as will trying to update either p or tspan while passing a new DiscreteProblem using the prob kwarg.","category":"page"},{"location":"jump_solve/#jump_solve","page":"Jump solvers","title":"Jump Problem and Jump Diffusion Solvers","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"solve(prob::JumpProblem,alg;kwargs)","category":"page"},{"location":"jump_solve/#Recommended-Methods","page":"Jump solvers","title":"Recommended Methods","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"A JumpProblem(prob,aggregator,jumps...) come in two forms. The first major form is if it does not have a RegularJump. In this case, it can be solved with any integrator on  prob. However, in the case of a pure JumpProblem (a JumpProblem over a  DiscreteProblem), there are special algorithms available.  The SSAStepper() is an efficient streamlined algorithm for running the  aggregator version of the SSA for pure ConstantRateJump and/or MassActionJump problems. However, it is not compatible with event handling. If events are necessary, then FunctionMap does well.","category":"page"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"If there is a RegularJump, then specific methods must be used. The current recommended method is TauLeaping if you need adaptivity, events, etc. If you just need the most barebones fixed time step leaping method, then SimpleTauLeaping can have performance benefits.","category":"page"},{"location":"jump_solve/#Special-Methods-for-Pure-Jump-Problems","page":"Jump solvers","title":"Special Methods for Pure Jump Problems","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"If you are using jumps with a differential equations, use the same methods as in the case of the differential equation solving. However, the following algorithms are optimized for pure jump problems.","category":"page"},{"location":"jump_solve/#DiffEqJump.jl","page":"Jump solvers","title":"DiffEqJump.jl","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"SSAStepper: a stepping algorithm for pure ConstantRateJump and/or MassActionJump JumpProblems. Supports handling of DiscreteCallback and saving controls like saveat.","category":"page"},{"location":"jump_solve/#RegularJump-Compatible-Methods","page":"Jump solvers","title":"RegularJump Compatible Methods","text":"","category":"section"},{"location":"jump_solve/#StochasticDiffEq.jl","page":"Jump solvers","title":"StochasticDiffEq.jl","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"These methods support mixing with event handling, other jump types, and all of the features of the normal differential equation solvers.","category":"page"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"TauLeaping: an adaptive tau-leaping algorithm with post-leap estimates.","category":"page"},{"location":"jump_solve/#DiffEqJump.jl-2","page":"Jump solvers","title":"DiffEqJump.jl","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"SimpleTauLeaping: a tau-leaping algorithm for pure RegularJump JumpProblems. Requires a choice of dt.\nRegularSSA: a version of SSA for pure RegularJump JumpProblems.","category":"page"},{"location":"jump_solve/#Regular-Jump-Diffusion-Compatible-Methods","page":"Jump solvers","title":"Regular Jump Diffusion Compatible Methods","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"Regular jump diffusions are JumpProblems where the internal problem is an SDEProblem and the jump process has designed a regular jump.","category":"page"},{"location":"jump_solve/#StochasticDiffEq.jl-2","page":"Jump solvers","title":"StochasticDiffEq.jl","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"EM: Explicit Euler-Maruyama.\nImplicitEM: Implicit Euler-Maruyama. See the SDE solvers page for more details.","category":"page"},{"location":"#DiffEqJump.jl","page":"Home","title":"DiffEqJump.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DiffEqJump.jl provides methods for simulating jump processes, known as stochastic simulation algorithms (SSAs), Doob's method, Gillespie methods, or Kinetic Monte Carlo methods across different fields of science. It also enables the incorporation of jump processes into hybrid jump-ODE and jump-SDE models, including jump diffusions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DiffEqJump is a component package in the SciML ecosystem, and one of the core solver libraries included in DifferentialEquations.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation includes","category":"page"},{"location":"","page":"Home","title":"Home","text":"a tutorial and details on using DiffEqJump to simulate jump processes via SSAs (i.e. Gillespie methods),\na reference on the types of jumps and available simulation methods,\na FAQ with information on changing parameters between simulations and using callbacks.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are two ways to install DiffEqJump.jl. First, users may install the meta DifferentialEquations.jl package, which installs and wraps OrdinaryDiffEq.jl for solving ODEs, StochasticDiffEq.jl for solving SDEs, and DiffEqJump.jl, along with a number of other useful packages for solving models involving ODEs, SDEs and/or jump process. This single install will provide the user with all of the facilities for developing and solving Jump problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the DifferentialEquations.jl package, refer to the following link for complete installation details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If the user wishes to separately install the DiffEqJump.jl library, which is a lighter dependency than DifferentialEquations.jl, then the following code will install DiffEqJump.jl using the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DiffEqJump\")","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nThere are a few community forums:\nthe #diffeq-bridged and #sciml-bridged channels on the Julia Slack\nJuliaDiffEq on Gitter\nthe Julia Discourse forums","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also the SciML Community page.","category":"page"},{"location":"faq/#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"faq/#*1.-My-simulation-is-really-slow-and/or-using-a-lot-of-memory,-what-can-I-do?*","page":"FAQ","title":"1. My simulation is really slow and/or using a lot of memory, what can I do?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"To reduce memory use, use save_positions=(false,false) in the JumpProblem constructor as described earlier to turn off saving the system state before and after every jump. Combined with use of saveat in the call to solve this can dramatically reduce memory usage.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"While Direct is often fastest for systems with 10 or less ConstantRateJumps or MassActionJumps, if your system has many jumps or one jump occurs most frequently, other stochastic simulation algorithms may be faster. See Constant Rate Jump Aggregators and the subsequent sections there for guidance on choosing different SSAs (called aggregators in DiffEqJump).","category":"page"},{"location":"faq/#*2.-When-running-many-consecutive-simulations,-for-example-within-an-EnsembleProblem-or-loop,-how-can-I-update-JumpProblems?*","page":"FAQ","title":"2. When running many consecutive simulations, for example within an EnsembleProblem or loop, how can I update JumpProblems?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In Remaking JumpProblems we show how to modify parameters, the initial condition, and other components of a generated JumpProblem. This can be useful when trying to call solve many times while avoiding reallocations of the internal aggregators for each new parameter value or initial condition.","category":"page"},{"location":"faq/#*3.-How-do-I-use-callbacks-with-ConstantRateJump-or-MassActionJump-systems?*","page":"FAQ","title":"3. How do I use callbacks with ConstantRateJump or MassActionJump systems?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Callbacks can be used with ConstantRateJumps and MassActionJumps. When solving a pure jump system with SSAStepper, only discrete callbacks can be used (otherwise a different time stepper is needed).","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Note, when modifying u or p within a callback, you must call reset_aggregated_jumps!(integrator) after making updates. This ensures that the underlying jump simulation algorithms know to reinitialize their internal data structures. Leaving out this call will lead to incorrect behavior!","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"A simple example that uses a MassActionJump and changes the parameters at a specified time in the simulation using a DiscreteCallback is","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"using DiffEqJump\nrs = [[1 => 1],[2=>1]]\nns = [[1 => -1, 2 => 1],[1=>1,2=>-1]]\np  = [1.0,0.0]\nmaj = MassActionJump(rs, ns; param_idxs=[1,2])\nu₀ = [100,0]\ntspan = (0.0,40.0)\ndprob = DiscreteProblem(u₀,tspan,p)\njprob = JumpProblem(dprob,Direct(),maj)\npcondit(u,t,integrator) = t==20.0\nfunction paffect!(integrator)\n  integrator.p[1] = 0.0\n  integrator.p[2] = 1.0\n  reset_aggregated_jumps!(integrator)\nend\nsol = solve(jprob, SSAStepper(), tstops=[20.0], callback=DiscreteCallback(pcondit,paffect!))","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Here at time 20.0 we turn off production of u[2] while activating production of u[1], giving","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"(Image: callback_gillespie)","category":"page"},{"location":"faq/#*4.-How-can-I-define-collections-of-many-different-jumps-and-pass-them-to-JumpProblem?*","page":"FAQ","title":"4. How can I define collections of many different jumps and pass them to JumpProblem?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"We can use JumpSets to collect jumps together, and then pass them into JumpProblems directly. For example, using the MassActionJump and ConstantRateJump defined earlier we can write","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"jset = JumpSet(mass_act_jump, birth_jump)\njump_prob = JumpProblem(prob, Direct(), jset)\nsol = solve(jump_prob, SSAStepper())","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you have many jumps in tuples or vectors it is easiest to use the keyword argument-based constructor:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"cj1 = ConstantRateJump(rate1,affect1!)\ncj2 = ConstantRateJump(rate2,affect2!)\ncjvec = [cj1,cj2]\n\nvj1 = VariableRateJump(rate3,affect3!)\nvj2 = VariableRateJump(rate4,affect4!)\nvjtuple = (vj1,vj2)\n\njset = JumpSet(; constant_jumps=cjvec, variable_jumps=vjtuple,\n                 massaction_jumps=mass_act_jump)","category":"page"},{"location":"faq/#*5.-How-can-I-set-the-random-number-generator-used-in-the-jump-process-sampling-algorithms-(SSAs)?*","page":"FAQ","title":"5. How can I set the random number generator used in the jump process sampling algorithms (SSAs)?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Random number generators can be passed to JumpProblem via the rng keyword argument. Continuing the previous example:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"#] add RandomNumbers\nusing RandomNumbers\njprob = JumpProblem(dprob, Direct(), maj, rng=Xorshifts.Xoroshiro128Star(rand(UInt64)))","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"uses the Xoroshiro128Star generator from RandomNumbers.jl.","category":"page"},{"location":"faq/#*6.-What-are-these-aggregators-and-aggregations-in-DiffEqJump?*","page":"FAQ","title":"6. What are these aggregators and aggregations in DiffEqJump?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"DiffEqJump provides a variety of methods for sampling the time the next ConstantRateJump or MassActionJump occurs, and which jump type happens at that time. These methods are examples of stochastic simulation algorithms (SSAs), also known as Gillespie methods, Doob's method, or Kinetic Monte Carlo methods. In the DiffEqJump terminology we call such methods \"aggregators\", and the cache structures that hold their basic data \"aggregations\". See Constant Rate Jump Aggregators for a list of the available SSA aggregators.","category":"page"},{"location":"faq/#*7.-How-should-jumps-be-ordered-in-dependency-graphs?*","page":"FAQ","title":"7. How should jumps be ordered in dependency graphs?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Internally, DiffEqJump SSAs (aggregators) order all MassActionJumps first, then all ConstantRateJumps. i.e. in the example","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"using DiffEqJump\nrs = [[1 => 1],[2=>1]]\nns = [[1 => -1, 2 => 1],[1=>1,2=>-1]]\np  = [1.0,0.0]\nmaj = MassActionJump(rs, ns; param_idxs=[1,2])\nrate1(u,p,t) = u[1]\nfunction affect1!(integrator)\n  u[1] -= 1\nend\ncj1 = ConstantRateJump(rate1,affect1)\nrate2(u,p,t) = u[2]\nfunction affect2!(integrator)\n  u[2] -= 1\nend\ncj2 = ConstantRateJump(rate2,affect2)\njset = JumpSet(; constant_jumps=[cj1,cj2], massaction_jump=maj)","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The four jumps would be ordered by the first jump in maj, the second jump in maj, cj1, and finally cj2. Any user-generated dependency graphs should then follow this ordering when assigning an integer id to each jump.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"See also Constant Rate Jump Aggregators Requiring Dependency Graphs for more on dependency graphs needed for the various SSAs.","category":"page"}]
}
