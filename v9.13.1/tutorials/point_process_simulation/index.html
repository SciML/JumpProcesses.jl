<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Temporal Point Process (TPP) Simulation · JumpProcesses.jl</title><meta name="title" content="Temporal Point Process (TPP) Simulation · JumpProcesses.jl"/><meta property="og:title" content="Temporal Point Process (TPP) Simulation · JumpProcesses.jl"/><meta property="twitter:title" content="Temporal Point Process (TPP) Simulation · JumpProcesses.jl"/><meta name="description" content="Documentation for JumpProcesses.jl."/><meta property="og:description" content="Documentation for JumpProcesses.jl."/><meta property="twitter:description" content="Documentation for JumpProcesses.jl."/><meta property="og:url" content="https://docs.sciml.ai/JumpProcesses/tutorials/point_process_simulation/"/><meta property="twitter:url" content="https://docs.sciml.ai/JumpProcesses/tutorials/point_process_simulation/"/><link rel="canonical" href="https://docs.sciml.ai/JumpProcesses/tutorials/point_process_simulation/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JumpProcesses.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JumpProcesses.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../simple_poisson_process/">Simple Poisson Processes in JumpProcesses</a></li><li><a class="tocitem" href="../discrete_stochastic_example/">Continuous-Time Jump Processes and Gillespie Methods</a></li><li class="is-active"><a class="tocitem" href>Temporal Point Process (TPP) Simulation</a><ul class="internal"><li><a class="tocitem" href="#TPP-Introduction"><span>TPP Introduction</span></a></li><li><a class="tocitem" href="#Homogeneous-Poisson-Process"><span>Homogeneous Poisson Process</span></a></li><li><a class="tocitem" href="#Multivariate-TPPs"><span>Multivariate TPPs</span></a></li><li><a class="tocitem" href="#More-TPPs"><span>More TPPs</span></a></li></ul></li><li><a class="tocitem" href="../jump_diffusion/">Piecewise Deterministic Markov Processes and Jump Diffusion Equations</a></li><li><a class="tocitem" href="../spatial/">Spatial SSAs with JumpProcesses.jl</a></li></ul></li><li><span class="tocitem">Applications</span><ul><li><a class="tocitem" href="../../applications/advanced_point_process/">Temporal Point Processes (TPP) with JumpProcesses and PointProcesses</a></li></ul></li><li><span class="tocitem">Type Documentation</span><ul><li><a class="tocitem" href="../../jump_types/">Jumps, JumpProblem, and Aggregators</a></li><li><a class="tocitem" href="../../jump_solve/">Jump solvers</a></li></ul></li><li><a class="tocitem" href="../../faq/">FAQ</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Temporal Point Process (TPP) Simulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Temporal Point Process (TPP) Simulation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/JumpProcesses.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/JumpProcesses.jl/blob/master/docs/src/tutorials/point_process_simulation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tpp_tutorial"><a class="docs-heading-anchor" href="#tpp_tutorial">Temporal Point Process (TPP) Simulation</a><a id="tpp_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#tpp_tutorial" title="Permalink"></a></h1><p>JumpProcesses was initially developed to simulate the trajectory of jump processes. Therefore, those with a background in point process might find the nomenclature in the library documentation confusing. In reality, jump and point processes share many things in common, but diverge in scope. This tutorial will demonstrate how to simulate point processes using JumpProcesses.</p><p>Historically, jump processes have been developed in the context of dynamical systems to describe dynamics with sudden changes — the jumps — in a system&#39;s value at random times. In contrast, the development of point processes has been more focused on describing the occurrence of random events — the points — over a support. The fact that any temporal point process (TPP) that satisfies some basic assumptions can be described in terms of a stochastic differential equation (SDE) with discontinuous jumps — more commonly known as a jump process — means TPPs can be simulated with JumpProcesses.</p><p>Once you complete this tutorial, you might want to check our <a href="../../applications/advanced_point_process/#tpp_advanced">advanced tutorial on TPP</a> that discusses more applications of JumpProcesses to TPP.</p><h2 id="TPP-Introduction"><a class="docs-heading-anchor" href="#TPP-Introduction">TPP Introduction</a><a id="TPP-Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#TPP-Introduction" title="Permalink"></a></h2><p>TPPs describe a set of discrete points over continuous time. Conventionally, we assume that time starts at <span>$0$</span>. We can represent a TPP as a random integer measure <span>$N( \cdot )$</span>. This random function counts the number of points in a set of intervals over the real line. For instance, <span>$N([5, 10])$</span> denotes the number of points (or events) in between time <span>$5$</span> and <span>$10$</span> inclusive. The number of points in this interval is a random variable.</p><p>For convenience, we denote <span>$N(t) \equiv N[0, t)$</span> as the number of points since the start of time until <span>$t$</span>, exclusive of <span>$t$</span>. For simulation purposes, <span>$N(t)$</span> will be the state of our system. In subsequent sections, we will denote the state of the system as <span>$u(t) \equiv N(t)$</span> following SciML convention.</p><p>Any TPP can be characterized by its conditional intensity <span>$\lambda(t)$</span> which can be interpreted as the expected number of points per unit of time. We assume <span>$N(t)$</span> changes according to the following dynamics on any given infinitesimal unit of time.</p><p class="math-container">\[dN(t) = \begin{cases}
  1 \text{ , if } N[t, t + \epsilon] = 1 \\
  0 \text{ , if } N[t, t + \epsilon] = 0.
\end{cases}\]</p><p>It is possible to show that <span>$E(dN(t)) = \lambda(t) d(t)$</span> which says that the expected number of points changes according to <span>$\lambda(t)$</span> over time. For this reason, <span>$\lambda(t)$</span> can also be known as the rate of the TPP.</p><h2 id="Homogeneous-Poisson-Process"><a class="docs-heading-anchor" href="#Homogeneous-Poisson-Process">Homogeneous Poisson Process</a><a id="Homogeneous-Poisson-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Homogeneous-Poisson-Process" title="Permalink"></a></h2><p>In this section, we specify a homogeneous Poisson process with unit rate, which is the simplest TPP process with <span>$\lambda(t) = 1$</span>. Let&#39;s start by loading our packages.</p><pre><code class="language-julia hljs">using JumpProcesses, Plots</code></pre><p>In JumpProcesses, a <code>ConstantRateJump</code> is a TPP whose rate is constant between points. To specify the homogeneous Poisson process, we need to declare the rate function which takes three inputs, the current state of the system, <code>u</code>, the parameters, <code>p</code>, and the time, <code>t</code>. In this case, the rate function is constant.</p><pre><code class="language-julia hljs">poisson_rate(u, p, t) = 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">poisson_rate (generic function with 1 method)</code></pre><p>We also need a function that updates the total count.</p><pre><code class="language-julia hljs">poisson_affect!(integrator) = (integrator.u[1] += 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">poisson_affect! (generic function with 1 method)</code></pre><p>Here, the convention is to take a <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/integrator/">DifferentialEquations.jl integrator</a>, and directly modify the current solution value it stores. i.e., <code>integrator.u</code> is the current solution vector, with <code>integrator.u[1]</code> the first component of this vector.</p><p>Now, we can declare the Poisson process.</p><pre><code class="language-julia hljs">poisson_process = ConstantRateJump(poisson_rate, poisson_affect!)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstantRateJump{typeof(Main.var&quot;Main&quot;.poisson_rate), typeof(Main.var&quot;Main&quot;.poisson_affect!)}(Main.var&quot;Main&quot;.poisson_rate, Main.var&quot;Main&quot;.poisson_affect!)</code></pre><p>Once we have declared the process we want to simulate, we need to specify our simulation requirements. First, we determine the initial count and the desired time span.</p><pre><code class="language-julia hljs">u0 = [0]
tspan = (0.0, 10.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.0, 10.0)</code></pre><p>We initialize a base problem containing our simulation specification. Since we will not combine any other concurrent process with the Poisson process, we create a <code>DiscreteProblem</code> which is the most basic problem for simulating processes that evolve in discrete time steps as is the case with our TPP.</p><pre><code class="language-julia hljs">dprob = DiscreteProblem(u0, tspan)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">DiscreteProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Int64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
timespan: (0.0, 10.0)
u0: 1-element Vector{Int64}:
 0</code></pre><p>Apart from our base problem, we need to create a <a href="../../api/#JumpProcesses.JumpProblem"><code>JumpProblem</code></a> in which we specify the simulation algorithm, i.e. the aggregator in JumpProcesses&#39; language, we intend to use for simulating the Poisson process. This aggregator is responsible for sampling the times at which the process changes based on the provided <code>poisson_rate</code> function, and for calling the user <code>poisson_affect!</code> function to update the system state at these times. Here we use the <code>Direct</code> method which is a type of thinning algorithm for simulating TPPs with a constant rate between points.</p><pre><code class="language-julia hljs">jprob = JumpProblem(dprob, Direct(), poisson_process)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">JumpProblem</span> with problem <span class="sgr38_2" style="color:#56b6c2">DiscreteProblem</span> with aggregator <span class="sgr38_2" style="color:#56b6c2">Direct
Number of jumps with discrete aggregation: 1
Number of jumps with continuous aggregation: 0
Number of mass action jumps: 0
</span></code></pre><p>Finally, we can simulate one realization of our TPP. The solver requires that we specify a time-stepper, which is a method that handles time-evolution in our system. While the <code>Direct</code> algorithm above draws the next point in our process, the stepper advances the system in time to that point. We use <code>SSAStepper</code> which is a discrete stepper that only stops at the times proposed by our simulation algorithm.</p><pre><code class="language-julia hljs">sol = solve(jprob, SSAStepper())
plot(sol)</code></pre><img src="00b55128.svg" alt="Example block output"/><p>By breaking the problem formulation and solver selection into specifying a <code>DiscreteProblem</code>, a simulation algorithm (i.e. aggregator) via <code>JumpProblem</code>, and generating a realization via <code>solve</code>, JumpProcesses&#39; has the flexibility to specify and simulate a broad variety of problem types. The base problem allow us to combine TPPs with other types of dynamics such as ODEs or SDEs, by replacing <code>DiscreteProblem</code> with <code>ODEProblem</code> or <code>SDEProblem</code> from <a href="https://docs.sciml.ai/DiffEqDocs/stable/">DifferentialEquations.jl</a>. For instance, we can declare a conditional intensity function that follows an ODE using <code>ODEProblem</code>. The <code>JumpProblem</code> allows us to combine multiple TPPs together as we will see in the next section. The simulation algorithm (i.e. aggregator) allows us to simulate different types of TPPs including processes with variable rates, using different algorithms that may offer improved performance over <code>Direct</code> depending on the number of TPPs and their properties. The time-stepper allow us to specify the time-evolution that allows the most exotic dynamics to evolve in sync with base time.</p><h2 id="Multivariate-TPPs"><a class="docs-heading-anchor" href="#Multivariate-TPPs">Multivariate TPPs</a><a id="Multivariate-TPPs-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-TPPs" title="Permalink"></a></h2><p>JumpProcesses allow us to simulate a multivariate TPP which is a TPP formed by multiple TPPs whose rates can influence one another. In this section we will illustrate a simple case with two TPPs. We assume that the first process <span>$N_1$</span> is the homogeneous Poisson process from the previous section. The second process <span>$N_2$</span> is a TPP whose intensity rate obeys the following dynamics:</p><p class="math-container">\[\lambda_2(t) = \begin{cases}
  1 + \sin(t), &amp; \text{if } N_1(t) \text{ is even} \\
  1 + \cos(t), &amp; \text{if } N_1(t) \text{ is odd}.
\end{cases}\]</p><p>In this case, the intensity rate of the second process is variable. It not only changes according to time but also according to the first process.</p><p>In JumpProcesses a <code>VariableRateJump</code> is a TPP whose rate is allowed to vary at arbitrary times. Again, we start by declaring the rate function and the affect.</p><pre><code class="language-julia hljs">seasonal_rate(u, p, t) = 1 + (u[1] % 2 == 0 ? sin(t) : cos(t))
seasonal_affect!(integrator) = (integrator.u[2] += 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">seasonal_affect! (generic function with 1 method)</code></pre><p>There are algorithms for simulating TPPs which can take advantage of bounded variable rates. In our example, <span>$\lambda_2$</span> is bounded above by <span>$2$</span> and below by <span>$1$</span>. To initialize, a bounded <code>VariableRateJump</code> we must supply the rate upper-bound and the interval for which the upper-bound is valid. In this case, the bound is valid throughout time. The lower-bound is optional but can improve the speed of the simulation.</p><pre><code class="language-julia hljs">urate(u, p, t) = 2           # upper bound
rateinterval(u, p, t) = Inf  # time window bound is valid over
lrate(u, p, t) = 1           # lower bound</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">lrate (generic function with 1 method)</code></pre><p>Now, we can declare the seasonal process as a <code>VariableRateJump</code>.</p><pre><code class="language-julia hljs">seasonal_process = VariableRateJump(seasonal_rate, seasonal_affect!;
    urate, rateinterval, lrate)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VariableRateJump{typeof(Main.var&quot;Main&quot;.seasonal_rate), typeof(Main.var&quot;Main&quot;.seasonal_affect!), typeof(Main.var&quot;Main&quot;.lrate), typeof(Main.var&quot;Main&quot;.urate), typeof(Main.var&quot;Main&quot;.rateinterval), Nothing, Float64, Int64}(Main.var&quot;Main&quot;.seasonal_rate, Main.var&quot;Main&quot;.seasonal_affect!, Main.var&quot;Main&quot;.lrate, Main.var&quot;Main&quot;.urate, Main.var&quot;Main&quot;.rateinterval, nothing, true, 10, (false, true), 1.0e-12, 0)</code></pre><p>We initialize a new base problem with a different simulation specification. Since we have a multivariate process, the state of the system is a vector with two counts.</p><pre><code class="language-julia hljs">u0 = [0, 0]
tspan = (0.0, 10.0)
dprob = DiscreteProblem(u0, tspan)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">DiscreteProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Int64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
timespan: (0.0, 10.0)
u0: 2-element Vector{Int64}:
 0
 0</code></pre><p>We also need to modify <a href="../../api/#JumpProcesses.JumpProblem"><code>JumpProblem</code></a> to use a simulation algorithm (i.e. aggregator) that supports bounded <code>VariableRateJump</code>s. In this case, we use the <code>Coevolve</code> method, which is another type of thinning algorithm for multivariate process and which is an improvement of the Ogata thinning method. This method also requires a dependency graph that indicates for a given TPP which other TPPs have rates that depend on states/variables altered in its affect function. Note JumpProcesses&#39; convention is that a given TPP should also always be a dependency of itself. Internally, JumpProcesses preserves the relative ordering of point processes of each distinct type, but always reorders all <code>ConstantRateJump</code>s to appear before any <code>VariableRateJump</code>s. Irrespective of how <code>JumpProblem</code> is initialized, internally the processes will be ordered as the vector <code>[poisson_process, seasonal_process]</code> so that these will have the internal indexes of <code>1</code> and <code>2</code> respectively. Note, this vector of the processes is distinct from our state variable vector, <code>u</code>. When <code>poisson_process</code> fires <code>u[1]</code> is altered, and as the rate for <code>seasonal_process</code> depends on it we have that the dependencies of <code>poisson_process</code> are <code>[1,2]</code>. In contrast, the rate of <code>poisson_process</code> is independent of <code>u[2]</code> which <code>seasonal_process</code> modifies, and hence the dependencies of <code>seasonal_process</code> are only <code>[2]</code>.</p><p>Therefore, we obtain the following dependency graph:</p><pre><code class="language-julia hljs">dep_graph = [[1, 2], [2]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Vector{Int64}}:
 [1, 2]
 [2]</code></pre><p>We can then construct the corresponding problem <code>JumpProblem</code>, passing our selected simulation algorithm, our processes and the dependency graph.</p><pre><code class="language-julia hljs">jprob = JumpProblem(dprob, Coevolve(), poisson_process, seasonal_process; dep_graph)
sol = solve(jprob, SSAStepper())
plot(sol, labels = [&quot;N_1(t)&quot; &quot;N_2(t)&quot;], xlabel = &quot;t&quot;, legend = :topleft)</code></pre><img src="65456c89.svg" alt="Example block output"/><h2 id="More-TPPs"><a class="docs-heading-anchor" href="#More-TPPs">More TPPs</a><a id="More-TPPs-1"></a><a class="docs-heading-anchor-permalink" href="#More-TPPs" title="Permalink"></a></h2><p>This tutorial demonstrated how to simulate simple TPPs. In addition to that, JumpProcesses and the SciML ecosystem can be a powerful tool in describing more general TPPs. We demonstrate this capability in the <a href="../../applications/advanced_point_process/#tpp_advanced">advanced TPP tutorial</a>, which shows how to interface JumpProcesses with <a href="https://github.com/gdalle/PointProcesses.jl">PointProcesses.jl</a> and covers via this interface many different aspects usually studied in point process theory.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../discrete_stochastic_example/">« Continuous-Time Jump Processes and Gillespie Methods</a><a class="docs-footer-nextpage" href="../jump_diffusion/">Piecewise Deterministic Markov Processes and Jump Diffusion Equations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 6 August 2024 20:48">Tuesday 6 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
