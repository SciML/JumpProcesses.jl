<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Jump types and JumpProblem · JumpProcesses.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/JumpProcesses/jump_types/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="JumpProcesses.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">JumpProcesses.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/simple_poisson_process/">Simple Poisson Processes in JumpProcesses</a></li><li><a class="tocitem" href="../tutorials/discrete_stochastic_example/">Continuous-Time Jump Processes and Gillespie Methods</a></li><li><a class="tocitem" href="../tutorials/jump_diffusion/">Piecewise Deterministic Markov Processes and Jump Diffusion Equations</a></li><li><a class="tocitem" href="../tutorials/spatial/">Spatial SSAs with JumpProcesses.jl</a></li></ul></li><li><a class="tocitem" href="../faq/">FAQ</a></li><li><span class="tocitem">Type Documentation</span><ul><li class="is-active"><a class="tocitem" href>Jump types and JumpProblem</a><ul class="internal"><li><a class="tocitem" href="#Mathematical-Specification-of-a-problem-with-jumps"><span>Mathematical Specification of a problem with jumps</span></a></li><li><a class="tocitem" href="#Types-of-Jumps:-Constant-Rate,-Mass-Action,-Variable-Rate-and-Regular"><span>Types of Jumps: Constant Rate, Mass Action, Variable Rate and Regular</span></a></li><li><a class="tocitem" href="#Defining-a-Jump-Problem"><span>Defining a Jump Problem</span></a></li><li><a class="tocitem" href="#Jump-Aggregators-for-Exact-Simulation"><span>Jump Aggregators for Exact Simulation</span></a></li><li><a class="tocitem" href="#Jump-Aggregators-Requiring-Dependency-Graphs"><span>Jump Aggregators Requiring Dependency Graphs</span></a></li><li><a class="tocitem" href="#Recommendations-for-exact-methods"><span>Recommendations for exact methods</span></a></li><li><a class="tocitem" href="#Remaking-JumpProblems"><span>Remaking <code>JumpProblem</code>s</span></a></li></ul></li><li><a class="tocitem" href="../jump_solve/">Jump solvers</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Type Documentation</a></li><li class="is-active"><a href>Jump types and JumpProblem</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Jump types and JumpProblem</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/JumpProcesses.jl/blob/master/docs/src/jump_types.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="jump_problem_type"><a class="docs-heading-anchor" href="#jump_problem_type">Jump Problems</a><a id="jump_problem_type-1"></a><a class="docs-heading-anchor-permalink" href="#jump_problem_type" title="Permalink"></a></h1><h2 id="Mathematical-Specification-of-a-problem-with-jumps"><a class="docs-heading-anchor" href="#Mathematical-Specification-of-a-problem-with-jumps">Mathematical Specification of a problem with jumps</a><a id="Mathematical-Specification-of-a-problem-with-jumps-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Specification-of-a-problem-with-jumps" title="Permalink"></a></h2><p>Jumps (or point) processes are stochastic processes with discrete state changes driven by a <code>rate</code> function. The homogeneous Poisson process is the canonical point process with a constant rate of change. Processes involving multiple jumps are known as compound jump (or point) processes.</p><p>A compound Poisson process is a continuous-time Markov Chain where the time to the next jump is exponentially distributed as determined by the rate. Simulation algorithms for these types of processes are known in biology and chemistry as Gillespie methods or Stochastic Simulation Algorithms (SSA), with the time evolution that the probability these processes are in a given state at a given time satisfying the Chemical Master Equation (CME). In the statistics literature, the composition of Poisson processes is described by the superposition theorem.</p><p>Any differential equation can be extended by jumps. For example, we have an ODE with jumps, denoted by</p><p class="math-container">\[\frac{du}{dt} = f(u,p,t) + \sum_{i}c_i(u,p,t)p_i(t)\]</p><p>where <span>$p_i$</span> is a Poisson counter of rate <span>$\lambda_i(u,p,t)$</span>. Extending a stochastic differential equation to have jumps is commonly known as a Jump Diffusion, and is denoted by</p><p class="math-container">\[du(t) = f(u,p,t)dt + \sum_{j}g_j(u,t)dW_j(t) + \sum_{i}c_i(u,p,t)dp_i(t)\]</p><h2 id="Types-of-Jumps:-Constant-Rate,-Mass-Action,-Variable-Rate-and-Regular"><a class="docs-heading-anchor" href="#Types-of-Jumps:-Constant-Rate,-Mass-Action,-Variable-Rate-and-Regular">Types of Jumps: Constant Rate, Mass Action, Variable Rate and Regular</a><a id="Types-of-Jumps:-Constant-Rate,-Mass-Action,-Variable-Rate-and-Regular-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-Jumps:-Constant-Rate,-Mass-Action,-Variable-Rate-and-Regular" title="Permalink"></a></h2><p>Exact jump process simulation algorithms tend to describe the realization of each jump event chronologically. Individual jumps are usually associated with changes to the state variable <code>u</code>, which in turn changes the <code>rate</code>s at which jump events occur. These jumps can be specified as a <a href="../api/#JumpProcesses.ConstantRateJump"><code>ConstantRateJump</code></a>, <a href="../api/#JumpProcesses.MassActionJump"><code>MassActionJump</code></a>, or a <a href="../api/#JumpProcesses.VariableRateJump"><code>VariableRateJump</code></a>.</p><p>Each individual type of jump that can occur is represented through (implicitly or explicitly) specifying two pieces of information; a <code>rate</code> function (i.e., intensity or propensity) for the jump and an <code>affect!</code> function for the jump. The former gives the probability per time a particular jump can occur given the current state of the system, and hence determines the time at which jumps can happen. The latter specifies the instantaneous change in the state of the system when the jump occurs.</p><p>A specific jump type is a <a href="../api/#JumpProcesses.VariableRateJump"><code>VariableRateJump</code></a> if its rate function is dependent on values which may change between the occurrence of any two jump events of the process. Examples include jumps where the rate is an explicit function of time, or depends on a state variable that is modified via continuous dynamics such as an ODE or SDE. Such &quot;general&quot; <code>VariableRateJump</code>s can be expensive to simulate because it is necessary to consider the (possibly continuous) changes in the rate function when calculating the next jump time.</p><p><em>Bounded</em> <a href="../api/#JumpProcesses.VariableRateJump"><code>VariableRateJump</code></a>s represent a special subset of <code>VariableRateJump</code>s where one can specify functions that calculate a time window over which the rate is bounded by a constant (presuming the state <code>u</code> is unchanged due to another <code>ConstantRateJump</code>, <code>MassActionJump</code> or bounded <code>VariableRateJump</code>). They can be simulated more efficiently using rejection-sampling based approaches that leverage this upper bound.</p><p><a href="../api/#JumpProcesses.ConstantRateJump"><code>ConstantRateJump</code></a>s are more restricted in that they assume the rate functions are constant at all times between two consecutive jumps of the system. That is, any states or parameters that a rate function depends on must not change between the times at which two consecutive jumps occur.</p><p>A <a href="../api/#JumpProcesses.MassActionJump"><code>MassActionJump</code></a>s is a specialized representation for a collection of <code>ConstantRateJump</code> jumps that can each be interpreted as a standard mass action reaction. For systems comprised of many mass action reactions, using the <code>MassActionJump</code> type will offer improved performance compared to using multiple <code>ConstantRateJump</code>s. Note, only one <code>MassActionJump</code> should be defined per <a href="../api/#JumpProcesses.JumpProblem"><code>JumpProblem</code></a>; it is then responsible for handling all mass action reaction type jumps. For systems with both mass action jumps and non-mass action jumps, one can create one <code>MassActionJump</code> to handle the mass action jumps, and create a number of <code>ConstantRateJump</code>s or <code>VariableRateJump</code>s to handle the non-mass action jumps.</p><p>Since exact methods simulate each individual jump, they may become computationally expensive to simulate processes over timescales that involve <em>many</em> jump occurrences. As an alternative, inexact τ-leaping methods take discrete steps through time, over which they simultaneously execute many jumps. These methods can be much faster as they do not need to simulate the realization of every individual jump event. τ-leaping methods trade accuracy for speed, and are best used when a set of jumps do not make significant changes to the processes&#39; state and/or rates over the course of one time-step (i.e., during a leap interval). A single <a href="../api/#JumpProcesses.RegularJump"><code>RegularJump</code></a> is used to encode jumps for τ-leaping algorithms. While τ-leaping methods can be proven to converge in the limit that the time-step approaches zero, their accuracy can be highly dependent on the chosen time-step. As a rule of thumb, if changes to the state variable <code>u</code> during a time-step (i.e., leap interval) are &quot;minimal&quot; compared to the size of the system, an τ-leaping method can often provide reasonable solution approximations.</p><p>Currently, <code>ConstantRateJump</code>s, <code>MassActionJump</code>s, and <code>VariableRateJump</code>s can be coupled to standard SciML ODE/SDE solvers since they are internally handled via callbacks. For <code>ConstantRateJump</code>s, <code>MassActionJump</code>s, and bounded <code>VariableRateJump</code> the determination of the next jump time and type is handled by a user-selected <em>aggregator</em> algorithm. <code>RegularJump</code>s currently require their own special time integrators.</p><h4 id="Defining-a-Constant-Rate-Jump"><a class="docs-heading-anchor" href="#Defining-a-Constant-Rate-Jump">Defining a Constant Rate Jump</a><a id="Defining-a-Constant-Rate-Jump-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-Constant-Rate-Jump" title="Permalink"></a></h4><p>The constructor for a <a href="../api/#JumpProcesses.ConstantRateJump"><code>ConstantRateJump</code></a> is:</p><pre><code class="language-julia hljs">ConstantRateJump(rate, affect!)</code></pre><ul><li><code>rate(u, p, t)</code> is a function which calculates the rate given the current state <code>u</code>, parameters <code>p</code>, and time <code>t</code>.</li><li><code>affect!(integrator)</code> is the effect on the equation using the integrator interface. It encodes how the state should change due to <em>one</em> occurrence of the jump.</li></ul><h4 id="Defining-a-Mass-Action-Jump"><a class="docs-heading-anchor" href="#Defining-a-Mass-Action-Jump">Defining a Mass Action Jump</a><a id="Defining-a-Mass-Action-Jump-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-Mass-Action-Jump" title="Permalink"></a></h4><p>The constructor for a <a href="../api/#JumpProcesses.MassActionJump"><code>MassActionJump</code></a> is:</p><pre><code class="language-julia hljs">MassActionJump(reactant_stoich, net_stoich; scale_rates = true, param_idxs = nothing)</code></pre><ul><li><code>reactant_stoich</code> is a vector whose <code>k</code>th entry is the reactant stoichiometry of the <code>k</code>th reaction. The reactant stoichiometry for an individual reaction is assumed to be represented as a vector of <code>Pair</code>s, mapping species integer id to stoichiometric coefficient.</li><li><code>net_stoich</code> is assumed to have the same type as <code>reactant_stoich</code>; a vector whose <code>k</code>th entry is the net stoichiometry of the <code>k</code>th reaction. The net stoichiometry for an individual reaction is again represented as a vector of <code>Pair</code>s, mapping species id to the net change in the species when the reaction occurs.</li><li><code>scale_rates</code> is an optional parameter that specifies whether the rate constants correspond to stochastic rate constants in the sense used by Gillespie, and hence need to be rescaled. <em>The default, <code>scale_rates = true</code>, corresponds to rescaling the passed in rate constants.</em> See below.</li><li><code>param_idxs</code> is a vector of the indices within the parameter vector, <code>p</code>, that correspond to the rate constant for each jump.</li></ul><p><strong>Notes for Mass Action Jumps</strong></p><ul><li><p>When using <code>MassActionJump</code> the default behavior is to assume rate constants correspond to stochastic rate constants in the sense used by Gillespie (J. Comp. Phys., 1976, 22 (4)). This means that for a reaction such as <span>$2A \overset{k}{\rightarrow} B$</span>, the jump rate function constructed by <code>MassActionJump</code> would be <code>k*A*(A-1)/2!</code>. For a trimolecular reaction like <span>$3A \overset{k}{\rightarrow} B$</span> the rate function would be <code>k*A*(A-1)*(A-2)/3!</code>. To <em>avoid</em> having the reaction rates rescaled (by <code>1/2</code> and <code>1/6</code> for these two examples), one can pass the <code>MassActionJump</code> constructor the optional named parameter <code>scale_rates = false</code>, i.e., use</p><pre><code class="language-julia hljs">MassActionJump(reactant_stoich, net_stoich; scale_rates = false, param_idxs)</code></pre></li><li><p>Zero order reactions can be passed as <code>reactant_stoich</code>s in one of two ways. Consider the <span>$\varnothing \overset{k}{\rightarrow} A$</span> reaction with rate <code>k=1</code>:</p><pre><code class="language-julia hljs">p = [1.0]
reactant_stoich = [[0 =&gt; 1]]
net_stoich = [[1 =&gt; 1]]
jump = MassActionJump(reactant_stoich, net_stoich; param_idxs = [1])</code></pre><p>Alternatively, one can create an empty vector of pairs to represent the reaction:</p><pre><code class="language-julia hljs">p = [1.0]
reactant_stoich = [Vector{Pair{Int, Int}}()]
net_stoich = [[1 =&gt; 1]]
jump = MassActionJump(reactant_stoich, net_stoich; param_idxs = [1])</code></pre></li><li><p>For performance reasons, it is recommended to order species indices in stoichiometry vectors from smallest to largest. That is</p><pre><code class="language-julia hljs">reactant_stoich = [[1 =&gt; 2, 3 =&gt; 1, 4 =&gt; 2], [2 =&gt; 2, 3 =&gt; 2]]</code></pre><p>is preferred over</p><pre><code class="language-julia hljs">reactant_stoich = [[3 =&gt; 1, 1 =&gt; 2, 4 =&gt; 2], [3 =&gt; 2, 2 =&gt; 2]]</code></pre></li></ul><h4 id="Defining-a-Variable-Rate-Jump"><a class="docs-heading-anchor" href="#Defining-a-Variable-Rate-Jump">Defining a Variable Rate Jump</a><a id="Defining-a-Variable-Rate-Jump-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-Variable-Rate-Jump" title="Permalink"></a></h4><p>The constructor for a <a href="../api/#JumpProcesses.VariableRateJump"><code>VariableRateJump</code></a> is:</p><pre><code class="language-julia hljs">VariableRateJump(rate, affect!;
                 lrate = nothing, urate = nothing, rateinterval = nothing,
                 idxs = nothing, rootfind = true, save_positions = (true, true),
                 interp_points = 10, abstol = 1e-12, reltol = 0)</code></pre><ul><li><code>rate(u, p, t)</code> is a function which calculates the rate given the current state <code>u</code>, parameters <code>p</code>, and time <code>t</code>.</li><li><code>affect!(integrator)</code> is the effect on the equation using the integrator interface. It encodes how the state should change due to <em>one</em> occurrence of the jump.</li></ul><p>To define a bounded <code>VariableRateJump</code>, which can be simulated more efficiently with bounded <code>VariableRateJump</code> supporting aggregators such as <code>Coevolve</code>, one must also specify</p><ul><li><code>urate(u, p, t)</code>, a function which computes an upper bound for the rate in the interval <code>t</code> to <code>t + rateinterval(u, p, t)</code> at time <code>t</code> given state <code>u</code> and parameters <code>p</code>.</li><li><code>rateinterval(u, p, t)</code>, a function which computes a time interval <code>t</code> to <code>t + rateinterval(u, p, t)</code> given state <code>u</code> and parameters <code>p</code> over which the <code>urate</code> bound will hold (and <code>lrate</code> bound if provided, see below).</li></ul><p>Note that it is ok if the <code>urate</code> bound would be violated within the <code>rateinterval</code> due to a change in <code>u</code> arising from another <code>ConstantRateJump</code>, <code>MassActionJump</code> or <em>bounded</em> <code>VariableRateJump</code> being executed, as the chosen aggregator will then handle recalculating the rate bound and interval. <em>However, if the bound could be violated within the time interval due to a change in <code>u</code> arising from continuous dynamics such as a coupled ODE, SDE, or a general <code>VariableRateJump</code>, bounds should not be given.</em> This ensures the jump is classified as a general <code>VariableRateJump</code> and properly handled.</p><p>For increased performance, one can also specify a lower bound that should be valid over the same <code>rateinterval</code></p><ul><li><code>lrate(u, p, t)</code>, a function which computes a lower bound for the rate in the interval <code>t</code> to <code>t + rateinterval(u, p, t)</code> at time <code>t</code> given state <code>u</code> and parameters <code>p</code>. <code>lrate</code> should remain valid under the same conditions as <code>urate</code>.</li></ul><p>Note that</p><ul><li>It is currently only possible to simulate <code>VariableRateJump</code>s with <code>SSAStepper</code> when using systems with only bounded <code>VariableRateJump</code>s and the <code>Coevolve</code> aggregator.</li><li>When choosing a different aggregator than <code>Coevolve</code>, <code>SSAStepper</code> cannot currently be used, and the <code>JumpProblem</code> must be coupled to a continuous problem type such as an <code>ODEProblem</code> to handle time-stepping. The continuous time-stepper treats <em>all</em> <code>VariableRateJump</code>s as <code>ContinuousCallback</code>s, using the <code>rate(u, p, t)</code> function to construct the <code>condition</code> function that triggers a callback.</li></ul><h4 id="Defining-a-Regular-Jump"><a class="docs-heading-anchor" href="#Defining-a-Regular-Jump">Defining a Regular Jump</a><a id="Defining-a-Regular-Jump-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-Regular-Jump" title="Permalink"></a></h4><p>The constructor for a <a href="../api/#JumpProcesses.RegularJump"><code>RegularJump</code></a> is:</p><pre><code class="language-julia hljs">RegularJump(rate, c, numjumps; mark_dist = nothing)</code></pre><ul><li><code>rate(out, u, p, t)</code> is the function which computes the rate for every regular jump process</li><li><code>c(du, u, p, t, counts, mark)</code> calculates the update given <code>counts</code> number of jumps for each jump process in the interval.</li><li><code>numjumps</code> is the number of jump processes, i.e., the number of <code>rate</code> equations and the number of <code>counts</code>.</li><li><code>mark_dist</code> is the distribution for a mark.</li></ul><h2 id="Defining-a-Jump-Problem"><a class="docs-heading-anchor" href="#Defining-a-Jump-Problem">Defining a Jump Problem</a><a id="Defining-a-Jump-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-Jump-Problem" title="Permalink"></a></h2><p>To define a <code>JumpProblem</code>, one must first define the basic problem. This can be a <code>DiscreteProblem</code> if there is no differential equation, or an ODE/SDE/DDE/DAE if you would like to augment a differential equation with jumps. Denote this previously defined problem as <code>prob</code>. Then the constructor for the jump problem is:</p><pre><code class="language-julia hljs">JumpProblem(prob, aggregator, jumps::JumpSet;
            save_positions = typeof(prob) &lt;: AbstractDiscreteProblem ? (false, true) :
                             (true, true))</code></pre><p>The aggregator is the method for simulating <code>ConstantRateJump</code>s, <code>MassActionJump</code>s, and bounded <code>VariableRateJump</code>s (if supported by the aggregator). They are called aggregators since they resolve all these jumps in a single discrete simulation algorithm. The possible aggregators are given below. <code>jumps</code> is a <a href="../api/#JumpProcesses.JumpSet"><code>JumpSet</code></a> which is just a collection of jumps. Instead of passing a <code>JumpSet</code>, one may just pass a list of jumps as trailing positional arguments. For example:</p><pre><code class="language-julia hljs">JumpProblem(prob, aggregator, jump1, jump2)</code></pre><p>and the internals will automatically build the <code>JumpSet</code>. <code>save_positions</code> determines whether to save the state of the system just before and/or after jumps occur.</p><p>Note that a <code>JumpProblem</code>/<code>JumpSet</code> can only have 1 <code>RegularJump</code> (since a <code>RegularJump</code> itself describes multiple processes together). Similarly, it can only have one <code>MassActionJump</code> (since it also describes multiple processes together).</p><h2 id="Jump-Aggregators-for-Exact-Simulation"><a class="docs-heading-anchor" href="#Jump-Aggregators-for-Exact-Simulation">Jump Aggregators for Exact Simulation</a><a id="Jump-Aggregators-for-Exact-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Jump-Aggregators-for-Exact-Simulation" title="Permalink"></a></h2><p>Jump aggregators are methods for simulating <code>ConstantRateJump</code>s, <code>MassActionJump</code>s, and bounded <code>VariableRateJump</code>s (if supported) exactly. They are called aggregators since they combine all jumps to handle within a single discrete simulation algorithm. Aggregators combine jumps in different ways and offer different trade-offs. However, all aggregators describe the realization of each and every individual jump chronologically. Since they do not skip any jumps, they are considered exact methods. Note that none of the aggregators discussed in this section can be used with <code>RegularJumps</code> which are used for time-step based (inexact) τ-leaping methods.</p><p>The current aggregators are (note that an italicized name indicates the aggregator requires various types of dependency graphs, see the next section):</p><ul><li><code>Direct</code>: The Gillespie Direct method SSA [1].</li><li><code>DirectFW</code>: the Gillespie Direct method SSA [1] with <code>FunctionWrappers</code>. This aggregator uses a different internal storage format for collections of <code>ConstantRateJumps</code>.</li><li><em><code>DirectCR</code></em>: The Composition-Rejection Direct method of Slepoy et al [2]. For large networks and linear chain-type networks, it will often give better performance than <code>Direct</code>.</li><li><em><code>SortingDirect</code></em>: The Sorting Direct Method of McCollum et al [3]. It will usually offer performance as good as <code>Direct</code>, and for some systems can offer substantially better performance.</li><li><em><code>RSSA</code></em>: The Rejection SSA (RSSA) method of Thanh et al [4,5]. With <code>RSSACR</code>, for very large reaction networks, it often offers the best performance of all methods.</li><li><em><code>RSSACR</code></em>: The Rejection SSA (RSSA) with Composition-Rejection method of Thanh et al [6]. With <code>RSSA</code>, for very large reaction networks, it often offers the best performance of all methods.</li><li><code>RDirect</code>: A variant of Gillespie&#39;s Direct method [1] that uses rejection to sample the next reaction.</li><li><code>FRM</code>: The Gillespie first reaction method SSA [1]. <code>Direct</code> should generally offer better performance and be preferred to <code>FRM</code>.</li><li><code>FRMFW</code>: The Gillespie first reaction method SSA [1] with <code>FunctionWrappers</code>.</li><li><em><code>NRM</code></em>: The Gibson-Bruck Next Reaction Method [7]. For some reaction network structures, this may offer better performance than <code>Direct</code> (for example, large, linear chains of reactions).</li><li><em><code>Coevolve</code></em>: An adaptation of the COEVOLVE algorithm of Farajtabar et al [8]. Currently the only aggregator that also supports <em>bounded</em> <code>VariableRateJump</code>s. Essentially reduces to <code>NRM</code> in handling <code>ConstantRateJump</code>s and <code>MassActionJump</code>s.</li></ul><p>To pass the aggregator, pass the instantiation of the type. For example:</p><pre><code class="language-julia hljs">JumpProblem(prob, Direct(), jump1, jump2)</code></pre><p>will build a problem where the jumps are simulated using Gillespie&#39;s Direct SSA method.</p><p>[1] Daniel T. Gillespie, A general method for numerically simulating the stochastic time evolution of coupled chemical reactions, Journal of Computational Physics, 22 (4), 403–434 (1976). doi:10.1016/0021-9991(76)90041-3.</p><p>[2] A. Slepoy, A.P. Thompson and S.J. Plimpton, A constant-time kinetic Monte Carlo algorithm for simulation of large biochemical reaction networks, Journal of Chemical Physics, 128 (20), 205101 (2008). doi:10.1063/1.2919546.</p><p>[3] J. M. McCollum, G. D. Peterson, C. D. Cox, M. L. Simpson and N. F. Samatova, The sorting direct method for stochastic simulation of biochemical systems with varying reaction execution behavior, Computational Biology and Chemistry, 30 (1), 39049 (2006). doi:10.1016/j.compbiolchem.2005.10.007.</p><p>[4] V. H. Thanh, C. Priami and R. Zunino, Efficient rejection-based simulation of biochemical reactions with stochastic noise and delays, Journal of Chemical Physics, 141 (13), 134116 (2014). doi:10.1063/1.4896985.</p><p>[5] V. H. Thanh, R. Zunino and C. Priami, On the rejection-based algorithm for simulation and analysis of large-scale reaction networks, Journal of Chemical Physics, 142 (24), 244106 (2015). doi:10.1063/1.4922923.</p><p>[6] V. H. Thanh, R. Zunino, and C. Priami, Efficient constant-time complexity algorithm for stochastic simulation of large reaction networks, IEEE/ACM Transactions on Computational Biology and Bioinformatics, 14 (3), 657-667 (2017). doi:10.1109/TCBB.2016.2530066.</p><p>[7] M. A. Gibson and J. Bruck, Efficient exact stochastic simulation of chemical systems with many species and many channels, Journal of Physical Chemistry A, 104 (9), 1876-1889 (2000). doi:10.1021/jp993732q.</p><p>[8] M. Farajtabar, Y. Wang, M. Gomez-Rodriguez, S. Li, H. Zha, and L. Song, COEVOLVE: a joint point process model for information diffusion and network evolution, Journal of Machine Learning Research 18(1), 1305–1353 (2017). doi: 10.5555/3122009.3122050.</p><h2 id="Jump-Aggregators-Requiring-Dependency-Graphs"><a class="docs-heading-anchor" href="#Jump-Aggregators-Requiring-Dependency-Graphs">Jump Aggregators Requiring Dependency Graphs</a><a id="Jump-Aggregators-Requiring-Dependency-Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Jump-Aggregators-Requiring-Dependency-Graphs" title="Permalink"></a></h2><p>Italicized constant rate jump aggregators above require the user to pass a dependency graph to <code>JumpProblem</code>. <code>Coevolve</code>, <code>DirectCR</code>, <code>NRM</code>, and <code>SortingDirect</code> require a jump-jump dependency graph, passed through the named parameter <code>dep_graph</code>. i.e.,</p><pre><code class="language-julia hljs">JumpProblem(prob, DirectCR(), jump1, jump2; dep_graph = your_dependency_graph)</code></pre><p>For systems with only <code>MassActionJump</code>s, or those generated from a <a href="https://docs.sciml.ai/Catalyst/stable/">Catalyst</a> <code>reaction_network</code>, this graph will be auto-generated. Otherwise, you must construct the dependency graph whenever the set of jumps include <code>ConstantRateJump</code>s and/or bounded <code>VariableRateJump</code>s.</p><p>Dependency graphs are represented as a <code>Vector{Vector{Int}}</code>, with the <code>i</code>th vector containing the indices of the jumps for which rates must be recalculated when the <code>i</code>th jump occurs. Internally, all <code>MassActionJump</code>s are ordered before <code>ConstantRateJump</code>s and bounded <code>VariableRateJump</code>s. General <code>VariableRateJump</code>s are not handled by aggregators, and so not included in the jump ordering for dependency graphs. Note that the relative order between <code>ConstantRateJump</code>s and relative order between bounded <code>VariableRateJump</code>s is preserved. In this way, one can precalculate the jump order to manually construct dependency graphs.</p><p><code>RSSA</code> and <code>RSSACR</code> require two different types of dependency graphs, passed through the following <code>JumpProblem</code> kwargs:</p><ul><li><code>vartojumps_map</code> - A <code>Vector{Vector{Int}}</code> mapping each variable index, <code>i</code>, to a set of jump indices. The jump indices correspond to jumps with rate functions that depend on the value of <code>u[i]</code>.</li><li><code>jumptovars_map</code> - A <code>Vector{Vector{Int}}</code>  mapping each jump index to a set of variable indices. The corresponding variables are those that have their value, <code>u[i]</code>, altered when the jump occurs.</li></ul><p>For systems generated from a <a href="https://docs.sciml.ai/Catalyst/stable/">Catalyst</a> <code>reaction_network</code> these will be auto-generated. Otherwise, you must explicitly construct and pass in these mappings.</p><h2 id="Recommendations-for-exact-methods"><a class="docs-heading-anchor" href="#Recommendations-for-exact-methods">Recommendations for exact methods</a><a id="Recommendations-for-exact-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Recommendations-for-exact-methods" title="Permalink"></a></h2><p>For representing and aggregating jumps</p><ul><li>Use a <code>MassActionJump</code> to handle all jumps that can be represented as mass action reactions with constant rate between jumps. This will generally offer the fastest performance.</li><li>Use <code>ConstantRateJump</code>s for any remaining jumps with a constant rate between jumps.</li><li>Use <code>VariableRateJump</code>s for any remaining jumps with variable rate between jumps. If possible, construct a bounded <a href="../api/#JumpProcesses.VariableRateJump"><code>VariableRateJump</code></a> as described above and in the doc string. The tighter and easier to compute the bounds are, the faster the resulting simulation will be. Use the <code>Coevolve</code> aggregator to ensure such jumps are handled via the more efficient aggregator interface.</li></ul><p>For systems with only <code>ConstantRateJump</code>s and <code>MassActionJump</code>s,</p><ul><li>For a small number of jumps, &lt; ~10, <code>Direct</code> will often perform as well as the other aggregators.</li><li>For &gt; ~10 jumps <code>SortingDirect</code> will often offer better performance than <code>Direct</code>.</li><li>For large numbers of jumps with sparse chain like structures and similar jump rates, for example continuous time random walks, <code>RSSACR</code>, <code>DirectCR</code> and then <code>NRM</code> often have the best performance.</li><li>For very large networks, with many updates per jump, <code>RSSA</code> and <code>RSSACR</code> will often substantially outperform the other methods.</li></ul><p>For pure jump systems, time-step using <code>SSAStepper()</code> with a <code>DiscreteProblem</code> unless one has general (i.e., non-bounded) <code>VariableRateJump</code>s.</p><p>In general, for systems with sparse dependency graphs if <code>Direct</code> is slow, one of <code>SortingDirect</code>, <code>RSSA</code> or <code>RSSACR</code> will usually offer substantially better performance. See <a href="https://docs.sciml.ai/SciMLBenchmarksOutput/stable/">DiffEqBenchmarks.jl</a> for benchmarks on several example networks.</p><h2 id="Remaking-JumpProblems"><a class="docs-heading-anchor" href="#Remaking-JumpProblems">Remaking <code>JumpProblem</code>s</a><a id="Remaking-JumpProblems-1"></a><a class="docs-heading-anchor-permalink" href="#Remaking-JumpProblems" title="Permalink"></a></h2><p>When running many simulations, it can often be convenient to update the initial condition or simulation parameters without having to create and initialize a new <code>JumpProblem</code>. In such situations <code>remake</code> can be used to change the initial condition, time span, and the parameter vector. <strong>Note,</strong> the new <code>JumpProblem</code> will alias internal data structures from the old problem, including core components of the SSA aggregators. As such, only the new problem generated by <code>remake</code> should be used for subsequent simulations.</p><p>As an example, consider the following SIR model:</p><pre><code class="language-julia hljs">rate1(u, p, t) = p[1] * u[1] * u[2]
function affect1!(integrator)
    integrator.u[1] -= 1
    integrator.u[2] += 1
end
jump = ConstantRateJump(rate1, affect1!)

rate2(u, p, t) = p[2] * u[2]
function affect2!(integrator)
    integrator.u[2] -= 1
    integrator.u[3] += 1
end
jump2 = ConstantRateJump(rate2, affect2!)
u0 = [999, 1, 0]
p = (0.1 / 1000, 0.01)
tspan = (0.0, 250.0)
dprob = DiscreteProblem(u0, tspan, p)
jprob = JumpProblem(dprob, Direct(), jump, jump2)
sol = solve(jprob, SSAStepper())</code></pre><p>We can change any of <code>u0</code>, <code>p</code> and/or <code>tspan</code> by either making a new <code>DiscreteProblem</code></p><pre><code class="language-julia hljs">u02 = [10, 1, 0]
p2 = (0.1 / 1000, 0.0)
tspan2 = (0.0, 2500.0)
dprob2 = DiscreteProblem(u02, tspan2, p2)
jprob2 = remake(jprob, prob = dprob2)
sol2 = solve(jprob2, SSAStepper())</code></pre><p>or by directly remaking with the new parameters</p><pre><code class="language-julia hljs">jprob2 = remake(jprob, u0 = u02, p = p2, tspan = tspan2)
sol2 = solve(jprob2, SSAStepper())</code></pre><p>To avoid ambiguities, the following will give an error</p><pre><code class="language-julia hljs">jprob2 = remake(jprob, prob = dprob2, u0 = u02)</code></pre><p>as will trying to update either <code>p</code> or <code>tspan</code> while passing a new <code>DiscreteProblem</code> using the <code>prob</code> kwarg.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../faq/">« FAQ</a><a class="docs-footer-nextpage" href="../jump_solve/">Jump solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 29 March 2023 03:23">Wednesday 29 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
