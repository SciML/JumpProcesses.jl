<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simple Poisson Processes in JumpProcesses · JumpProcesses.jl</title><meta name="title" content="Simple Poisson Processes in JumpProcesses · JumpProcesses.jl"/><meta property="og:title" content="Simple Poisson Processes in JumpProcesses · JumpProcesses.jl"/><meta property="twitter:title" content="Simple Poisson Processes in JumpProcesses · JumpProcesses.jl"/><meta name="description" content="Documentation for JumpProcesses.jl."/><meta property="og:description" content="Documentation for JumpProcesses.jl."/><meta property="twitter:description" content="Documentation for JumpProcesses.jl."/><meta property="og:url" content="https://docs.sciml.ai/JumpProcesses/tutorials/simple_poisson_process/"/><meta property="twitter:url" content="https://docs.sciml.ai/JumpProcesses/tutorials/simple_poisson_process/"/><link rel="canonical" href="https://docs.sciml.ai/JumpProcesses/tutorials/simple_poisson_process/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JumpProcesses.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JumpProcesses.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Simple Poisson Processes in JumpProcesses</a><ul class="internal"><li><a class="tocitem" href="#ConstantRateJumps"><span><code>ConstantRateJump</code>s</span></a></li><li><a class="tocitem" href="#VariableRateJumps-for-processes-that-are-not-constant-between-jumps"><span><code>VariableRateJump</code>s for processes that are not constant between jumps</span></a></li><li><a class="tocitem" href="#Having-a-Random-Jump-Distribution"><span>Having a Random Jump Distribution</span></a></li></ul></li><li><a class="tocitem" href="../discrete_stochastic_example/">Continuous-Time Jump Processes and Gillespie Methods</a></li><li><a class="tocitem" href="../point_process_simulation/">Temporal Point Process (TPP) Simulation</a></li><li><a class="tocitem" href="../jump_diffusion/">Piecewise Deterministic Markov Processes and Jump Diffusion Equations</a></li><li><a class="tocitem" href="../spatial/">Spatial SSAs with JumpProcesses.jl</a></li></ul></li><li><span class="tocitem">Applications</span><ul><li><a class="tocitem" href="../../applications/advanced_point_process/">Temporal Point Processes (TPP) with JumpProcesses and PointProcesses</a></li></ul></li><li><span class="tocitem">Type Documentation</span><ul><li><a class="tocitem" href="../../jump_types/">Jumps, JumpProblem, and Aggregators</a></li><li><a class="tocitem" href="../../jump_solve/">Jump solvers</a></li></ul></li><li><a class="tocitem" href="../../faq/">FAQ</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Simple Poisson Processes in JumpProcesses</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simple Poisson Processes in JumpProcesses</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/JumpProcesses.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/JumpProcesses.jl/blob/master/docs/src/tutorials/simple_poisson_process.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="poisson_proc_tutorial"><a class="docs-heading-anchor" href="#poisson_proc_tutorial">Simple Poisson Processes in JumpProcesses</a><a id="poisson_proc_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#poisson_proc_tutorial" title="Permalink"></a></h1><p>In this tutorial, we show how to simulate several Poisson jump processes, for several types of intensities and jump distributions.</p><p>Readers interested primarily in chemical or population process models, where several types of jumps may occur, can skip directly to the <a href="../discrete_stochastic_example/#ssa_tutorial">second tutorial</a> for a tutorial covering similar material but focused on the SIR model. Readers with a background in point process theory can skip directly to <a href="../point_process_simulation/#tpp_tutorial">modelling temporal point processes with JumpProcesses</a>.</p><p>JumpProcesses allows the simulation of jump processes where the transition rate, i.e., intensity or propensity, can be a function of the current solution, current parameters, and current time. Throughout this tutorial these are denoted by <code>u</code>, <code>p</code> and <code>t</code>. Likewise, when a jump occurs any DifferentialEquations.jl-compatible change to the current system state, as encoded by a <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/integrator/">DifferentialEquations.jl integrator</a>, is allowed. This includes changes to the current state or to parameter values (for example via a callback).</p><p>This tutorial requires several packages, which can be added if not already installed via</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;JumpProcesses&quot;)
Pkg.add(&quot;Plots&quot;)</code></pre><p>Let&#39;s also load our packages and set some defaults for our plot formatting</p><pre><code class="language-julia hljs">using JumpProcesses, Plots
default(; lw = 2)</code></pre><h2 id="ConstantRateJumps"><a class="docs-heading-anchor" href="#ConstantRateJumps"><code>ConstantRateJump</code>s</a><a id="ConstantRateJumps-1"></a><a class="docs-heading-anchor-permalink" href="#ConstantRateJumps" title="Permalink"></a></h2><p>Our first example will be to simulate a simple Poisson counting process, <span>$N(t)$</span>, with a constant transition rate of λ. We can interpret this as a birth process where new individuals are created at the constant rate λ. <span>$N(t)$</span> then gives the current population size. In terms of a unit Poisson counting process, <span>$Y_b(t)$</span>, we have</p><p class="math-container">\[N(t) = Y_b\left( \lambda t \right).\]</p><p>(Here by a unit Poisson counting process we just mean a Poisson counting process with a constant rate of one.)</p><p>In the remainder of this tutorial we will use <em>transition rate</em>, <em>rate</em>, <em>propensity</em>, and <em>intensity</em> interchangeably. Here is the full program listing, which we will subsequently explain line by line</p><pre><code class="language-julia hljs">using JumpProcesses, Plots

rate(u, p, t) = p.λ
affect!(integrator) = (integrator.u[1] += 1)
crj = ConstantRateJump(rate, affect!)

u₀ = [0]
p = (λ = 2.0,)
tspan = (0.0, 10.0)

dprob = DiscreteProblem(u₀, tspan, p)
jprob = JumpProblem(dprob, Direct(), crj)

sol = solve(jprob, SSAStepper())
plot(sol, label = &quot;N(t)&quot;, xlabel = &quot;t&quot;, legend = :bottomright)</code></pre><p>We can define and simulate our jump process as follows. We first load our packages</p><pre><code class="language-julia hljs">using JumpProcesses, Plots</code></pre><p>To specify our jump process, we need to define two functions. One that given the current state of the system, <code>u</code>, the parameters, <code>p</code>, and the time, <code>t</code>, can determine the current transition rate (intensity)</p><pre><code class="language-julia hljs">rate(u, p, t) = p.λ</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">rate (generic function with 1 method)</code></pre><p>This corresponds to the instantaneous probability per time a jump occurs when the current state is <code>u</code>, current parameters are <code>p</code>, and the time is <code>t</code>. We also give a function that updates the system state when a jump is known to have occurred (at time <code>integrator.t</code>)</p><pre><code class="language-julia hljs">affect!(integrator) = (integrator.u[1] += 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">affect! (generic function with 1 method)</code></pre><p>Here, the convention is to take a <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/integrator/">DifferentialEquations.jl integrator</a>, and directly modify the current solution value it stores. i.e., <code>integrator.u</code> is the current solution vector, with <code>integrator.u[1]</code> the first component of this vector. In our case, we will only have one unknown, so this will be the current value of the counting process. As our jump process&#39;s transition rate is constant between jumps, we can use a <a href="../../api/#JumpProcesses.ConstantRateJump"><code>ConstantRateJump</code></a> to encode it</p><pre><code class="language-julia hljs">crj = ConstantRateJump(rate, affect!)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstantRateJump{typeof(Main.rate), typeof(Main.affect!)}(Main.rate, Main.affect!)</code></pre><p>We then specify the parameters needed to simulate our jump process</p><pre><code class="language-julia hljs"># the initial condition vector, notice we make it an integer
# since we have a discrete counting process
u₀ = [0]

# the parameters of the model, in this case a named tuple storing the rate, λ
p = (λ = 2.0,)

# the time interval to solve over
tspan = (0.0, 10.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.0, 10.0)</code></pre><p>Finally, we construct the associated SciML problem types and generate one realization of the process. We first create a <code>DiscreteProblem</code> to encode that we are simulating a process that evolves in discrete time steps.</p><pre><code class="language-julia hljs">dprob = DiscreteProblem(u₀, tspan, p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">DiscreteProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Int64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
timespan: (0.0, 10.0)
u0: 1-element Vector{Int64}:
 0</code></pre><p>We next create a <a href="../../api/#JumpProcesses.JumpProblem"><code>JumpProblem</code></a> that wraps the discrete problem, and specifies which sampling algorithm, called an aggregator in JumpProcesses, to use for determining next jump times (and in the case of multiple possible jumps the next jump type). We call them aggregators because these algorithms are methods for aggregating a set of jumps to determine the next jump time and type.  Here we use the classical <code>Direct</code> method, proposed by Gillespie in the chemical reaction context, but going back to earlier work by Doob and others (and also known as Kinetic Monte Carlo in the physics literature)</p><pre><code class="language-julia hljs"># a jump problem, specifying we will use the Direct method to sample
# jump times and events, and that our jump is encoded by crj
jprob = JumpProblem(dprob, Direct(), crj)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">JumpProblem</span> with problem <span class="sgr38_2" style="color:#56b6c2">DiscreteProblem</span> with aggregator <span class="sgr38_2" style="color:#56b6c2">Direct
Number of jumps with discrete aggregation: 1
Number of jumps with continuous aggregation: 0
Number of mass action jumps: 0
</span></code></pre><p>We are finally ready to simulate one realization of our jump process, selecting <code>SSAStepper</code> to handle time-stepping our system from jump to jump</p><pre><code class="language-julia hljs"># now we simulate the jump process in time, using the SSAStepper time-stepper
sol = solve(jprob, SSAStepper())

plot(sol, labels = &quot;N(t)&quot;, xlabel = &quot;t&quot;, legend = :bottomright)</code></pre><img src="a7aa7405.svg" alt="Example block output"/><h3 id="More-general-ConstantRateJumps"><a class="docs-heading-anchor" href="#More-general-ConstantRateJumps">More general <code>ConstantRateJump</code>s</a><a id="More-general-ConstantRateJumps-1"></a><a class="docs-heading-anchor-permalink" href="#More-general-ConstantRateJumps" title="Permalink"></a></h3><p>The previous counting process could be interpreted as a birth process, where new individuals were created with a constant transition rate λ. Suppose we also allow individuals to be killed with a death rate of μ. The transition rate at time <code>t</code> for some individual to die, assuming the deaths of individuals are independent, is just <span>$\mu N(t)$</span>. Suppose we also wish to keep track of the number of deaths, <span>$D(t)$</span>, that have occurred. We can store these as an auxiliary variable in <code>u[2]</code>. Our processes are then given mathematically by</p><p class="math-container">\[\begin{align*}
N(t) &amp;= Y_b(\lambda t) - Y_d \left(\int_0^t \mu N(s^-) \, ds \right), \\
D(t) &amp;= Y_d \left(\int_0^t \mu N(s^-) \, ds \right),
\end{align*}\]</p><p>where <span>$Y_d(t)$</span> denotes a second, independent, unit Poisson counting process.</p><p>We can encode this as a second jump for our system like</p><pre><code class="language-julia hljs">deathrate(u, p, t) = p.μ * u[1]
deathaffect!(integrator) = (integrator.u[1] -= 1; integrator.u[2] += 1)
deathcrj = ConstantRateJump(deathrate, deathaffect!)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstantRateJump{typeof(Main.deathrate), typeof(Main.deathaffect!)}(Main.deathrate, Main.deathaffect!)</code></pre><p>As the death rate is constant <em>between</em> jumps, we can encode this process as a second <code>ConstantRateJump</code>. Overall, we keep track of four different processes, the population size <span>$N(t)$</span>, total deaths <span>$D(t)$</span>, births <span>$Y_b(t)$</span> and deaths <span>$Y_d(t)$</span>. The vector <span>$(N(t), D(t))$</span> is represented by <span>$u$</span> in our code, with <span>$Y_b(t)$</span> encoded by <code>crj</code> and <span>$Y_d(t)$</span> by <code>death_crj</code>. We then construct the corresponding problems, passing both jumps to <code>JumpProblem</code>, and can solve as before</p><pre><code class="language-julia hljs">p = (λ = 2.0, μ = 1.5)
u₀ = [0, 0]   # (N(0), D(0))
dprob = DiscreteProblem(u₀, tspan, p)
jprob = JumpProblem(dprob, Direct(), crj, deathcrj)
sol = solve(jprob, SSAStepper())
plot(sol, labels = [&quot;N(t)&quot; &quot;D(t)&quot;], xlabel = &quot;t&quot;, legend = :topleft)</code></pre><img src="3a01750c.svg" alt="Example block output"/><p>In the next tutorial, we will also introduce <a href="../../api/#JumpProcesses.MassActionJump"><code>MassActionJump</code></a>s, which are a special type of <a href="../../api/#JumpProcesses.ConstantRateJump"><code>ConstantRateJump</code></a>s that require a more specialized form of transition rate and state update, but can offer better computational performance. They can encode any mass action reaction, as commonly arise in chemical and population process models, and essentially require that <code>rate(u,p,t)</code> be a monomial in the components of <code>u</code> and state changes be given by adding or subtracting a constant vector from <code>u</code>.</p><h2 id="VariableRateJumps-for-processes-that-are-not-constant-between-jumps"><a class="docs-heading-anchor" href="#VariableRateJumps-for-processes-that-are-not-constant-between-jumps"><code>VariableRateJump</code>s for processes that are not constant between jumps</a><a id="VariableRateJumps-for-processes-that-are-not-constant-between-jumps-1"></a><a class="docs-heading-anchor-permalink" href="#VariableRateJumps-for-processes-that-are-not-constant-between-jumps" title="Permalink"></a></h2><p>So far, we have assumed that our jump processes have transition rates that are constant in between jumps. In many applications, this may be a limiting assumption. To support such models, JumpProcesses has the <a href="../../api/#JumpProcesses.VariableRateJump"><code>VariableRateJump</code></a> type, which represents jump processes that have an arbitrary time dependence in the calculation of the transition rate, including transition rates that depend on states which can change in between two jumps occurring. Let&#39;s consider the previous example, but now let the birth rate be time-dependent, <span>$b(t) = \lambda \left(\sin(\pi t / 2) + 1\right)$</span>, so that our model becomes</p><p class="math-container">\[\begin{align*}
N(t) &amp;= Y_b\left(\int_0^t \left( \lambda \sin\left(\tfrac{\pi s}{2}\right) + 1 \right) \, d s\right) - Y_d \left(\int_0^t \mu N(s^-) \, ds \right), \\
D(t) &amp;= Y_d \left(\int_0^t \mu N(s^-) \, ds \right).
\end{align*}\]</p><p>The birth rate is cyclical, bounded between a lower-bound of <span>$λ$</span> and an upper-bound of <span>$2 λ$</span>. We&#39;ll then re-encode the first (birth) jump as a <code>VariableRateJump</code>. Two types of <code>VariableRateJump</code>s are supported, general and bounded. The latter are generally more performant, but are also more restrictive in when they can be used. They also require specifying additional information beyond just <code>rate</code> and <code>affect!</code> functions.</p><p>Let&#39;s see how to build a bounded <code>VariableRateJump</code> encoding our new birth process. We first specify the rate and affect functions, just like for a <code>ConstantRateJump</code>,</p><pre><code class="language-julia hljs">rate1(u, p, t) = p.λ * (sin(pi * t / 2) + 1)
affect1!(integrator) = (integrator.u[1] += 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">affect1! (generic function with 1 method)</code></pre><p>We next provide functions that determine a time interval over which the rate is bounded from above given <code>u</code>, <code>p</code> and <code>t</code>. From these, we can construct the new bounded <code>VariableRateJump</code>:</p><pre><code class="language-julia hljs"># We require that rate1(u,p,s) &lt;= urate(u,p,s)
# for t &lt;= s &lt;= t + rateinterval(u,p,t)
rateinterval(u, p, t) = typemax(t)
urate(u, p, t) = 2 * p.λ

# Optionally, we can give a lower bound over the same interval.
# This may boost computational performance.
lrate(u, p, t) = p.λ

# now we construct the bounded VariableRateJump
vrj1 = VariableRateJump(rate1, affect1!; lrate, urate, rateinterval)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VariableRateJump{typeof(Main.rate1), typeof(Main.affect1!), typeof(Main.lrate), typeof(Main.urate), typeof(Main.rateinterval), Nothing, Float64, Int64}(Main.rate1, Main.affect1!, Main.lrate, Main.urate, Main.rateinterval, nothing, true, 10, (false, true), 1.0e-12, 0)</code></pre><p>Finally, to efficiently simulate the new jump process, we must also specify a dependency graph. This indicates when a given jump occurs, which jumps in the system need to have their rates and/or rate bounds recalculated (for example, due to depending on changed components in <code>u</code>). Internally, JumpProcesses preserves the relative ordering of jumps of each distinct type, but always reorders all <code>ConstantRateJump</code>s to appear before any <code>VariableRateJump</code>s. Irrespective of how <code>JumpProblem</code> is initialized, internally the jumps will be ordered as the vector <code>[deathcrj, vrj1]</code>. Note, this vector of the jumps is distinct from our state variable vector, <code>u</code>.</p><p>We assume the convention that jumps depends on themselves. With regards to <code>vrj1</code> that represents births, we have that when <code>vrj1</code> fires the population <span>$N(t)$</span> increases by 1. Since <code>deathcrj</code> is proportional to population size, then a birth event should trigger an update of the death rate. Conversely, death events do not modify the birth rate, since births only obey seasonal fluctuation. The dependency graph below, <code>dep_graph</code>, encodes this dependency such that <code>dep_graph[1]</code> is a vector of the dependents of death events and <code>dep_graph[2]</code> is a vector of the dependents of birth events.</p><pre><code class="language-julia hljs">dep_graph = [[1], [1, 2]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Vector{Int64}}:
 [1]
 [1, 2]</code></pre><p>We can then construct the corresponding problem, passing both jumps to <code>JumpProblem</code> as well as the dependency graph. We must use an aggregator that supports bounded <code>VariableRateJump</code>s, in this case we choose the <code>Coevolve</code> aggregator.</p><pre><code class="language-julia hljs">jprob = JumpProblem(dprob, Coevolve(), vrj1, deathcrj; dep_graph)
sol = solve(jprob, SSAStepper())
plot(sol, labels = [&quot;N(t)&quot; &quot;D(t)&quot;], xlabel = &quot;t&quot;, legend = :topleft)</code></pre><img src="ea0a4dfa.svg" alt="Example block output"/><p>If we did not know the upper rate bound or rate interval functions for the time-dependent rate, we would have to use a continuous problem type and general <code>VariableRateJump</code> to correctly handle calculating the jump times. Under this assumption, we would define a general <code>VariableRateJump</code> as following:</p><pre><code class="language-julia hljs">vrj2 = VariableRateJump(rate1, affect1!)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VariableRateJump{typeof(Main.rate1), typeof(Main.affect1!), Nothing, Nothing, Nothing, Nothing, Float64, Int64}(Main.rate1, Main.affect1!, nothing, nothing, nothing, nothing, true, 10, (false, true), 1.0e-12, 0)</code></pre><p>Since the death rate now depends on a variable, <code>u[2]</code>, modified by a general <code>VariableRateJump</code> (i.e., one that is not bounded), we also need to redefine the death jump process as a general <code>VariableRateJump</code></p><pre><code class="language-julia hljs">deathvrj = VariableRateJump(deathrate, deathaffect!)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VariableRateJump{typeof(Main.deathrate), typeof(Main.deathaffect!), Nothing, Nothing, Nothing, Nothing, Float64, Int64}(Main.deathrate, Main.deathaffect!, nothing, nothing, nothing, nothing, true, 10, (false, true), 1.0e-12, 0)</code></pre><p>To simulate our jump process, we now need to construct a continuous problem type to couple the jumps to, for example an ordinary differential equation (ODE) or stochastic differential equation (SDE). Let&#39;s use an ODE, encoded via an <code>ODEProblem</code>. We simply set the ODE derivative to zero to preserve the state. We are essentially defining a combined ODE-jump process, i.e., a <a href="https://en.wikipedia.org/wiki/Piecewise-deterministic_Markov_process">piecewise deterministic Markov process</a>, but one where the ODE is trivial and does not change the state. To use this problem type and the ODE solvers, we first load <code>OrdinaryDiffEq.jl</code> or <code>DifferentialEquations.jl</code>. If neither is installed, we first</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;OrdinaryDiffEq&quot;)
# or Pkg.add(&quot;DifferentialEquations&quot;)</code></pre><p>and then load it via</p><pre><code class="language-julia hljs">using OrdinaryDiffEq
# or using DifferentialEquations</code></pre><p>We can then construct our ODE problem with a trivial ODE derivative component. Note, to work with the ODE solver time stepper we must also change our initial condition to be floating point valued</p><pre><code class="language-julia hljs">function f!(du, u, p, t)
    du .= 0
    nothing
end
u₀ = [0.0, 0.0]
oprob = ODEProblem(f!, u₀, tspan, p)
jprob = JumpProblem(oprob, Direct(), vrj2, deathvrj)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">JumpProblem</span> with problem <span class="sgr38_2" style="color:#56b6c2">ODEProblem</span> with aggregator <span class="sgr38_2" style="color:#56b6c2">Direct
Number of jumps with discrete aggregation: 0
Number of jumps with continuous aggregation: 2
Number of mass action jumps: 0
</span></code></pre><p>We can now simulate our jump process, using the <code>Tsit5</code> ODE solver as the time stepper, in place of <code>SSAStepper</code></p><pre><code class="language-julia hljs">sol = solve(jprob, Tsit5())
plot(sol, label = [&quot;N(t)&quot; &quot;D(t)&quot;], xlabel = &quot;t&quot;, legend = :topleft)</code></pre><img src="b43c5e7a.svg" alt="Example block output"/><p>For more details on when bounded vs. general <code>VariableRateJump</code>s can be used, see the <a href="../discrete_stochastic_example/#ssa_tutorial">next tutorial</a> and the <a href="../../jump_types/#jump_problem_type">Jump Problems</a> documentation page.</p><h2 id="Having-a-Random-Jump-Distribution"><a class="docs-heading-anchor" href="#Having-a-Random-Jump-Distribution">Having a Random Jump Distribution</a><a id="Having-a-Random-Jump-Distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Having-a-Random-Jump-Distribution" title="Permalink"></a></h2><p>Suppose we want to simulate a compound Poisson process, <span>$G(t)$</span>, where</p><p class="math-container">\[G(t) = \sum_{i=1}^{N(t)} C_i\]</p><p>with <span>$N(t)$</span> a Poisson counting process with constant transition rate <span>$\lambda$</span>, and the <span>$C_i$</span> independent and identical samples from a uniform distribution over <span>$\{-1,1\}$</span>. We can simulate such a process as follows.</p><p>We first ensure that we use the same random number generator as JumpProcesses. We can either pass one as an input to <a href="../../api/#JumpProcesses.JumpProblem"><code>JumpProblem</code></a> via the <code>rng</code> keyword argument, and make sure it is the same one we use in our <code>affect!</code> function, or we can just use the default generator chosen by JumpProcesses if one is not specified, <code>JumpProcesses.DEFAULT_RNG</code>. Let&#39;s do the latter</p><pre><code class="language-julia hljs">rng = JumpProcesses.DEFAULT_RNG</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Random.TaskLocalRNG()</code></pre><p>Let&#39;s assume <code>u[1]</code> is <span>$N(t)$</span> and <code>u[2]</code> is <span>$G(t)$</span>. We now proceed as in the previous examples</p><pre><code class="language-julia hljs">rate3(u, p, t) = p.λ

# define the affect function via a closure
affect3! = integrator -&gt; let rng = rng
    # N(t) &lt;-- N(t) + 1
    integrator.u[1] += 1

    # G(t) &lt;-- G(t) + C_{N(t)}
    integrator.u[2] += rand(rng, (-1, 1))
    nothing
end
crj = ConstantRateJump(rate3, affect3!)

u₀ = [0, 0]
p = (λ = 1.0,)
tspan = (0.0, 100.0)
dprob = DiscreteProblem(u₀, tspan, p)
jprob = JumpProblem(dprob, Direct(), crj)
sol = solve(jprob, SSAStepper())
plot(sol, label = [&quot;N(t)&quot; &quot;G(t)&quot;], xlabel = &quot;t&quot;)</code></pre><img src="699a8d2e.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions</a><a class="docs-footer-nextpage" href="../discrete_stochastic_example/">Continuous-Time Jump Processes and Gillespie Methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.6.0 on <span class="colophon-date" title="Monday 2 September 2024 02:41">Monday 2 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
