<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · JumpProcesses.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/JumpProcesses/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="JumpProcesses.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">JumpProcesses.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/simple_poisson_process/">Simple Poisson Processes in JumpProcesses</a></li><li><a class="tocitem" href="../tutorials/discrete_stochastic_example/">Continuous-Time Jump Processes and Gillespie Methods</a></li><li><a class="tocitem" href="../tutorials/jump_diffusion/">Piecewise Deterministic Markov Processes and Jump Diffusion Equations</a></li><li><a class="tocitem" href="../tutorials/spatial/">Spatial SSAs with JumpProcesses.jl</a></li></ul></li><li><a class="tocitem" href="../faq/">FAQ</a></li><li><span class="tocitem">Type Documentation</span><ul><li><a class="tocitem" href="../jump_types/">Jump types and JumpProblem</a></li><li><a class="tocitem" href="../jump_solve/">Jump solvers</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Core-Types"><span>Core Types</span></a></li><li><a class="tocitem" href="#Types-of-Jumps"><span>Types of Jumps</span></a></li><li><a class="tocitem" href="#Aggregators"><span>Aggregators</span></a></li><li class="toplevel"><a class="tocitem" href="#Private-API-Functions"><span>Private API Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/JumpProcesses.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="JumpProcesses.jl-API"><a class="docs-heading-anchor" href="#JumpProcesses.jl-API">JumpProcesses.jl API</a><a id="JumpProcesses.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#JumpProcesses.jl-API" title="Permalink"></a></h1><h2 id="Core-Types"><a class="docs-heading-anchor" href="#Core-Types">Core Types</a><a id="Core-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.JumpProblem" href="#JumpProcesses.JumpProblem"><code>JumpProcesses.JumpProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct JumpProblem{iip, P, A, C, J&lt;:Union{Nothing, JumpProcesses.AbstractJumpAggregator}, J2, J3, J4, R, K} &lt;: SciMLBase.AbstractJumpProblem{P, J&lt;:Union{Nothing, JumpProcesses.AbstractJumpAggregator}}</code></pre><p>Defines a collection of jump processes to associate with another problem type.</p><ul><li><a href="https://docs.sciml.ai/JumpProcesses/stable/jump_types/">Documentation Page</a></li><li><a href="https://docs.sciml.ai/JumpProcesses/stable/tutorials/discrete_stochastic_example/">Tutorial Page</a></li><li><a href="https://docs.sciml.ai/JumpProcesses/stable/tutorials/discrete_stochastic_example/#FAQ">FAQ Page</a></li></ul><p><strong>Constructors</strong></p><p><code>JumpProblem</code>s can be constructed by first building another problem type to which the jumps will be associated. For example, to  simulate a collection of jump processes for which the transition rates are constant <em>between</em> jumps (called <a href="#JumpProcesses.ConstantRateJump"><code>ConstantRateJump</code></a>s or <a href="#JumpProcesses.MassActionJump"><code>MassActionJump</code></a>s), we must first construct a <a href="https://docs.sciml.ai/DiffEqDocs/stable/types/discrete_types/"><code>DiscreteProblem</code></a></p><pre><code class="language-julia hljs">prob = DiscreteProblem(u0, p, tspan)</code></pre><p>where <code>u0</code> is the initial condition, <code>p</code> the parameters and <code>tspan</code> the time span. If we wanted to have the jumps coupled with a system of ODEs, or have transition rates with explicit time dependence, we would use an <code>ODEProblem</code> instead that defines the ODE portion of the dynamics.</p><p>Given <code>prob</code> we define the jumps via</p><ul><li><code>JumpProblem(prob, aggregator::AbstractAggregatorAlgorithm, jumps::JumpSet ; kwargs...)</code></li><li><code>JumpProblem(prob, aggregator::AbstractAggregatorAlgorithm, jumps...; kwargs...)</code></li></ul><p>Here <code>aggregator</code> specifies the underlying algorithm for calculating next jump times and types, for example <a href="#JumpProcesses.Direct"><code>Direct</code></a>. The collection of different <code>AbstractJump</code> types can then be passed within a single <a href="#JumpProcesses.JumpSet"><code>JumpSet</code></a> or as subsequent sequential arguments.</p><p><strong>Fields</strong></p><ul><li><p><code>prob</code>: The type of problem to couple the jumps to. For a pure jump process use <code>DiscreteProblem</code>, to couple to ODEs, <code>ODEProblem</code>, etc.</p></li><li><p><code>aggregator</code>: The aggregator algorithm that determines the next jump times and types for <code>ConstantRateJump</code>s and <code>MassActionJump</code>s. Examples include <code>Direct</code>.</p></li><li><p><code>discrete_jump_aggregation</code>: The underlying state data associated with the chosen aggregator.</p></li><li><p><code>jump_callback</code>: <code>CallBackSet</code> with the underlying <code>ConstantRate</code> and <code>VariableRate</code> jumps.</p></li><li><p><code>variable_jumps</code>: The <code>VariableRateJump</code>s.</p></li><li><p><code>regular_jump</code>: The <code>RegularJump</code>s.</p></li><li><p><code>massaction_jump</code>: The <code>MassActionJump</code>s.</p></li><li><p><code>rng</code>: The random number generator to use.</p></li><li><p><code>kwargs</code>: kwargs to pass on to solve call.</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>rng</code>, the random number generator to use. On 1.7 and up defaults to Julia&#39;s built-in generator, below 1.7 uses RandomNumbers.jl&#39;s <code>Xorshifts.Xoroshiro128Star(rand(UInt64))</code>.</li><li><code>save_positions=(true,true)</code>, specifies whether to save the system&#39;s state (before, after) the jump occurs.</li><li><code>spatial_system</code>, for spatial problems the underlying spatial structure.</li><li><code>hopping_constants</code>, for spatial problems the spatial transition rate coefficients.</li><li><code>use_vrj_bounds = true</code>, set to false to disable handling bounded <code>VariableRateJump</code>s with a supporting aggregator (such as <code>Coevolve</code>). They will then be handled via the continuous integration interface, and treated like general <code>VariableRateJump</code>s.</li></ul><p>Please see the <a href="https://docs.sciml.ai/JumpProcesses/stable/tutorials/discrete_stochastic_example/">tutorial page</a> in the DifferentialEquations.jl <a href="https://docs.sciml.ai/JumpProcesses/stable/">docs</a> for usage examples and commonly asked questions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/problem.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.SSAStepper" href="#JumpProcesses.SSAStepper"><code>JumpProcesses.SSAStepper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SSAStepper &lt;: SciMLBase.AbstractDEAlgorithm</code></pre><p>Highly efficient integrator for pure jump problems that involve only <code>ConstantRateJump</code>s, <code>MassActionJump</code>s, and/or <code>VariableRateJump</code>s <em>with rate bounds</em>.</p><p><strong>Notes</strong></p><ul><li>Only works with <code>JumpProblem</code>s defined from <code>DiscreteProblem</code>s.</li><li>Only works with collections of <code>ConstantRateJump</code>s, <code>MassActionJump</code>s, and <code>VariableRateJump</code>s with rate bounds.</li><li>Only supports <code>DiscreteCallback</code>s for events, which are checked after every step taken by <code>SSAStepper</code>.</li><li>Only supports a limited subset of the output controls from the common solver interface, specifically <code>save_start</code>, <code>save_end</code>, and <code>saveat</code>.</li><li>As when using jumps with ODEs and SDEs, saving controls for whether to save each time a jump occurs are via the <code>save_positions</code> keyword argument to <code>JumpProblem</code>. Note that when choosing <code>SSAStepper</code> as the timestepper, <code>save_positions = (true,true)</code>, <code>(true,false)</code>, or <code>(false,true)</code> are all equivalent. <code>SSAStepper</code> will save only the post-jump state in the solution object in each of these cases. This is because solution objects generated via <code>SSAStepper</code> use piecewise-constant interpolation, and can therefore exactly reconstruct the sampled jump process path with knowing just the post-jump state. That is, <code>sol(t)</code> for any <code>0 &lt;= t &lt;= tstop</code> will give the exact value of the sampled solution path at <code>t</code> provided at least one component of <code>save_positions</code> is <code>true</code>.</li></ul><p><strong>Examples</strong></p><p>SIR model:</p><pre><code class="language-julia hljs">using JumpProcesses
β = 0.1 / 1000.0; ν = .01;
p = (β,ν)
rate1(u,p,t) = p[1]*u[1]*u[2]  # β*S*I
function affect1!(integrator)
  integrator.u[1] -= 1         # S -&gt; S - 1
  integrator.u[2] += 1         # I -&gt; I + 1
end
jump = ConstantRateJump(rate1,affect1!)

rate2(u,p,t) = p[2]*u[2]      # ν*I
function affect2!(integrator)
  integrator.u[2] -= 1        # I -&gt; I - 1
  integrator.u[3] += 1        # R -&gt; R + 1
end
jump2 = ConstantRateJump(rate2,affect2!)
u₀    = [999,1,0]
tspan = (0.0,250.0)
prob = DiscreteProblem(u₀, tspan, p)
jump_prob = JumpProblem(prob, Direct(), jump, jump2)
sol = solve(jump_prob, SSAStepper())</code></pre><p>see the <a href="https://docs.sciml.ai/JumpProcesses/stable/tutorials/discrete_stochastic_example/">tutorial</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/SSA_stepper.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.reset_aggregated_jumps!" href="#JumpProcesses.reset_aggregated_jumps!"><code>JumpProcesses.reset_aggregated_jumps!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reset_aggregated_jumps!(integrator, uprev = nothing; update_jump_params=true)</code></pre><p>Reset the state of jump processes and associated solvers following a change in parameters or such.</p><p>Notes</p><ul><li><code>update_jump_params=true</code> will recalculate the rates stored within any MassActionJump that was built from the parameter vector. If the parameter vector is unchanged, this can safely be set to false to improve performance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/aggregators/aggregated_api.jl#L1-L12">source</a></section></article><h2 id="Types-of-Jumps"><a class="docs-heading-anchor" href="#Types-of-Jumps">Types of Jumps</a><a id="Types-of-Jumps-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-Jumps" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.ConstantRateJump" href="#JumpProcesses.ConstantRateJump"><code>JumpProcesses.ConstantRateJump</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConstantRateJump{F1, F2} &lt;: JumpProcesses.AbstractJump</code></pre><p>Defines a jump process with a rate (i.e. hazard, intensity, or propensity) that does not <em>explicitly</em> depend on time. More precisely, one where the rate function is constant <em>between</em> the occurrence of jumps. For detailed examples and usage information, see the</p><ul><li><a href="https://docs.sciml.ai/JumpProcesses/stable/tutorials/discrete_stochastic_example/">Tutorial</a></li></ul><p><strong>Fields</strong></p><ul><li><p><code>rate</code>: Function <code>rate(u,p,t)</code> that returns the jump&#39;s current rate.</p></li><li><p><code>affect!</code>: Function <code>affect(integrator)</code> that updates the state for one occurrence of the jump.</p></li></ul><p><strong>Examples</strong></p><p>Suppose <code>u[1]</code> gives the number of particles and <code>p[1]</code> the probability per time each particle can decay away. A corresponding <code>ConstantRateJump</code> for this jump process is</p><pre><code class="language-julia hljs">rate(u,p,t) = p[1]*u[1]
affect!(integrator) = integrator.u[1] -= 1
crj = ConstantRateJump(rate, affect!)</code></pre><p>Notice, here that <code>rate</code> changes in time, but is constant between the occurrence of jumps (when <code>u[1]</code> will decrease).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/jumps.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.MassActionJump" href="#JumpProcesses.MassActionJump"><code>JumpProcesses.MassActionJump</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MassActionJump{T, S, U, V} &lt;: JumpProcesses.AbstractMassActionJump</code></pre><p>Optimized representation for <code>ConstantRateJump</code>s that can be represented in mass action form, offering improved performance within jump algorithms compared to <code>ConstantRateJump</code>. For detailed examples and usage information, see the</p><ul><li><a href="https://docs.sciml.ai/JumpProcesses/stable/jump_types/#Defining-a-Mass-Action-Jump">Main Docs</a></li><li><a href="https://docs.sciml.ai/JumpProcesses/stable/tutorials/discrete_stochastic_example/">Tutorial</a></li></ul><p><strong>Constructors</strong></p><ul><li><code>MassActionJump(reactant_stoich, net_stoich; scale_rates = true, param_idxs = nothing)</code></li></ul><p>Here <code>reactant_stoich</code> denotes the reactant stoichiometry for each reaction and <code>net_stoich</code> the net stoichiometry for each reaction.</p><p><strong>Fields</strong></p><ul><li><p><code>scaled_rates</code>: The (scaled) reaction rate constants.</p></li><li><p><code>reactant_stoch</code>: The reactant stoichiometry vectors.</p></li><li><p><code>net_stoch</code>: The net stoichiometry vectors.</p></li><li><p><code>param_mapper</code>: Parameter mapping functor to identify reaction rate constants with parameters in <code>p</code> vectors.</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>scale_rates = true</code>, whether to rescale the reaction rate constants according to the stoichiometry.</li><li><code>nocopy = false</code>, whether the <code>MassActionJump</code> can alias the <code>scaled_rates</code> and <code>reactant_stoch</code> from the input. Note, if <code>scale_rates=true</code> this will potentially modify both of these.</li><li><code>param_idxs = nothing</code>, indexes in the parameter vector, <code>JumpProblem.prob.p</code>, that correspond to each reaction&#39;s rate.</li></ul><p>See the tutorial and main docs for details.</p><p><strong>Examples</strong></p><p>An SIR model with <code>S + I --&gt; 2I</code> at rate β as the first reaction and <code>I --&gt; R</code> at rate ν as the second reaction can be encoded by</p><pre><code class="language-julia hljs">p        = (β=1e-4, ν=.01)
u0       = [999, 1, 0]       # (S,I,R)
tspan    = (0.0, 250.0)
rateidxs = [1, 2]           # i.e. [β,ν]
reactant_stoich =
[
  [1 =&gt; 1, 2 =&gt; 1],         # 1*S and 1*I
  [2 =&gt; 1]                  # 1*I
]
net_stoich =
[
  [1 =&gt; -1, 2 =&gt; 1],        # -1*S and 1*I
  [2 =&gt; -1, 3 =&gt; 1]         # -1*I and 1*R
]
maj = MassActionJump(reactant_stoich, net_stoich; param_idxs=rateidxs)
prob = DiscreteProblem(u0, tspan, p)
jprob = JumpProblem(prob, Direct(), maj)</code></pre><p><strong>Notes</strong></p><ul><li>By default, reaction rates are rescaled when constructing the <code>MassActionJump</code> as explained in the <a href="https://docs.sciml.ai/JumpProcesses/stable/jump_types/#Defining-a-Mass-Action-Jump">main docs</a>. Disable this with the kwarg <code>scale_rates=false</code>.</li><li>Also see the <a href="https://docs.sciml.ai/JumpProcesses/stable/jump_types/#Defining-a-Mass-Action-Jump">main docs</a> for how to specify reactions with no products or no reactants.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/jumps.jl#L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.VariableRateJump" href="#JumpProcesses.VariableRateJump"><code>JumpProcesses.VariableRateJump</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct VariableRateJump{R, F, R2, R3, R4, I, T, T2} &lt;: JumpProcesses.AbstractJump</code></pre><p>Defines a jump process with a rate (i.e. hazard, intensity, or propensity) that may explicitly depend on time. More precisely, one where the rate function is allowed to change <em>between</em> the occurrence of jumps. For detailed examples and usage information, see the</p><ul><li><a href="https://docs.sciml.ai/JumpProcesses/stable/tutorials/discrete_stochastic_example/">Tutorial</a></li></ul><p>Note that two types of <code>VariableRateJump</code>s are currently supported, with different performance characteritistics.</p><ul><li><p>A general <code>VariableRateJump</code> or <code>VariableRateJump</code> will refer to one in which only <code>rate</code> and <code>affect</code> functions are specified.</p><ul><li>These are the most general in what they can represent, but require the use of an <code>ODEProblem</code> or <code>SDEProblem</code> whose underlying timestepper handles their evolution in time (via the callback interface).</li><li>This is the least performant jump type in simulations.</li></ul></li><li><p>Bounded <code>VariableRateJump</code>s require passing the keyword arguments <code>urate</code> and <code>rateinterval</code>, corresponding to functions <code>urate(u, p, t)</code> and <code>rateinterval(u, p, t)</code>, see below. These must calculate a time window over which the rate function is bounded by a constant. Note that it is ok if the rate bound would be violated within the time interval due to a change in <code>u</code> arising from another <code>ConstantRateJump</code>, <code>MassActionJump</code> or <em>bounded</em> <code>VariableRateJump</code> being executed, as the chosen aggregator will then handle recalculating the rate bound and interval. <em>However, if the bound could be violated within the time interval due to a change in <code>u</code> arising from continuous dynamics such as a coupled ODE, SDE, or a general <code>VariableRateJump</code>, bounds should not be given.</em> This ensures the jump is classified as a general <code>VariableRateJump</code> and properly handled. One can also optionally provide a lower bound function, <code>lrate(u, p, t)</code>, via the <code>lrate</code> keyword argument. This can lead to increased performance. The validity of the lower bound should hold under the same conditions and rate interval as <code>urate</code>.</p><ul><li>Bounded <code>VariableRateJump</code>s can currently be used in the <code>Coevolve</code> aggregator, and can therefore be efficiently simulated in pure-jump <code>DiscreteProblem</code>s using the <code>SSAStepper</code> time-stepper.</li><li>These can be substantially more performant than general <code>VariableRateJump</code>s without the rate bound functions.</li></ul></li></ul><p>Reemphasizing, the additional user provided functions leveraged by bounded <code>VariableRateJumps</code>, <code>urate(u, p, t)</code>, <code>rateinterval(u, p, t)</code>, and the optional <code>lrate(u, p, t)</code> require that</p><ul><li>For <code>s</code> in <code>[t, t + rateinterval(u, p, t)]</code>, we have that <code>lrate(u, p, t) &lt;= rate(u, p, s) &lt;= urate(u, p, t)</code>.</li><li>It is ok if these bounds would be violated during the time window due to another <code>ConstantRateJump</code>, <code>MassActionJump</code> or bounded <code>VariableRateJump</code> occurring. However, they must remain valid if <code>u</code> changes for any other reason (for example, due to continuous dynamics like ODEs, SDEs, or general <code>VariableRateJump</code>s).</li></ul><p><strong>Fields</strong></p><ul><li><p><code>rate</code>: Function <code>rate(u,p,t)</code> that returns the jump&#39;s current rate given state <code>u</code>, parameters <code>p</code> and time <code>t</code>.</p></li><li><p><code>affect!</code>: Function <code>affect!(integrator)</code> that updates the state for one occurrence of the jump given <code>integrator</code>.</p></li><li><p><code>lrate</code>: Optional function <code>lrate(u, p, t)</code> that computes a lower bound on the rate in the interval <code>t</code> to <code>t + rateinterval(u, p, t)</code> at time <code>t</code> given state <code>u</code> and parameters <code>p</code>. This bound must rigorously hold during the time interval as long as another <code>ConstantRateJump</code>, <code>MassActionJump</code>, or <em>bounded</em> <code>VariableRateJump</code> has not been sampled. When using aggregators that support bounded <code>VariableRateJump</code>s, currently only <code>Coevolve</code>, providing a lower-bound can lead to improved performance.</p></li></ul><ul><li><p><code>urate</code>: Optional function <code>urate(u, p, t)</code> for general <code>VariableRateJump</code>s, but is required to define a bounded <code>VariableRateJump</code>, which can be used with supporting aggregators,  currently only <code>Coevolve</code>, and offers improved computational performance. Computes an upper bound for the rate in the interval <code>t</code> to <code>t + rateinterval(u, p, t)</code> at time <code>t</code> given state <code>u</code> and parameters <code>p</code>. This bound must rigorously hold during the time interval as long as another <code>ConstantRateJump</code>, <code>MassActionJump</code>, or <em>bounded</em> <code>VariableRateJump</code> has not been sampled.</p></li><li><p><code>rateinterval</code>: Optional function <code>rateinterval(u, p, t)</code> for general <code>VariableRateJump</code>s, but is required to define a bounded <code>VariableRateJump</code>, which can be used with supporting  aggregators, currently only <code>Coevolve</code>, and offers improved computational performance. Computes the time interval from time <code>t</code> over which the <code>urate</code> and <code>lrate</code> bounds will hold, <code>t</code> to <code>t + rateinterval(u, p, t)</code>, given state <code>u</code> and parameters <code>p</code>. This bound must rigorously hold during the time interval as long as another <code>ConstantRateJump</code>, <code>MassActionJump</code>, or <em>bounded</em> <code>VariableRateJump</code> has not been sampled.</p></li><li><p><code>idxs</code></p></li><li><p><code>rootfind</code></p></li><li><p><code>interp_points</code></p></li><li><p><code>save_positions</code></p></li><li><p><code>abstol</code></p></li><li><p><code>reltol</code></p></li></ul><p><strong>Examples</strong></p><p>Suppose <code>u[1]</code> gives the number of particles and <code>t*p[1]</code> the probability per time each particle can decay away. A corresponding <code>VariableRateJump</code> for this jump process is</p><pre><code class="language-julia hljs">rate(u,p,t) = t*p[1]*u[1]
affect!(integrator) = integrator.u[1] -= 1
vrj = VariableRateJump(rate, affect!)</code></pre><p>To define a bounded <code>VariableRateJump</code> that can be used with supporting aggregators such as <code>Coevolve</code>, we must define bounds and a rate interval:</p><pre><code class="language-julia hljs">rateinterval(u,p,t) = (1 / p[1]) * 2
rate(u,p,t) = t * p[1] * u[1]
lrate(u, p, t) = rate(u, p, t)
urate(u,p,t) = rate(u, p, t + rateinterval(u,p,t))
affect!(integrator) = integrator.u[1] -= 1
vrj = VariableRateJump(rate, affect!; lrate = lrate, urate = urate,
                                      rateinterval = rateinterval)</code></pre><p><strong>Notes</strong></p><ul><li>When using an aggregator that supports bounded <code>VariableRateJump</code>s, <code>DiscreteProblem</code> can be used. Otherwise, <code>ODEProblem</code> or <code>SDEProblem</code> must be used.</li><li><strong>When not using aggregators that support bounded <code>VariableRateJump</code>s, or when there are general <code>VariableRateJump</code>s, <code>integrator</code>s store an effective state type that wraps the main state vector.</strong> See <a href="#JumpProcesses.ExtendedJumpArray"><code>ExtendedJumpArray</code></a> for details on using this object. In this case all <code>ConstantRateJump</code>, <code>VariableRateJump</code> and callback <code>affect!</code> functions receive an integrator with <code>integrator.u</code> an <a href="#JumpProcesses.ExtendedJumpArray"><code>ExtendedJumpArray</code></a>.</li><li>Salis H., Kaznessis Y.,  Accurate hybrid stochastic simulation of a system of coupled chemical or biochemical reactions, Journal of Chemical Physics, 122 (5), DOI:10.1063/1.1835951 is used for calculating jump times with <code>VariableRateJump</code>s within ODE/SDE integrators.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/jumps.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.RegularJump" href="#JumpProcesses.RegularJump"><code>JumpProcesses.RegularJump</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RegularJump{iip, R, C, MD}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/jumps.jl#L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.JumpSet" href="#JumpProcesses.JumpSet"><code>JumpProcesses.JumpSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct JumpSet{T1, T2, T3, T4} &lt;: JumpProcesses.AbstractJump</code></pre><p>Defines a collection of jumps that should collectively be included in a simulation.</p><p><strong>Fields</strong></p><ul><li><p><code>variable_jumps</code>: Collection of <a href="#JumpProcesses.VariableRateJump"><code>VariableRateJump</code></a>s</p></li><li><p><code>constant_jumps</code>: Collection of <a href="#JumpProcesses.ConstantRateJump"><code>ConstantRateJump</code></a>s</p></li><li><p><code>regular_jump</code>: Collection of <a href="#JumpProcesses.RegularJump"><code>RegularJump</code></a>s</p></li><li><p><code>massaction_jump</code>: Collection of <a href="#JumpProcesses.MassActionJump"><code>MassActionJump</code></a>s</p></li></ul><p><strong>Examples</strong></p><p>Here we construct two jumps, store them in a <code>JumpSet</code>, and then simulate the resulting process.</p><pre><code class="language-julia hljs">using JumpProcesses, OrdinaryDiffEq

rate1(u,p,t) = p[1]
affect1!(integrator) = (integrator.u[1] += 1)
crj = ConstantRateJump(rate1, affect1!)

rate2(u,p,t) = (t/(1+t))*p[2]*u[1]
affect2!(integrator) = (integrator.u[1] -= 1)
vrj = VariableRateJump(rate2, affect2!)

jset = JumpSet(crj, vrj)

f!(du,u,p,t) = (du .= 0)
u0 = [0.0]
p = (20.0, 2.0)
tspan = (0.0, 200.0)
oprob = ODEProblem(f!, u0, tspan, p)
jprob = JumpProblem(oprob, Direct(), jset)
sol = solve(jprob, Tsit5())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/jumps.jl#L453">source</a></section></article><h2 id="Aggregators"><a class="docs-heading-anchor" href="#Aggregators">Aggregators</a><a id="Aggregators-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregators" title="Permalink"></a></h2><p>Aggregators are the underlying algorithms used for sampling <a href="#JumpProcesses.ConstantRateJump"><code>ConstantRateJump</code></a>s, <a href="#JumpProcesses.MassActionJump"><code>MassActionJump</code></a>s, and <a href="#JumpProcesses.VariableRateJump"><code>VariableRateJump</code></a>s.</p><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.Coevolve" href="#JumpProcesses.Coevolve"><code>JumpProcesses.Coevolve</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An improvement of the COEVOLVE algorithm for simulating any compound jump process that evolves through time. This method handles variable intensity rates with user-defined bounds and inter-dependent processes. It reduces to NRM when rates are constant. As opposed to COEVOLVE, this method syncs the thinning procedure with the stepper which allows it to handle dependencies on continuous dynamics.</p><p>M. Farajtabar, Y. Wang, M. Gomez-Rodriguez, S. Li, H. Zha, and L. Song, COEVOLVE: a joint point process model for information diffusion and network evolution, Journal of Machine Learning Research 18(1), 1305–1353 (2017). doi: 10.5555/3122009.3122050.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/aggregators/aggregators.jl#L122-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.Direct" href="#JumpProcesses.Direct"><code>JumpProcesses.Direct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Gillespie&#39;s Direct method. <code>ConstantRateJump</code> rates and affects are stored in tuples. Fastest for a small (total) number of <code>ConstantRateJump</code>s or <code>MassActionJump</code>s (~10). For larger numbers of possible jumps, use other methods.</p><p>Daniel T. Gillespie, A general method for numerically simulating the stochastic time evolution of coupled chemical reactions, Journal of Computational Physics, 22 (4), 403–434 (1976). doi:10.1016/0021-9991(76)90041-3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/aggregators/aggregators.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.DirectCR" href="#JumpProcesses.DirectCR"><code>JumpProcesses.DirectCR</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Composition-Rejection Direct method. Performs best relative to other methods for systems with large numbers of jumps with special structure (for example a linear chain of reactions, or jumps corresponding to particles hopping on a grid or graph).</p><p>A. Slepoy, A.P. Thompson and S.J. Plimpton, A constant-time kinetic Monte Carlo algorithm for simulation of large biochemical reaction networks, Journal of Chemical Physics, 128 (20), 205101 (2008). doi:10.1063/1.2919546.</p><p>S. Mauch and M. Stalzer, Efficient formulations for exact stochastic simulation of chemical systems, ACM Transactions on Computational Biology and Bioinformatics, 8 (1), 27-35 (2010). doi:10.1109/TCBB.2009.47.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/aggregators/aggregators.jl#L30-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.FRM" href="#JumpProcesses.FRM"><code>JumpProcesses.FRM</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Gillespie&#39;s First Reaction Method. Should not be used for practical applications due to slow performance relative to all other methods.</p><p>Daniel T. Gillespie, A general method for numerically simulating the stochastic time evolution of coupled chemical reactions, Journal of Computational Physics, 22 (4), 403–434 (1976). doi:10.1016/0021-9991(76)90041-3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/aggregators/aggregators.jl#L90-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.NRM" href="#JumpProcesses.NRM"><code>JumpProcesses.NRM</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Next Reaction Method. Can significantly outperform Direct for systems with large numbers of jumps and sparse dependency graphs, but is usually slower than one of <code>DirectCR</code>, <code>RSSA</code>, or <code>RSSACR</code> for such systems.</p><p>M. A. Gibson and J. Bruck, Efficient exact stochastic simulation of chemical systems with many species and many channels, Journal of Physical Chemistry A, 104 (9), 1876-1889 (2000). doi:10.1021/jp993732q.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/aggregators/aggregators.jl#L111-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.RDirect" href="#JumpProcesses.RDirect"><code>JumpProcesses.RDirect</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A rejection-based direct method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/aggregators/aggregators.jl#L83-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.RSSA" href="#JumpProcesses.RSSA"><code>JumpProcesses.RSSA</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Rejection SSA method. One of the best methods for systems with hundreds to many thousands of jumps (along with <code>RSSACR</code>) and sparse dependency graphs.</p><p>V. H. Thanh, C. Priami and R. Zunino, Efficient rejection-based simulation of biochemical reactions with stochastic noise and delays, Journal of Chemical Physics, 141 (13), 134116 (2014). doi:10.1063/1.4896985</p><p>V. H. Thanh, R. Zunino and C. Priami, On the rejection-based algorithm for simulation and analysis of large-scale reaction networks, Journal of Chemical Physics, 142 (24), 244106 (2015). doi:10.1063/1.4922923.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/aggregators/aggregators.jl#L58-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.RSSACR" href="#JumpProcesses.RSSACR"><code>JumpProcesses.RSSACR</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Rejection SSA Composition-Rejection method. Often the best performer for systems with tens of thousands of jumps and sparse dependency graphs.</p><p>V. H. Thanh, R. Zunino, and C. Priami, Efficient constant-time complexity algorithm for stochastic simulation of large reaction networks, IEEE/ACM Transactions on Computational Biology and Bioinformatics, 14 (3), 657-667 (2017). doi:10.1109/TCBB.2016.2530066.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/aggregators/aggregators.jl#L72-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.SortingDirect" href="#JumpProcesses.SortingDirect"><code>JumpProcesses.SortingDirect</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Sorting Direct method. Often the fastest algorithm for smaller to moderate sized systems (tens of jumps), or systems where a few jumps occur much more frequently than others.</p><p>J. M. McCollum, G. D. Peterson, C. D. Cox, M. L. Simpson and N. F. Samatova, The sorting direct method for stochastic simulation of biochemical systems with varying reaction execution behavior, Computational Biology and Chemistry, 30 (1), 39049 (2006). doi:10.1016/j.compbiolchem.2005.10.007.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/aggregators/aggregators.jl#L46-L55">source</a></section></article><h1 id="Private-API-Functions"><a class="docs-heading-anchor" href="#Private-API-Functions">Private API Functions</a><a id="Private-API-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Private-API-Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.ExtendedJumpArray" href="#JumpProcesses.ExtendedJumpArray"><code>JumpProcesses.ExtendedJumpArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExtendedJumpArray{T3&lt;:Number, T1, T&lt;:AbstractArray{T3&lt;:Number, T1}, T2} &lt;: AbstractArray{T3&lt;:Number, 1}</code></pre><p>Extended state definition used within integrators when there are <code>VariableRateJump</code>s in a system. For detailed examples and usage information, see the</p><ul><li><a href="https://docs.sciml.ai/JumpProcesses/stable/tutorials/discrete_stochastic_example/">Tutorial</a></li></ul><p><strong>Fields</strong></p><ul><li><p><code>u</code>: The current state.</p></li><li><p><code>jump_u</code>: The current rate (i.e. hazard, intensity, or propensity) values for the <code>VariableRateJump</code>s.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using JumpProcesses, OrdinaryDiffEq
f(du,u,p,t) = du .= 0
rate(u,p,t) = (1+t)*u[1]*u[2]

# suppose we wish to decrease each of the two variables by one
# when a jump occurs
function affect!(integrator)
   # Method 1, direct indexing works like normal
   integrator.u[1] -= 1
   integrator.u[2] -= 1

   # Method 2, if we want to broadcast or use array operations we need
   # to access integrator.u.u which is the actual state object.
   # So equivalently to above we could have said:
   # integrator.u.u .-= 1
end

u0 = [10.0, 10.0]
vrj = VariableRateJump(rate, affect!)
oprob = ODEProblem(f, u0, (0.0,2.0))
jprob = JumpProblem(oprob, Direct(), vrj)
sol = solve(jprob,Tsit5())</code></pre><p><strong>Notes</strong></p><ul><li><p>If <code>ueja isa ExtendedJumpArray</code> with <code>ueja.u</code> of size <code>N</code> and <code>ueja.jump_u</code> of size <code>num_variableratejumps</code> then</p><pre><code class="language-julia hljs"># for 1 &lt;= i &lt;= N
ueja[i] == ueja.u[i]

# for N &lt; i &lt;= (N+num_variableratejumps)
ueja[i] == ueja.jump_u[i]</code></pre></li><li><p>In a system with <code>VariableRateJump</code>s all callback, <code>ConstantRateJump</code>, and <code>VariableRateJump</code> <code>affect!</code> functions will receive integrators with <code>integrator.u</code> an <code>ExtendedJumpArray</code>.</p></li><li><p>As such, <code>affect!</code> functions that wish to modify the state via vector operations should use <code>ueja.u.u</code> to obtain the aliased state object.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/extended_jump_array.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JumpProcesses.SSAIntegrator" href="#JumpProcesses.SSAIntegrator"><code>JumpProcesses.SSAIntegrator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct SSAIntegrator{F, uType, tType, tdirType, P, S, CB, SA, OPT, TS} &lt;: JumpProcesses.AbstractSSAIntegrator{SSAStepper, Nothing, uType, tType}</code></pre><p>Solution objects for pure jump problems solved via <code>SSAStepper</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>f</code>: The underlying <code>prob.f</code> function. Not currently used.</p></li><li><p><code>u</code>: The current solution values.</p></li><li><p><code>t</code>: The current solution time.</p></li><li><p><code>tprev</code>: The previous time a jump occurred.</p></li><li><p><code>tdir</code>: The direction time is changing in (must be positive, indicating time is increasing)</p></li><li><p><code>p</code>: The current parameters.</p></li><li><p><code>sol</code>: The current solution object.</p></li><li><p><code>i</code></p></li><li><p><code>tstop</code>: The next jump time.</p></li><li><p><code>cb</code>: The jump aggregator callback.</p></li><li><p><code>saveat</code>: Times to save the solution at.</p></li><li><p><code>save_everystep</code>: Whether to save every time a jump occurs.</p></li><li><p><code>save_end</code>: Whether to save at the final step.</p></li><li><p><code>cur_saveat</code>: Index of the next <code>saveat</code> time.</p></li><li><p><code>opts</code>: Tuple storing callbacks.</p></li><li><p><code>tstops</code>: User supplied times to step to, useful with callbacks.</p></li><li><p><code>tstops_idx</code></p></li><li><p><code>u_modified</code></p></li><li><p><code>keep_stepping</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/JumpProcesses.jl/blob/5dda729a6b846761e5e0e5af9431968ea777f270/src/SSA_stepper.jl#L56">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../jump_solve/">« Jump solvers</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 3 September 2023 05:14">Sunday 3 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
