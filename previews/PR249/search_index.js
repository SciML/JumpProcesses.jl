var documenterSearchIndex = {"docs":
[{"location":"api/#DiffEqJump.jl-API","page":"API","title":"DiffEqJump.jl API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = DiffEqJump","category":"page"},{"location":"api/#Core-Types","page":"API","title":"Core Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JumpProblem\nSSAStepper","category":"page"},{"location":"api/#DiffEqJump.JumpProblem","page":"API","title":"DiffEqJump.JumpProblem","text":"mutable struct JumpProblem{iip, P, A, C, J<:Union{Nothing, DiffEqJump.AbstractJumpAggregator}, J2, J3, J4, R} <: SciMLBase.AbstractJumpProblem{P, J<:Union{Nothing, DiffEqJump.AbstractJumpAggregator}}\n\nDefines a collection of jump processes to associate with another problem type.\n\nDocumentation Page\nTutorial Page\nFAQ Page\n\nConstructors\n\nJumpProblems can be constructed by first building another problem type to which the jumps will be associated. For example, to  simulate a collection of jump processes for which the transition rates are constant between jumps (called ConstantRateJumps or MassActionJumps), we must first construct a DiscreteProblem\n\nprob = DiscreteProblem(u0, p, tspan)\n\nwhere u0 is the initial condition, p the parameters and tspan the time span. If we wanted to have the jumps coupled with a system of ODEs, or have transition rates with explicit time dependence, we would use an ODEProblem instead that defines the ODE portion of the dynamics.\n\nGiven prob we define the jumps via\n\nJumpProblem(prob, aggregator::AbstractAggregatorAlgorithm, jumps::JumpSet ; kwargs...)\nJumpProblem(prob, aggregator::AbstractAggregatorAlgorithm, jumps...; kwargs...)\n\nHere aggregator specifies the underlying algorithm for calculating next jump times and types, for example Direct. The collection of different AbstractJump types can then be passed within a single JumpSet or as subsequent sequential arguments.\n\nFields\n\nprob\nThe type of problem to couple the jumps to. For a pure jump process use DiscreteProblem, to couple to ODEs, ODEProblem, etc.\naggregator\nThe aggregator algorithm that determines the next jump times and types for ConstantRateJumps and MassActionJumps. Examples include Direct.\ndiscrete_jump_aggregation\nThe underlying state data associated with the chosen aggregator.\njump_callback\nCallBackSet with the underlying ConstantRate and VariableRate jumps.\nvariable_jumps\nThe VariableRateJumps.\nregular_jump\nThe RegularJumps.\nmassaction_jump\nThe MassActionJumps.\nrng\nThe random number generator to use.\n\nKeyword Arguments\n\nrng, the random number generator to use. On 1.7 and up defaults to Julia's builtin generator, below 1.7 uses RandomNumbers.jl's Xorshifts.Xoroshiro128Star(rand(UInt64)).\nsave_positions=(true,true), specifies whether to save the system's state (before,after) the jump occurs.\nspatial_system, for spatial problems the underlying spatial structure.\nhopping_constants, for spatial problems the spatial transition rate coefficients.\n\nPlease see the tutorial page in the DifferentialEquations.jl docs for usage examples and commonly asked questions.\n\n\n\n\n\n","category":"type"},{"location":"api/#DiffEqJump.SSAStepper","page":"API","title":"DiffEqJump.SSAStepper","text":"struct SSAStepper <: SciMLBase.DEAlgorithm\n\nHighly efficient integrator for pure jump problems that involve only ConstantRateJumps and/or MassActionJumps.\n\nNotes\n\nOnly works with JumProblems defined from DiscreteProblems.\nOnly works with collections of ConstantRateJumps and MassActionJumps.\nOnly supports DiscreteCallbacks for events.\n\nExamples\n\nSIR model:\n\nusing DiffEqJump\nβ = 0.1 / 1000.0; ν = .01;\np = (β,ν)\nrate1(u,p,t) = p[1]*u[1]*u[2]  # β*S*I\nfunction affect1!(integrator)\n  integrator.u[1] -= 1         # S -> S - 1\n  integrator.u[2] += 1         # I -> I + 1\nend\njump = ConstantRateJump(rate1,affect1!)\n\nrate2(u,p,t) = p[2]*u[2]      # ν*I\nfunction affect2!(integrator)\n  integrator.u[2] -= 1        # I -> I - 1\n  integrator.u[3] += 1        # R -> R + 1\nend\njump2 = ConstantRateJump(rate2,affect2!)\nu₀    = [999,1,0]\ntspan = (0.0,250.0)\nprob = DiscreteProblem(u₀, tspan, p)\njump_prob = JumpProblem(prob, Direct(), jump, jump2)\nsol = solve(jump_prob, SSAStepper())\n\nsee the tutorial for details.\n\n\n\n\n\n","category":"type"},{"location":"api/#Types-of-Jumps","page":"API","title":"Types of Jumps","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ConstantRateJump\nMassActionJump\nVariableRateJump\nJumpSet","category":"page"},{"location":"api/#DiffEqJump.ConstantRateJump","page":"API","title":"DiffEqJump.ConstantRateJump","text":"struct ConstantRateJump{F1, F2} <: DiffEqJump.AbstractJump\n\nDefines a jump process with a rate (i.e. hazard, intensity, or propensity) that does not explicitly depend on time. More precisely, one where the rate function is constant between the occurrence of jumps. For detailed examples and usage information see the\n\nTutorial\n\nFields\n\nrate\nFunction rate(u,p,t) that returns the jump's current rate.\naffect!\nFunction affect(integrator) that updates the state for one occurrence of the jump.\n\nExamples\n\nSuppose u[1] gives the amount of particles and p[1] the probability per time each particle can decay away. A corresponding ConstantRateJump for this jump process is\n\nrate(u,p,t) = p[1]*u[1]\naffect!(integrator) = integrator.u[1] -= 1\ncrj = ConstantRateJump(rate, affect!)\n\nNotice, here that rate changes in time, but is constant between the occurrence of jumps (when u[1] will decrease).\n\n\n\n\n\n","category":"type"},{"location":"api/#DiffEqJump.MassActionJump","page":"API","title":"DiffEqJump.MassActionJump","text":"struct MassActionJump{T, S, U, V} <: DiffEqJump.AbstractMassActionJump\n\nOptimized representation for ConstantRateJumps that can be represented in mass action form, offering improved performance within jump algorithms compared to ConstantRateJump. For detailed examples and usage information see the\n\nMain Docs\nTutorial\n\nConstructors\n\nMassActionJump(reactant_stoich, net_stoich; scale_rates=true, param_idxs=nothing)\n\nHere reactant_stoich denotes the reactant stoichiometry for each reaction and net_stoich the net stoichiometry for each reaction.\n\nFields\n\nscaled_rates\nThe (scaled) reaction rate constants.\nreactant_stoch\nThe reactant stoichiometry vectors.\nnet_stoch\nThe net stoichiometry vectors.\nparam_mapper\nParameter mapping functor to identify reaction rate constants with parameters in p vectors.\n\nKeyword Arguments\n\nscale_rates=true, whether to rescale the reaction rate constants according to the stoichiometry.\nnocopy=false, whether the MassActionJump can alias the scaled_rates and reactant_stoch from the input. Note, if scale_rates=true this will potentially modify both of these.\nparam_idxs=nothing, indexes in the parameter vector, JumpProblem.prob.p, that correspond to each reaction's rate.\n\nSee the tutorial and main docs for details.\n\nExamples\n\nAn SIR model with S + I --> 2I at rate β as the first reaction and I --> R at rate ν as the second reaction can be encoded by\n\np        = (β=1e-4, ν=.01)\nu0       = [999, 1, 0]       # (S,I,R)\ntspan    = (0.0, 250.0)\nrateidxs = [1, 2]           # i.e. [β,ν]\nreactant_stoich =\n[\n  [1 => 1, 2 => 1],         # 1*S and 1*I\n  [2 => 1]                  # 1*I\n]\nnet_stoich =\n[\n  [1 => -1, 2 => 1],        # -1*S and 1*I\n  [2 => -1, 3 => 1]         # -1*I and 1*R\n]\nmaj = MassActionJump(reactant_stoich, net_stoich; param_idxs=rateidxs)\nprob = DiscreteProblem(u0, tspan, p)\njprob = JumpProblem(prob, Direct(), maj)\n\nNotes\n\nBy default reaction rates are rescaled when constructing the MassActionJump as explained in the main docs. Disable this with the kwarg scale_rates=false.\nAlso see the main docs for how to specify reactions with no products or no reactants.\n\n\n\n\n\n","category":"type"},{"location":"api/#DiffEqJump.VariableRateJump","page":"API","title":"DiffEqJump.VariableRateJump","text":"struct VariableRateJump{R, F, I, T, T2} <: DiffEqJump.AbstractJump\n\nDefines a jump process with a rate (i.e. hazard, intensity, or propensity) that may explicitly depend on time. More precisely, one where the rate function is allowed to change between the occurrence of jumps. For detailed examples and usage information see the\n\nTutorial\n\nFields\n\nrate\nFunction rate(u,p,t) that returns the jump's current rate.\naffect!\nFunction affect(integrator) that updates the state for one occurrence of the jump.\nidxs\nrootfind\ninterp_points\nsave_positions\nabstol\nreltol\n\nExamples\n\nSuppose u[1] gives the amount of particles and t*p[1] the probability per time each particle can decay away. A corresponding VariableRateJump for this jump process is\n\nrate(u,p,t) = t*p[1]*u[1]\naffect!(integrator) = integrator.u[1] -= 1\ncrj = VariableRateJump(rate, affect!)\n\nNotes\n\nVariableRateJumps result in integrators storing an effective state type that wraps the main state vector. See ExtendedJumpArray for details on using this object. Note that the presence of any VariableRateJumps will result in all ConstantRateJump, VariableRateJump and callback affect! functions receiving an integrator with integrator.u an ExtendedJumpArray.\nMust be used with ODEProblems or SDEProblems to be correctly simulated (i.e. can not currently be used with DiscreteProblems).\nSalis H., Kaznessis Y.,  Accurate hybrid stochastic simulation of a system of coupled chemical or biochemical reactions, Journal of Chemical Physics, 122 (5), DOI:10.1063/1.1835951 is used for calculating jump times with VariableRateJumps within ODE/SDE integrators.\n\n\n\n\n\n","category":"type"},{"location":"api/#DiffEqJump.JumpSet","page":"API","title":"DiffEqJump.JumpSet","text":"struct JumpSet{T1, T2, T3, T4} <: DiffEqJump.AbstractJump\n\nDefines a collection of jumps that should collectively be included in a simulation.\n\nFields\n\nvariable_jumps\nCollection of VariableRateJumps\nconstant_jumps\nCollection of ConstantRateJumps\nregular_jump\nCollection of RegularJumps\nmassaction_jump\nCollection of MassActionJumps\n\nExamples\n\nHere we construct two jumps, store them in a JumpSet, and then simulate the resulting process.\n\nusing DiffEqJump, OrdinaryDiffEq\n\nrate1(u,p,t) = p[1]\naffect1!(integrator) = (integrator.u[1] += 1)\ncrj = ConstantRateJump(rate1, affect1!)\n\nrate2(u,p,t) = (t/(1+t))*p[2]*u[1]\naffect2!(integrator) = (integrator.u[1] -= 1)\nvrj = VariableRateJump(rate2, affect2!)\n\njset = JumpSet(crj, vrj)\n\nf!(du,u,p,t) = (du .= 0)\nu0 = [0.0]\np = (20.0, 2.0)\ntspan = (0.0, 200.0)\noprob = ODEProblem(f!, u0, tspan, p)\njprob = JumpProblem(oprob, Direct(), jset)\nsol = solve(jprob, Tsit5())\n\n\n\n\n\n","category":"type"},{"location":"api/#Aggregators","page":"API","title":"Aggregators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Aggregators are the underlying algorithms used for sampling MassActionJumps and ConstantRateJumps.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Direct\nDirectCR\nFRM\nNRM\nRDirect\nRSSA\nRSSACR\nSortingDirect\nreset_aggregated_jumps!","category":"page"},{"location":"api/#DiffEqJump.Direct","page":"API","title":"DiffEqJump.Direct","text":"Gillespie's Direct method. ConstantRateJump rates and affects are stored in tuples. Fastest for a small (total) number of ConstantRateJumps or MassActionJumps (~10). For larger numbers of possible jumps use other methods.\n\nGillespie, Daniel T. (1976). A General Method for Numerically Simulating the Stochastic Time Evolution of Coupled Chemical Reactions. Journal of Computational Physics. 22 (4): 403–434. doi:10.1016/0021-9991(76)90041-3.\n\n\n\n\n\n","category":"type"},{"location":"api/#DiffEqJump.DirectCR","page":"API","title":"DiffEqJump.DirectCR","text":"The Composition-Rejection Direct method. Performs best relative to other methods for systems with large numbers of jumps with special structure (for example a linear chain of reactions, or jumps corresponding to particles hopping on a grid or graph).\n\nA. Slepoy, A.P. Thompson and S.J. Plimpton, A constant-time kinetic Monte Carlo algorithm for simulation of large biochemical reaction networks, Journal of Chemical Physics, 128 (20), 205101 (2008). doi:10.1063/1.2919546\nS. Mauch and M. Stalzer, Efficient formulations for exact stochastic simulation of chemical systems, ACM Transactions on Computational Biology and Bioinformatics, 8 (1), 27-35 (2010). doi:10.1109/TCBB.2009.47\n\n\n\n\n\n","category":"type"},{"location":"api/#DiffEqJump.FRM","page":"API","title":"DiffEqJump.FRM","text":"Gillespie's First Reaction Method. Should not be used for practical applications due to slow performance relative to all other methods.\n\nGillespie, Daniel T. (1976). A General Method for Numerically Simulating the Stochastic Time Evolution of Coupled Chemical Reactions. Journal of Computational Physics. 22 (4): 403–434. doi:10.1016/0021-9991(76)90041-3.\n\n\n\n\n\n","category":"type"},{"location":"api/#DiffEqJump.NRM","page":"API","title":"DiffEqJump.NRM","text":"The Next Reaction Method. Can significantly outperform Direct for systems with large numbers of jumps and sparse dependency graphs, but is usually slower than one of DirectCR, RSSA, or RSSACR for such systems.\n\nM. A. Gibson and J. Bruck, Efficient exact stochastic simulation of chemical systems with many species and many channels, Journal of Physical Chemistry A, 104 (9), 1876-1889 (2000). doi:10.1021/jp993732q\n\n\n\n\n\n","category":"type"},{"location":"api/#DiffEqJump.RDirect","page":"API","title":"DiffEqJump.RDirect","text":"A rejection-based direct method. \n\n\n\n\n\n","category":"type"},{"location":"api/#DiffEqJump.RSSA","page":"API","title":"DiffEqJump.RSSA","text":"The Rejection SSA method. One of the best methods for systems with hundreds to many thousands of jumps (along with RSSACR) and sparse dependency graphs.\n\nV. H. Thanh, C. Priami and R. Zunino, Efficient rejection-based simulation of biochemical reactions with stochastic noise and delays, Journal of Chemical Physics, 141 (13), 134116 (2014). doi:10.1063/1.4896985\nV. H. Thanh, R. Zunino and C. Priami, On the rejection-based algorithm for simulation and analysis of large-scale reaction networks, Journal of Chemical Physics, 142 (24), 244106 (2015). doi:10.1063/1.4922923\n\n\n\n\n\n","category":"type"},{"location":"api/#DiffEqJump.RSSACR","page":"API","title":"DiffEqJump.RSSACR","text":"The Rejection SSA Composition-Rejection method. Often the best performer for systems with tens of thousands of jumps and sparse depedency graphs.\n\nV. H. Thanh, R. Zunino, and C. Priami, Efficient Constant-Time Complexity Algorithm for Stochastic Simulation of Large Reaction Networks, IEEE/ACM Transactions on Computational Biology and Bioinformatics, Vol. 14, No. 3, 657-667 (2017).\n\n\n\n\n\n","category":"type"},{"location":"api/#DiffEqJump.SortingDirect","page":"API","title":"DiffEqJump.SortingDirect","text":"The Sorting Direct method. Often the fastest algorithm for smaller to moderate sized systems (tens of jumps), or systems where a few jumps occur much more frequently than others.\n\nJ. M. McCollum, G. D. Peterson, C. D. Cox, M. L. Simpson and N. F. Samatova, The   sorting direct method for stochastic simulation of biochemical systems with   varying reaction execution behavior, Computational Biology and Chemistry, 30   (1), 39049 (2006). doi:10.1016/j.compbiolchem.2005.10.007\n\n\n\n\n\n","category":"type"},{"location":"api/#Private-API-Functions","page":"API","title":"Private API Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ExtendedJumpArray\nSSAIntegrator","category":"page"},{"location":"api/#DiffEqJump.ExtendedJumpArray","page":"API","title":"DiffEqJump.ExtendedJumpArray","text":"struct ExtendedJumpArray{T3<:Number, T1, T<:AbstractArray{T3<:Number, T1}, T2} <: AbstractArray{T3<:Number, 1}\n\nExtended state definition used within integrators when there are VariableRateJumps in a system. For detailed examples and usage information see the\n\nTutorial\n\nFields\n\nu\nThe current state.\njump_u\nThe current rate (i.e. hazard, intensity, or propensity) values for the VariableRateJumps.\n\nExamples\n\nusing DiffEqJump, OrdinaryDiffEq\nf(du,u,p,t) = du .= 0\nrate(u,p,t) = (1+t)*u[1]*u[2]\n\n# suppose we wish to decrease each of the two variables by one\n# when a jump occurs\nfunction affect!(integrator)\n   # Method 1, direct indexing works like normal\n   integrator.u[1] -= 1\n   integrator.u[2] -= 1\n\n   # Method 2, if we want to broadcast or use array operations we need\n   # to access integrator.u.u which is the actual state object.\n   # So equivalently to above we could have said:\n   # integrator.u.u .-= 1\nend\n\nu0 = [10.0, 10.0]\nvrj = VariableRateJump(rate, affect!)\noprob = ODEProblem(f, u0, (0.0,2.0))\njprob = JumpProblem(oprob, Direct(), vrj)\nsol = solve(jprob,Tsit5())\n\nNotes\n\nIf ueja isa ExtendedJumpArray with ueja.u of size N and ueja.jump_u of size num_variableratejumps then\n# for 1 <= i <= N\nueja[i] == ueja.u[i]\n\n# for N < i <= (N+num_variableratejumps)\nueja[i] == ueja.jump_u[i]\nIn a system with VariableRateJumps all callback, ConstantRateJump, and VariableRateJump affect! functions will receive integrators with integrator.u an ExtendedJumpArray.\nAs such, affect! functions that wish to modify the state via vector operations should use ueja.u.u to obtain the aliased state object.\n\n\n\n\n\n","category":"type"},{"location":"api/#DiffEqJump.SSAIntegrator","page":"API","title":"DiffEqJump.SSAIntegrator","text":"mutable struct SSAIntegrator{F, uType, tType, tdirType, P, S, CB, SA, OPT, TS} <: SciMLBase.DEIntegrator{SSAStepper, Nothing, uType, tType}\n\nSolution objects for pure jump problems solved via SSAStepper.\n\nFields\n\nf\nThe underlying prob.f function. Not currently used.\nu\nThe current solution values.\nt\nThe current solution time.\ntprev\nThe previous time a jump occured.\ntdir\nThe direction time is changing in (must be positive indicating time is increasing)\np\nThe current parameters.\nsol\nThe current solution object.\ni\ntstop\nThe next jump time.\ncb\nThe jump aggregator callback.\nsaveat\nTimes to save the solution at.\nsave_everystep\nWhether to save everytime a jump occurs.\nsave_end\nWhether to save at the final step.\ncur_saveat\nIndex of the next saveat time.\nopts\nTuple storing callbacks.\ntstops\nUser supplied times to step to, useful with callbacks.\ntstops_idx\nu_modified\nkeep_stepping\n\n\n\n\n\n","category":"type"},{"location":"tutorials/simple_poisson_process/#poisson_proc_tutorial","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"","category":"section"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"In this tutorial we show how to simulate several Poisson jump processes, for several types of intensities and jump distributions. Readers interested primarily in chemical or population process models, where several types of jumps may occur, can skip directly to the second tutorial for a tutorial covering similar material but focused on the SIR model.","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"DiffEqJump allows the simulation of jump processes where the transition rate, i.e. intensity or propensity, can be a function of the current solution, current parameters, and current time. Throughout this tutorial these are denoted by u, p and t. Likewise, when a jump occurs any DifferentialEquations.jl-compatible change to the current system state, as encoded by a DifferentialEquations.jl integrator, is allowed. This includes changes to the current state or to parameter values.","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"This tutorial requires several packages, which can be added if not already installed via","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"using Pkg\nPkg.add(\"DiffEqJump\")\nPkg.add(\"Plots)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"Let's also load our packages and set some defaults for our plot formatting","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"using DiffEqJump, Plots\ndefault(; lw = 2)","category":"page"},{"location":"tutorials/simple_poisson_process/#ConstantRateJumps","page":"Simple Poisson Processes in DiffEqJump","title":"ConstantRateJumps","text":"","category":"section"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"Our first example will be to simulate a simple Poission counting process, N(t), with a constant transition rate of λ. We can interpret this as a birth process where new individuals are created at the constant rate λ. N(t) then gives the current population size. In terms of a unit Poisson counting process, Y_b(t), we have","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"N(t) = Y_bleft( lambda t right)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"(Here by a unit Poisson counting process we just mean a Poisson counting process with a constant rate of one.)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"In the remainder of this tutorial we will use transition rate, rate, propensity, and intensity interchangeably. Here is the full program listing we will subsequently explain line by line","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"using DiffEqJump, Plots\n\nrate(u,p,t) = p.λ\naffect!(integrator) = (integrator.u[1] += 1)\ncrj = ConstantRateJump(rate, affect!)\n\nu₀ = [0]\np = (λ = 2.0, )\ntspan = (0.0, 10.0)\n\ndprob = DiscreteProblem(u₀, tspan, p)\njprob = JumpProblem(dprob, Direct(), crj)\n\nsol = solve(jprob, SSAStepper())\nplot(sol, label=\"N(t)\", xlabel=\"t\", legend=:bottomright)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"We can define and simulate our jump process using DiffEqJump. We first load our packages","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"using DiffEqJump, Plots","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"To specify our jump process we need to define two functions. One that given the current state of the system, u, the parameters, p, and the time, t, can determine the current transition rate (intensity)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"rate(u,p,t) = p.λ","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"This corresponds to the instantaneous probability per time a jump occurs when the current state is u, current parameters are p, and the time is t. We also give a function that updates the system state when a jump is known to have occurred (at time integrator.t)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"affect!(integrator) = (integrator.u[1] += 1)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"Here the convention is to take a DifferentialEquations.jl integrator, and directly modify the current solution value it stores. i.e. integrator.u is the current solution vector, with integrator.u[1] the first component of this vector. In our case we will only have one unknown, so this will be the current value of the counting process. As our jump process's transition rate is constant between jumps, we can use a ConstantRateJump to encode it","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"crj = ConstantRateJump(rate, affect!)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"We then specify the parameters needed to simulate our jump process","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"# the initial condition vector, notice we make it an integer\n# since we have a discrete counting process\nu₀ = [0]\n\n# the parameters of the model, in this case a named tuple storing the rate, λ\np = (λ = 2.0, )\n\n# the time interval to solve over\ntspan = (0.0, 10.0)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"Finally, we construct the associated SciML problem types and generate one realization of the process. We first create a DiscreteProblem to encode that we are simulating a process that evolves in discrete time steps. Note, this currently requires that the process has constant transition rates between jumps","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"dprob = DiscreteProblem(u₀, tspan, p)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"We next create a JumpProblem that wraps the discrete problem, and specifies which algorithm to use for determining next jump times (and in the case of multiple possible jumps the next jump type). Here we use the classical Direct method, proposed by Gillespie in the chemical reaction context, but going back to earlier work by Doob and others (and also known as Kinetic Monte Carlo in the physics literature)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"# a jump problem, specifying we will use the Direct method to sample\n# jump times and events, and that our jump is encoded by crj\njprob = JumpProblem(dprob, Direct(), crj)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"We are finally ready to simulate one realization of our jump process","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"# now we simulate the jump process in time, using the SSAStepper time-stepper\nsol = solve(jprob, SSAStepper())\n\nplot(sol, label=\"N(t)\", xlabel=\"t\", legend=:bottomright)","category":"page"},{"location":"tutorials/simple_poisson_process/#More-general-ConstantRateJumps","page":"Simple Poisson Processes in DiffEqJump","title":"More general ConstantRateJumps","text":"","category":"section"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"The previous counting process could be interpreted as a birth process, where new individuals were created with a constant transition rate λ. Suppose we also allow individuals to be killed with a death rate of μ. The transition rate at time t for some individual to die, assuming the death of individuals are independent, is just mu N(t). Suppose we also wish to keep track of the number of deaths, D(t), that have occurred. We can store these as an auxiliary variable in u[2]. Our processes are then given mathematically by","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"beginalign*\nN(t) = Y_b(lambda t) - Y_d left(int_0^t mu N(s^-)  ds right) \nD(t) = Y_d left(int_0^t mu N(s^-)  ds right)\nendalign*","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"where Y_d(t) denotes a second, independent, unit Poisson counting process.","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"We can encode this as a second jump for our system like","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"deathrate(u,p,t) = p.μ * u[1]\ndeathaffect!(integrator) = (integrator.u[1] -= 1; integrator.u[2] += 1)\ndeathcrj = ConstantRateJump(deathrate, deathaffect!)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"As the death rate is constant between jumps we can encode this process as a second ConstantRateJump. We then construct the corresponding problems, passing both jumps to JumpProblem, and can solve as before","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"p = (λ = 2.0, μ = 1.5)\nu₀ = [0,0]   # (N(0), D(0))\ndprob = DiscreteProblem(u₀, tspan, p)\njprob = JumpProblem(dprob, Direct(), crj, deathcrj)\nsol = solve(jprob, SSAStepper())\nplot(sol, label=[\"N(t)\" \"D(t)\"], xlabel=\"t\", legend=:topleft)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"In the next tutorial we will also introduce MassActionJumps, which are a special type of ConstantRateJumps that require a more specialized form of transition rate and state update, but can offer better computational performance. They can encode any mass action reaction, as commonly arise in chemical and population process models, and essentially require that rate(u,p,t) be a monomial in the components of u and state changes be given by adding or subtracting a constant vector from u.","category":"page"},{"location":"tutorials/simple_poisson_process/#VariableRateJumps-for-processes-that-are-not-constant-between-jumps","page":"Simple Poisson Processes in DiffEqJump","title":"VariableRateJumps for processes that are not constant between jumps","text":"","category":"section"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"So far we have assumed that our jump processes have transition rates that are constant in between jumps. In many applications this may be a limiting assumption. To support such models DiffEqJump has the VariableRateJump type, which represents jump processes that have an arbitrary time dependence in the calculation of the transition rate, including transition rates that depend on states which can change in between ConstantRateJumps. Let's consider the previous example, but now let the birth rate be time dependent, b(t) = lambda left(sin(pi t  2) + 1right), so that our model becomes","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"beginalign*\nN(t) = Y_bleft(int_0^t left( lambda sinleft(tfracpi s2right) + 1 right)  d sright) - Y_d left(int_0^t mu N(s^-)  ds right) \nD(t) = Y_d left(int_0^t mu N(s^-)  ds right)\nendalign*","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"We'll then re-encode the first jump as a VariableRateJump","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"rate1(u,p,t) = p.λ * (sin(pi*t/2) + 1)\naffect1!(integrator) = (integrator.u[1] += 1)\nvrj = VariableRateJump(rate1, affect1!)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"Because this new jump can modify the value of u[1] between death events, and the death transition rate depends on this value, we must also update our death jump process to also be a VariableRateJump","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"deathvrj = VariableRateJump(deathrate, deathaffect!)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"Note, if the death rate only depended on values that were unchanged by a variable rate jump, then it could have remained a ConstantRateJump. This would have been the case if, for example, it depended on u[2] instead of u[1].","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"To simulate our jump process we now need to use a continuous problem type to properly handle determining the jump times. We do this by constructing an ordinary differential equation problem, ODEProblem, but setting the ODE derivative to preserve the state (i.e. to zero). We are essentially defining a combined ODE-jump process, i.e. a piecewise deterministic Markov process, but one where the ODE is trivial and does not change the state. To use this problem type and the ODE solvers we first load OrdinaryDiffEq.jl or DifferentialEquations.jl. If neither is installed, we first","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"using Pkg\nPkg.add(\"OrdinaryDiffEq\")\n# or Pkg.add(\"DifferentialEquations\")","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"and then load it via","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"using OrdinaryDiffEq\n# or using DifferentialEquations","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"We can then construct our ODE problem with a trivial ODE derivative component. Note, to work with the ODE solver time stepper we must change our initial condition to be floating point valued","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"function f!(du, u, p, t)\n    du .= 0\n    nothing\nend\nu₀ = [0.0, 0.0]\noprob = ODEProblem(f!, u₀, tspan, p)\njprob = JumpProblem(oprob, Direct(), vrj, deathvrj)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"We simulate our jump process, using the Tsit5 ODE solver as the time stepper in place of SSAStepper","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"sol = solve(jprob, Tsit5())\nplot(sol, label=[\"N(t)\" \"D(t)\"], xlabel=\"t\", legend=:topleft)","category":"page"},{"location":"tutorials/simple_poisson_process/#Having-a-Random-Jump-Distribution","page":"Simple Poisson Processes in DiffEqJump","title":"Having a Random Jump Distribution","text":"","category":"section"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"Suppose we want to simulate a compound Poisson process, G(t), where","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"G(t) = sum_i=1^N(t) C_i","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"with N(t) a Poisson counting process with constant transition rate lambda, and the C_i independent and identical samples from a uniform distribution over -11. We can simulate such a process as follows.","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"We first ensure that we use the same random number generator as DiffEqJump. We can either pass one as an input to JumpProblem via the rng keyword argument, and make sure it is the same one we use in our affect! function, or we can just use the default generator chosen by DiffEqJump if one is not specified, DiffEqJump.DEFAULT_RNG. Let's do the latter","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"rng = DiffEqJump.DEFAULT_RNG","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"Let's assume u[1] is N(t) and u[2] is G(t). We now proceed as in the previous examples","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in DiffEqJump","title":"Simple Poisson Processes in DiffEqJump","text":"rate3(u,p,t) = p.λ\n\n# define the affect function via a closure\naffect3! = integrator -> let rng=rng\n    # N(t) <-- N(t) + 1\n    integrator.u[1] += 1\n\n    # G(t) <-- G(t) + C_{N(t)}\n    integrator.u[2] += rand(rng, (-1,1))\n    nothing\nend\ncrj = ConstantRateJump(rate3, affect3!)\n\nu₀ = [0, 0]\np = (λ = 1.0,)\ntspan = (0.0, 100.0)\ndprob = DiscreteProblem(u₀, tspan, p)\njprob = JumpProblem(dprob, Direct(), crj)\nsol = solve(jprob, SSAStepper())\nplot(sol, label=[\"N(t)\" \"G(t)\"], xlabel=\"t\")","category":"page"},{"location":"tutorials/discrete_stochastic_example/#ssa_tutorial","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"In this tutorial we will describe how to define and simulate continuous-time jump processes, also known in biological fields as stochastic chemical kinetics (i.e. Gillespie) models. It is not necessary to have read the first tutorial. We will illustrate","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"The different types of jumps that can be represented in DiffEqJump and their use cases.\nHow to speed up pure-jump simulations with only ConstantRateJumps and MassActionJumps by using the SSAStepper time stepper.\nHow to define and use MassActionJumps, a more specialized type of ConstantRateJump that offers improved computational performance.\nHow to use saving controls to reduce memory use per simulation.\nHow to use VariableRateJumps and when they should be preferred over ConstantRateJumps and MassActionJumps.\nHow to create hybrid problems mixing the various jump types with ODEs or SDEs.\nHow to use RegularJumps to enable faster, but approximate, time stepping via τ-leaping methods.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"note: Note\nThis tutorial assumes you have read the Ordinary Differential Equations tutorial in DifferentialEquations.jl.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We begin by demonstrating how to build jump processes using DiffEqJump.jl's different jump types, which encode the rate functions (i.e. transition rates, intensities, or propensities) and state changes when a given jump occurs.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note, the SIR model considered here is a type of stochastic chemical kinetics jump process model, and as such the biological modeling functionality of Catalyst.jl can be used to easily specify the model and automatically calculate inputs needed for DiffEqJump's optimized simulation algorithms. We summarize this alternative approach at the beginning for users who may be interested in modeling chemical systems, but note this tutorial is intended to explain the general jump process formulation of DiffEqJump for all users. However, for those users constructing models that can be represented as a collection of chemical reactions we strongly recommend using Catalyst, which should ensure optimal jump types are selected to represent each reaction, and necessary data structures for the simulation algorithms, such as dependency graphs, are automatically calculated.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We'll make use of the DifferentialEquations.jl meta package, which includes DiffEqJump and ODE/SDE solvers, Plots.jl, and (optionally) Catalyst.jl in this tutorial. If not already installed they can be added as follows","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using Pkg\nPkg.add(\"DifferentialEquations\")\nPkg.add(\"Plots\")\nPkg.add(\"Catalyst)                # optional","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Let's now load the required packages and set some default plot settings","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using DifferentialEquations, Plots, LinearAlgebra\ndefault(; lw = 2)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using DifferentialEquations, Plots, LinearAlgebra\ndefault(; lw = 2)","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Illustrative-Model:-SIR-Disease-Dynamics","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Illustrative Model: SIR Disease Dynamics","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"To illustrate the jump process solvers, we will build an SIR model which matches the tutorial from Gillespie.jl. SIR stands for susceptible, infected, and recovered, and is a model of disease spread. When a susceptible person comes in contact with an infected person, the disease has a chance of infecting the susceptible person. This \"chance\" is determined by the number of susceptible persons and the number of infected persons, since in larger populations there is a greater chance that two people come into contact. Every infected person will in turn have a rate at which they recover. In our model we'll assume there are no births or deaths, and a recovered individual is protected from reinfection.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We'll begin by giving the mathematical equations for the jump processes of the number of susceptible (S(t)), number of infected (I(t)), and number of recovered (R(t)). In the next section we give a more intuitive and biological description of the model for users that are less familiar with jump processes. Let Y_i(t), i = 12, denote independent unit Poisson processes. Our basic mathematical model for the evolution of (S(t)I(t)R(t)), written using Kurtz's time-change representation, is then","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginaligned\nS(t) = S(0) - Y_1left(  int_0^t beta S(s^-) I(s^-)  dsright) \nI(t) = I(0) + Y_1left(  int_0^t beta S(s^-) I(s^-)  dsright)\n        - Y_2 left( int_0^t nu I(s^-)   ds right) \nR(t) = R(0) + Y_2 left( int_0^t nu I(s^-)   ds right)\nendaligned","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice, our model involves two jump processes with rate functions, also known as intensities or propensities, given by beta S(t) I(t) and nu I(t) respectively. These give the probability per time a new infected individual is created, and the probability per time some infected individual recovers.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"For those less-familiar with the time-change representation, we next give a more intuitive explanation of the model as a collection of chemical reactions, and then demonstrate how these reactions can be written in Catalyst.jl and seamlessly converted into a form that can be used with the DiffEqJump.jl solvers. Users interested in how to directly define jumps using the lower-level DiffEqJump interface can skip to Building and Simulating the Jump Process Using the DiffEqJump Low-Level Interface.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Specifying-the-SIR-Model-with-Chemical-Reactions","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Specifying the SIR Model with Chemical Reactions","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"The SIR model described above involves two basic chemical reactions,","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginaligned\nS + I oversetbetato 2 I \nI oversetnuto R\nendaligned","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"where beta and nu are the rate constants of the reactions (with units of probability per time). In a jump process (stochastic chemical kinetics) model, we keep track of the non-negative integer number of each species at each time (i.e. (S(t) I(t) R(t)) above). Each reaction has an associated rate function (i.e. intensity or propensity) giving the probability per time it can occur when the system is in state (S(t)I(t)R(t)):","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginmatrix\ntextReaction  textRate Functions \nhline\nS + I oversetbetato 2 I  beta S(t) I(t) \nI oversetnuto R  nu I(t)\nendmatrix","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beta is determined by factors like the type of the disease. It can be interpreted as the probability per time one pair of susceptible and infected people encounter each other, with the susceptible person becoming sick. The overall rate (i.e. probability per time) that some susceptible person gets sick is then given by the rate constant multiplied by the number of possible pairs of susceptible and infected people. This formulation is known as the law of mass action. Similarly, we have that each individual infected person is assumed to recover with probability per time nu, so that the probability per time some infected person becomes recovered is nu times the number of infected people, i.e. nu I(t).","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Rate functions give the probability per time for each of the two types of jumps to occur, and hence determine when the state of our system changes. To fully specify our model we also need to specify how the state changes when a jump occurs, giving what are called affect! functions in DiffEqJump. For example, when the S + I to 2 I reaction occurs and some susceptible person becomes infected, the subsequent (instantaneous) state change is that","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginaligned\nS to S - 1  I to I + 1\nendaligned","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Likewise, when the I to R reaction occurs so that some infected person becomes recovered the state change is","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginaligned\nI to I - 1  R to R + 1\nendaligned","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"In summary, our model is described by two chemical reactions, which each in turn correspond to a jump process determined by a rate function specifying how frequently jumps should occur, and an affect! function for how the state should change when that jump type occurs.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Building-and-Simulating-the-Jump-Processes-from-Catalyst-Models","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Building and Simulating the Jump Processes from Catalyst Models","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Using Catalyst.jl we can input our full reaction network in a form that can be easily used with DiffEqJump's solvers","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using Catalyst\nsir_model = @reaction_network begin\n    β, S + I --> 2I\n    ν, I --> R\nend β ν","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"To build a pure jump process model of the reaction system, where the state is  constant between jumps, we will use a DiscreteProblem. This encodes that the state only changes at the jump times. We do this by giving the constructor u₀, the initial condition, and tspan, the timespan. Here, we will start with 999 susceptible people, 1 infected person, and 0 recovered people, and solve the problem from t=0.0 to t=250.0. We use the parameters β = 0.1/1000 and ν = 0.01. Thus we build the problem via:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"p     = (:β => 0.1/1000, :ν => 0.01)\nu₀    = [:S => 999, :I => 10, :R => 0]\ntspan = (0.0, 250.0)\nprob  = DiscreteProblem(sir_model, u₀, tspan, p)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice, the initial populations are integers since we want the exact number of people in the different states.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"The Catalyst reaction network can be converted into various DifferentialEquations.jl problem types, including JumpProblems, ODEProblems, or SDEProblems. To turn it into a JumpProblem representing the SIR jump process model, we simply write","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump_prob = JumpProblem(sir_model, prob, Direct())","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Here Direct() indicates that we will determine the random times and types of reactions using Gillespie's Direct stochastic simulation algorithm (SSA), also known as Doob's method or Kinetic Monte Carlo. See Constant Rate Jump Aggregators for other supported SSAs.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We now have a problem that can be evolved in time using the DiffEqJump solvers. Since our model is a pure jump process (no continuously-varying components), we will use SSAStepper() to handle time-stepping the Direct method from jump to jump:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"sol = solve(jump_prob, SSAStepper())","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"This solve command takes the standard commands of the common interface, and the solution object acts just like any other differential equation solution. Thus there exists a plot recipe, which we can plot with:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"plot(sol)","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Building-and-Simulating-the-Jump-Process-Using-the-DiffEqJump-Low-Level-Interface","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Building and Simulating the Jump Process Using the DiffEqJump Low-Level Interface","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We now show how to directly use DiffEqJump's low-level interface to construct and solve our jump process model for (S(t)I(t)R(t)). Each individual jump that can occur is represented through specifying two pieces of information; a rate function (i.e. intensity or propensity) for the jump and an affect! function for the jump. The former gives the probability per time a particular jump can occur given the current state of the system, and hence determines the time at which jumps can happen. The later specifies the instantaneous change in the state of the system when the jump occurs.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"In our SIR model we have two possible jumps that can occur (one for susceptibles becoming infected and one for infected becoming recovered), with the corresponding (mathematical) rates and affects given by","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginmatrix\ntextRates  textAffects\nhline\nbeta S(t) I(t)  S to S - 1 I to I + 1 \nnu I(t)  I to I - 1  R to R + 1\nendmatrix","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"DiffEqJump offers three different ways to (exactly) represent jumps: MassActionJump, ConstantRateJump, and VariableRateJump. Choosing which to use is a trade off between the desired generality of the rate and affect! functions vs. the computational performance of the resulting simulated system. In general","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Jump Type Performance Generality\nMassActionJump Fastest Restrictive rates/affects\nConstantRateJump Somewhat Slower Much more general\nVariableRateJump Slowest Completely general","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"It is recommended to try to encode jumps using the most performant option that supports the desired generality of the underlying rate and affect functions. Below we describe the different jump types, and show how the SIR model can be formulated using first ConstantRateJumps and then MassActionJumps (VariableRateJumps are considered later).","category":"page"},{"location":"tutorials/discrete_stochastic_example/#ConstantRateJumpSect","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Defining the Jumps Directly: ConstantRateJump","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"The constructor for a ConstantRateJump is:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump = ConstantRateJump(rate, affect!)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"where rate is a function rate(u,p,t) and affect! is a function of the integrator affect!(integrator) (for details on the integrator, see the integrator interface docs). Here u corresponds to the current state vector of the system; for our SIR model u[1] = S(t), u[2] = I(t) and u[3] = R(t). p corresponds to the parameters of the model, just as used for passing parameters to derivative functions in ODE solvers. Thus, to define the two possible jumps for our model we take (with β = .1/1000.0 and ν = .01).","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"β = 0.1 / 1000.0\nν = .01;\np = (β, ν)\nrate1(u, p, t) = p[1] * u[1] * u[2]  # β*S*I\nfunction affect1!(integrator)\n  integrator.u[1] -= 1         # S -> S - 1\n  integrator.u[2] += 1         # I -> I + 1\n  nothing\nend\njump = ConstantRateJump(rate1,affect1!)\n\nrate2(u, p, t) = p[2] * u[2]         # ν*I\nfunction affect2!(integrator)\n  integrator.u[2] -= 1        # I -> I - 1\n  integrator.u[3] += 1        # R -> R + 1\n  nothing\nend\njump2 = ConstantRateJump(rate2,affect2!)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We will start with 999 susceptible people, 1 infected person, and 0 recovered people, and solve the problem from t=0.0 to t=250.0 so that","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"u₀    = [999, 10, 0]\ntspan = (0.0, 250.0)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice, the initial populations are integers since we want the exact number of people in the different states.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Since we want the system state to change only at the discrete jump times, we will build a DiscreteProblem","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"prob = DiscreteProblem(u₀, tspan, p)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We can then use JumpProblem from DiffEqJump to augment the discrete problem with jumps and select the stochastic simulation algorithm (SSA) to use in sampling the jump processes. To create a JumpProblem we would simply do:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump_prob = JumpProblem(prob, Direct(), jump, jump2)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Here Direct() indicates that we will determine the random times and types of jumps that occur using Gillespie's Direct stochastic simulation algorithm (SSA), also known as Doob's method or Kinetic Monte Carlo. See Constant Rate Jump Aggregators for other supported SSAs.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We now have a problem that can be evolved in time using the DiffEqJump solvers. Since our model is a pure jump process with all rates being constant in between jumps (i.e. no continuously-varying components), we will use SSAStepper to handle time-stepping the Direct method from jump to jump:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"sol = solve(jump_prob, SSAStepper())","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"This solve command takes the standard commands of the common interface, and the solution object acts just like any other differential equation solution. Thus there exists a plot recipe, which we can plot with:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"plot(sol, label=[\"S(t)\" \"I(t)\" \"R(t)\"])","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note, in systems with more than a few jumps (more than ~10), it can be advantageous to use more sophisticated SSAs than Direct. For such systems it is recommended to use SortingDirect, RSSA or RSSACR, see the list of DiffEqJump SSAs at Constant Rate Jump Aggregators.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#*Caution-about-Constant-Rate-Jumps*","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Caution about Constant Rate Jumps","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"ConstantRateJumps are quite general, but they do have one restriction. They assume that the rate functions are constant at all times between two consecutive jumps of the system. i.e. any species/states or parameters that the rate function depends on must not change between the times at which two consecutive jumps occur. Such conditions are violated if one has a time dependent parameter like beta(t) or if some of the solution components, say u[2], may also evolve through a coupled ODE, SDE, or a VariableRateJump (see below for examples). For problems where the rate function may change between consecutive jumps, VariableRateJumps must be used.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Thus in the examples above,","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"rate1(u,p,t) = p[1]*u[1]*u[2]\nrate2(u,p,t) = p[2]*u[2]","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"both must be constant other than changes due to some other ConstantRateJump or MassActionJump (the same restriction applies to MassActionJumps). Since these rates only change when u[1] or u[2] is changed, and u[1] and u[2] only change when one of the jumps occur, this setup is valid. However, a rate of t*p[1]*u[1]*u[2] would not be valid because the rate would change during the interval, as would p[2]*u[1]*u[4] when u[4] is the solution to a continuous problem such as an ODE or SDE or can be changed via a VariableRateJump. Thus one must be careful to follow this rule when choosing rates.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"In summary, if a particular jump process has a rate function that depends explicitly or implicitly on a continuously changing quantity, you need to use a VariableRateJump.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#SSAStepper","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"SSAStepper","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Any common interface algorithm can be used to perform the time-stepping since it is implemented over the callback interface. This allows for hybrid systems that mix ODEs, SDEs and jumps. In many cases we may have a pure jump system that only involves ConstantRateJumps and/or MassActionJumps (see below). When that's the case, a substantial performance benefit may be gained by using SSAStepper. Note, SSAStepper is a more limited time-stepper which only supports discrete events, and does not allow simultaneous coupled ODEs or SDEs or VariableRateJumps. It is, however, very efficient for pure jump problems involving only ConstantRateJumps and MassActionJumps.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#save_positions_docs","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Reducing Memory Use: Controlling Saving Behavior","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note that jumps act via DifferentialEquations.jl's callback interface, which defaults to saving at each event. This is required in order to accurately resolve every discontinuity exactly (and this is what allows for perfectly vertical lines in plots!). However, in many cases when using jump problems you may wish to decrease the saving pressure given by large numbers of jumps. To do this, you set the save_positions keyword argument to JumpProblem. Just like for other callbacks, this is a tuple (bool1, bool2) which sets whether to save before or after a jump. If we do not want to save at every jump, we would thus pass:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump_prob = JumpProblem(prob, Direct(), jump, jump2; save_positions = (false, false))","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Now the saving controls associated with the integrator should specified, see the main SciML Docs for saving options. For example, we can use saveat = 10.0 to save at an evenly spaced grid:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"sol = solve(jump_prob, SSAStepper(); saveat = 10.0)\n\n# we plot each solution component separately since\n# the graph should no longer be a step function\nplot(sol.t, sol[1,:]; marker = :o, label=\"S(t)\", xlabel=\"t\")\nplot!(sol.t, sol[2,:]; marker = :x, label=\"I(t)\", xlabel=\"t\")\nplot!(sol.t, sol[3,:]; marker = :d, label=\"R(t)\", xlabel=\"t\")","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice that our plot (and solutions) are now defined at precisely the specified time points. It is important to note that interpolation of the solution object will no longer be exact for a pure jump process, as the solution values at jump times have not been stored. i.e for t a time we did not save at sol(t) will no longer give the exact value of the solution at t.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#MassActionJumpSect","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Defining the Jumps Directly: MassActionJump","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"For ConstantRateJumps that can be represented as mass action reactions a further specialization of the jump type is possible that offers improved computational performance; MassActionJump. Suppose the system has N chemical species S_1dotsS_N. A general mass action reaction has the form","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"R_1 S_1 + R_2 S_2 + dots + R_N S_N oversetkrightarrow P_1 S_1 + P_2 S_2 + dots + P_N S_N","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"where the non-negative integers (R_1dotsR_N) denote the reactant stoichiometry of the reaction, and the non-negative integers (P_1dotsP_N) the product stoichiometry. The net stoichiometry is the net change in each chemical species from the reaction occurring one time, given by mathbfnu = (P_1-R_1dotsP_N-R_N). As such, the affect! function associated with a MassActionJump simply changes the state, mathbfu(t) = (u_1(t)dotsu_N(t)), by updating","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"mathbfu(t) to mathbfu(t) + mathbfnu","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"The default rate function, ρ = rate(u,p,t), is based on stochastic chemical kinetics and given by","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"ρ(mathbfu(t)) = k prod_i=1^N beginpmatrix u_i  R_i endpmatrix\n= k prod_i=1^N fracu_iR_i (u_i - R_i)\n= k prod_i=1^N fracu_i (u_i - 1) cdots (u_i - R_i + 1)R_i","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"where k denotes the rate constant of the reaction (in units of per time).","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"As an example, consider again the SIR model. The species are u = (S,I,R). The first reaction has rate β, reactant stoichiometry (1, 1, 0), product stoichiometry (0, 2, 0), and net stoichiometry (-1, 1, 0). The second reaction has rate ν, reactant stoichiometry (0, 1, 0), product stoichiometry (0, 0, 1), and net stoichiometry (0, -1, 1).","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We can manually encode this system as a mass action jump by specifying the indexes of the rate constants in p, the reactant stoichiometry, and the net stoichiometry. We note that the first two determine the rate function, with the latter determining the affect function.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"rateidxs = [1, 2]           # i.e. [β, ν]\nreactant_stoich =\n[\n  [1 => 1, 2 => 1],         # 1*S and 1*I\n  [2 => 1]                  # 1*I\n]\nnet_stoich =\n[\n  [1 => -1, 2 => 1],        # -1*S and 1*I\n  [2 => -1, 3 => 1]         # -1*I and 1*R\n]\nmass_act_jump = MassActionJump(reactant_stoich, net_stoich; param_idxs=rateidxs)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice, one typically should define one MassActionJump that encodes each possible jump that can be represented via a mass action reaction. This is in contrast to ConstantRateJumps or VariableRateJumps where separate instances are created for each distinct jump type.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Just like for ConstantRateJumps, to then simulate the system we create a JumpProblem and call solve:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump_prob = JumpProblem(prob, Direct(), mass_act_jump)\nsol = solve(jump_prob, SSAStepper())\nplot(sol; label=[\"S(t)\" \"I(t)\" \"R(t)\"])","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"For more details about MassActionJumps see Defining a Mass Action Jump. We note that one could include the factors of 1  R_i directly in the rate constant passed into a MassActionJump, so that the desired rate function that gets evaluated is","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"hatk prod_i=1^N u_i (u_i - 1) cdots (u_i - R_i + 1)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"with hatk = k  prod_i=1^N R_i the renormalized rate constant. Passing the keyword argument scale_rates = false will disable MassActionJumps internally rescaling the rate constant by \\prod_{i=1}^{N} R_i!.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"For chemical reaction systems Catalyst.jl automatically groups reactions into their optimal jump representation.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Defining-the-Jumps-Directly:-Mixing-ConstantRateJump-and-MassActionJump","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Defining the Jumps Directly: Mixing ConstantRateJump and MassActionJump","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Suppose we now want to add in to the SIR model another jump that can not be represented as a mass action reaction. We can create a new ConstantRateJump and simulate a hybrid system using both the MassActionJump for the two previous reactions, and the new ConstantRateJump. Let's suppose we want to let susceptible people be born with the following jump rate:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"birth_rate(u,p,t) = 10.0 * u[1] / (200.0 + u[1]) + 10.0\nfunction birth_affect!(integrator)\n  integrator.u[1] += 1\n  nothing\nend\nbirth_jump = ConstantRateJump(birth_rate, birth_affect!)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We can then simulate the hybrid system as","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump_prob = JumpProblem(prob, Direct(), mass_act_jump, birth_jump)\nsol = solve(jump_prob, SSAStepper())\nplot(sol; label=[\"S(t)\" \"I(t)\" \"R(t)\"])","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Adding-Jumps-to-a-Differential-Equation","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Adding Jumps to a Differential Equation","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"If we instead used some form of differential equation instead of a DiscreteProblem, we would couple the jumps/reactions to the differential equation. Let's define an ODE problem, where the continuous part only acts on some new 4th component:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using OrdinaryDiffEq\nfunction f(du, u, p, t)\n  du[4] = u[2]*u[3]/100000 - u[1]*u[4]/100000\n  nothing\nend\nu₀   = [999.0, 10.0, 0.0, 100.0]\nprob = ODEProblem(f, u₀, tspan, p)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice we gave the 4th component a starting value of 100.0, and used floating point numbers for the initial condition since some solution components now evolve continuously. The same steps as above will allow us to solve this hybrid equation when using ConstantRateJumps (or MassActionJumps). For example, we can solve it using the Tsit5() method via:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump_prob = JumpProblem(prob, Direct(), jump, jump2)\nsol = solve(jump_prob, Tsit5())\nplot(sol; label=[\"S(t)\" \"I(t)\" \"R(t)\" \"u₄(t)\"])","category":"page"},{"location":"tutorials/discrete_stochastic_example/#VariableRateJumpSect","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Adding a VariableRateJump","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Now let's consider adding a reaction whose rate changes continuously with the differential equation. To continue our example, let there be a new reaction with rate depending on u[4] of the form u_4 to u_4 + textrmI, with a rate constant of 1e-2:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"rate3(u, p, t) = 1e-2 * u[4]\nfunction affect3!(integrator)\n  integrator.u[2] += 1    # I -> I + 1\n  nothing\nend\njump3 = VariableRateJump(rate3, affect3!)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice, since rate3 depends on a variable that evolves continuously, and hence is not constant between jumps, we must use a VariableRateJump.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Solving the equation is exactly the same:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"u₀   = [999.0, 10.0, 0.0, 1.0]\nprob = ODEProblem(f, u₀, tspan, p)\njump_prob = JumpProblem(prob, Direct(), jump, jump2, jump3)\nsol = solve(jump_prob, Tsit5())\nplot(sol; label=[\"S(t)\" \"I(t)\" \"R(t)\" \"u₄(t)\"])","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note that VariableRateJumps require using a continuous problem, like an ODE/SDE/DDE/DAE problem, and using floating point initial conditions.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Lastly, we are not restricted to ODEs. For example, we can solve the same jump problem except with multiplicative noise on u[4] by using an SDEProblem instead:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using StochasticDiffEq\nfunction g(du, u, p, t)\n  du[4] = 0.1u[4]\nend\nprob = SDEProblem(f, g, [999.0, 1.0, 0.0, 1.0], (0.0, 250.0), p)\njump_prob = JumpProblem(prob, Direct(), jump, jump2, jump3)\nsol = solve(jump_prob, SRIW1())\nplot(sol; label=[\"S(t)\" \"I(t)\" \"R(t)\" \"u₄(t)\"])","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"For more details about VariableRateJumps see Defining a Variable Rate Jump.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#RegularJumps-and-τ-Leaping","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"RegularJumps and τ-Leaping","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"The previous parts described how to use ConstantRateJumps, MassActionJumps, and VariableRateJumps, however, in many cases one does not require the exactness of stepping to every jump time. Instead, regular jumping (i.e. τ-leaping) allows pooling jumps together, and performing larger updates in a statistically-correct but more efficient manner. The trade-off is the introduction of a time-discretization error due to the time-stepping, but one that is controlled and convergent as the time-step is reduced to zero.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Let's see how to define the SIR model in terms of a RegularJump. We need two functions, rate and change!. rate is a vector equation which computes the rates of each jump process","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"function rate(out, u, p, t)\n    out[1] = p[1] * u[1] * u[2]   # β * S * I\n    out[2] = p[2] * u[2]          # ν * I\n    nothing\nend","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We then define a function that given a vector storing the number of times each jump occurs during a time-step, counts, calculates the change in the state, du. For the SIR example we do this by multiplying counts by a matrix that encodes the change in the state due to one occurrence of each reaction (i.e. the net stoichiometry matrix). Below c[i,j] gives the change in u[i] due to the jth jump:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"c = zeros(3, 2)\n# S + I --> I\nc[1,1] = -1    # S -> S - 1\nc[2,1] = 1     # I -> I + 1\n\n# I --> R\nc[2,2] = -1    # I -> I - 1\nc[3,2] = 1     # R -> R + 1\n\nfunction change(du, u, p, t, counts, mark)\n  mul!(du, c, counts)\n  nothing\nend","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We are now ready to create our RegularJump, passing in the rate function, change function, and the number of jumps being encoded","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"rj = RegularJump(rate, change, 2)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"From there we build a JumpProblem","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"u₀ = [1000.0, 50.0, 0.0]\nprob = DiscreteProblem(u₀, tspan, p)\njump_prob = JumpProblem(prob, Direct(), rj)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note that when a JumpProblem has a RegularJump, τ-leaping algorithms are required for simulating it. This is detailed on the jump solvers page. One such algorithm is TauLeaping from StochasticDiffEq.jl, which we use as follows:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"sol = solve(jump_prob, TauLeaping(); dt=.001)\nplot(sol; label=[\"S(t)\" \"I(t)\" \"R(t)\"])","category":"page"},{"location":"tutorials/jump_diffusion/#jump_diffusion_tutorial","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"","category":"section"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"note: Note\nThis tutorial assumes you have read the Ordinary Differential Equations tutorial in DifferentialEquations.jl.","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Jump Diffusion equations are stochastic differential equations with discontinuous jumps. These can be written as:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"du = f(upt)dt + sum_jg_j(upt)dW_j(t) + sum_ih_i(upt)dN_i(t)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"where N_i is a Poisson-counter which denotes jumps of size h_i. In this tutorial we will show how to solve problems with even more general jumps. In the special case that g_j = 0 for all j, we'll call the resulting jump-ODE a piecewise deterministic Markov process.","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Before running this tutorial please install the following packages if they are not already installed","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"using Pkg\nPkg.add(\"DifferentialEquations\")\nPkg.add(\"Plots\")","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"DifferentialEquations.jl will install DiffEqJump, along with the needed ODE and SDE solvers.","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"We then load these packages, and set some plotting defaults, as","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"using DifferentialEquations, Plots\ndefault(; lw = 2)","category":"page"},{"location":"tutorials/jump_diffusion/#Defining-a-ConstantRateJump-Problem","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Defining a ConstantRateJump Problem","text":"","category":"section"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"To start, let's solve an ODE that is coupled to a ConstantRateJump. A jump is defined as being \"constant rate\" if the rate is only dependent on values from other ConstantRateJumps or MassActionJumps (a special type of ConstantRateJump). This means that its rate must not be coupled with time, the solution to the differential equation, or a solution component that is changed by a VariableRateJump. ConstantRateJumps are cheaper to compute than VariableRateJumps, and so should be preferred when mathematically appropriate.","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"(Note: if your rate is only \"slightly\" dependent on the solution of the differential equation, then it may be okay to use a ConstantRateJump. Accuracy loss will be related to the percentage that the rate changes over the jump intervals.)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Let's solve the following problem. We will have a linear ODE with a Poisson counter of rate 2 (which is the mean and variance), where at each jump the current solution will be halved. To solve this problem, we first define the ODEProblem:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"function f(du,u,p,t)\n    du[1] = u[1]\n    nothing\nend\n\nprob = ODEProblem(f, [0.2], (0.0, 10.0))","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Notice that, even though our equation is scalar, we define it using the in-place array form. Variable rate jump equations will require this form. Note that for this tutorial we solve a one-dimensional problem, but the same syntax applies for solving a system of differential equations with multiple jumps.","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Now we define our rate equation for our jump. Since it's just the constant value 2, we do:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"rate(u, p, t) = 2","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Now we define the affect! of the jump. This is the same as an affect! from a DiscreteCallback, and thus acts directly on the integrator. Therefore, to make it halve the current value of u, we do:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"function affect!(integrator)\n    integrator.u[1] = integrator.u[1] / 2\n    nothing\nend","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Then we build our jump:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"jump = ConstantRateJump(rate, affect!)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Next, we extend our ODEProblem to a JumpProblem by attaching the jump:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"jump_prob = JumpProblem(prob, Direct(), jump)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"We can now solve this extended problem using any ODE solver:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"sol = solve(jump_prob, Tsit5())\nplot(sol)","category":"page"},{"location":"tutorials/jump_diffusion/#Variable-Rate-Jumps","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Variable Rate Jumps","text":"","category":"section"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Now let's define a jump with a rate that is dependent on the differential equation via the solution vector. Let's set the rate to be the current value of the solution, that is:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"rate(u,p,t) = u[1]","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Using the same affect! we build a VariableRateJump:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"jump = VariableRateJump(rate, affect!)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"To make things interesting, let's copy this jump:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"jump2 = deepcopy(jump)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"so that way we have two independent jump processes. We now couple these jumps to the ODEProblem:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"jump_prob = JumpProblem(prob, Direct(), jump, jump2)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"which we once again solve using an ODE solver:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"sol = solve(jump_prob, Tsit5())\nplot(sol)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"In this way we have solve a mixed jump-ODE, i.e. a piecewise deterministic Markov process.","category":"page"},{"location":"tutorials/jump_diffusion/#Jump-Diffusion","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Jump Diffusion","text":"","category":"section"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Now we will finally solve the jump diffusion problem. The steps are the same as before, except we now start with a SDEProblem instead of an ODEProblem. Using the same drift function f as before, we add multiplicative noise via:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"function g(du, u, p, t)\n  du[1] = u[1]\n  nothing\nend\n\nprob = SDEProblem(f, g, [0.2], (0.0, 10.0))","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"and couple it to the jumps:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"jump_prob = JumpProblem(prob, Direct(), jump, jump2)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"We then solve it using an SDE algorithm:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"sol = solve(jump_prob, SRIW1())\nplot(sol)","category":"page"},{"location":"jump_types/#jump_problem_type","page":"Jump types and JumpProblem","title":"Jump Problems","text":"","category":"section"},{"location":"jump_types/#Mathematical-Specification-of-an-problem-with-jumps","page":"Jump types and JumpProblem","title":"Mathematical Specification of an problem with jumps","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Jumps are defined as a Poisson process which changes states at some rate. When there are multiple possible jumps, the process is a compound Poisson process. On its own, a jump equation is a continuous-time Markov Chain where the time to the next jump is exponentially distributed as calculated by the rate. This type of process, known in biology as \"Gillespie discrete stochastic simulations\" and modeled by the Chemical Master Equation (CME), is the same thing as adding jumps to a DiscreteProblem. However, any differential equation can be extended by jumps as well. For example, we have an ODE with jumps, denoted by","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"fracdudt = f(upt) + sum_ic_i(upt)p_i(t)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"where p_i is a Poisson counter of rate lambda_i(upt). Extending a stochastic differential equation to have jumps is commonly known as a Jump Diffusion, and is denoted by","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"du = f(upt)dt + sum_jg_j(ut)dW_j(t) + sum_ic_i(upt)dp_i(t)","category":"page"},{"location":"jump_types/#Types-of-Jumps:-Regular,-Variable,-Constant-Rate-and-Mass-Action","page":"Jump types and JumpProblem","title":"Types of Jumps: Regular, Variable, Constant Rate and Mass Action","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"A RegularJump is a set of jumps that do not make structural changes to the underlying equation. These kinds of jumps only change values of the dependent variable (u) and thus can be treated in an inexact manner. Other jumps, such as those which change the size of u, require exact handling which is also known as time-adaptive jumping. These can only be specified as a ConstantRateJump, MassActionJump, or a VariableRateJump.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"We denote a jump as variable rate if its rate function is dependent on values which may change between constant rate jumps. For example, if there are multiple jumps whose rates only change when one of them occur, than that set of jumps is a constant rate jump. If a jump's rate depends on the differential equation, time, or by some value which changes outside of any constant rate jump, then it is denoted as variable.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"A MassActionJump is a specialized representation for a collection of constant rate jumps that can each be interpreted as a standard mass action reaction. For systems comprised of many mass action reactions, using the MassActionJump type will offer improved performance. Note, only one MassActionJump should be defined per JumpProblem; it is then responsible for handling all mass action reaction type jumps. For systems with both mass action jumps and non-mass action jumps, one can create one MassActionJump to handle the mass action jumps, and create a number of ConstantRateJumps to handle the non-mass action jumps.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"RegularJumps are optimized for regular jumping algorithms like tau-leaping and hybrid algorithms. ConstantRateJumps and MassActionJumps are optimized for SSA algorithms. ConstantRateJumps, MassActionJumps and VariableRateJumps can be added to standard DiffEq algorithms since they are simply callbacks, while RegularJumps require special algorithms.","category":"page"},{"location":"jump_types/#Defining-a-Regular-Jump","page":"Jump types and JumpProblem","title":"Defining a Regular Jump","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"The constructor for a RegularJump is:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"RegularJump(rate,c,numjumps;mark_dist = nothing)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"rate(out,u,p,t) is the function which computes the rate for every regular jump process\nc(du,u,p,t,counts,mark) is calculates the update given counts number of jumps for each jump process in the interval.\nnumjumps is the number of jump processes, i.e. the number of rate equations and the number of counts\nmark_dist is the distribution for the mark.","category":"page"},{"location":"jump_types/#Defining-a-Constant-Rate-Jump","page":"Jump types and JumpProblem","title":"Defining a Constant Rate Jump","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"The constructor for a ConstantRateJump is:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"ConstantRateJump(rate,affect!)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"rate(u,p,t) is a function which calculates the rate given the time and the state.\naffect!(integrator) is the effect on the equation, using the integrator interface.","category":"page"},{"location":"jump_types/#Defining-a-Mass-Action-Jump","page":"Jump types and JumpProblem","title":"Defining a Mass Action Jump","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"The constructor for a MassActionJump is:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"MassActionJump(reactant_stoich, net_stoich; scale_rates = true, param_idxs=nothing)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"reactant_stoich is a vector whose kth entry is the reactant stoichiometry of the kth reaction. The reactant stoichiometry for an individual reaction is assumed to be represented as a vector of Pairs, mapping species id to stoichiometric coefficient.\nnet_stoich is assumed to have the same type as reactant_stoich; a vector whose kth entry is the net stoichiometry of the kth reaction. The net stoichiometry for an individual reaction is again represented as a vector of Pairs, mapping species id to the net change in the species when the reaction occurs.\nscale_rates is an optional parameter that specifies whether the rate constants correspond to stochastic rate constants in the sense used by Gillespie, and hence need to be rescaled. The default, scale_rates=true, corresponds to rescaling the passed in rate constants. See below.\nparam_idxs is a vector of the indices within the parameter vector, p, that correspond to the rate constant for each jump.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Notes for Mass Action Jumps","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"When using MassActionJump the default behavior is to assume rate constants correspond to stochastic rate constants in the sense used by Gillespie (J. Comp. Phys., 1976, 22 (4)). This means that for a reaction such as 2A oversetkrightarrow B, the jump rate function constructed by MassActionJump would be k*A*(A-1)/2!. For a trimolecular reaction like 3A oversetkrightarrow B the rate function would be k*A*(A-1)*(A-2)/3!. To avoid having the reaction rates rescaled (by 1/2 and 1/6 for these two examples), one can pass the MassActionJump constructor the optional named parameter scale_rates=false, i.e. use\nMassActionJump(reactant_stoich, net_stoich; scale_rates = false, param_idxs)\nZero order reactions can be passed as reactant_stoichs in one of two ways. Consider the varnothing oversetkrightarrow A reaction with rate k=1:\np = [1.]\nreactant_stoich = [[0 => 1]]\nnet_stoich = [[1 => 1]]\njump = MassActionJump(reactant_stoich, net_stoich; param_idxs=[1])\nAlternatively one can create an empty vector of pairs to represent the reaction:\np = [1.]\nreactant_stoich = [Vector{Pair{Int,Int}}()]\nnet_stoich = [[1 => 1]]\njump = MassActionJump(reactant_stoich, net_stoich; param_idxs=[1])\nFor performance reasons, it is recommended to order species indices in stoichiometry vectors from smallest to largest. That is\nreactant_stoich = [[1 => 2, 3 => 1, 4 => 2], [2 => 2, 3 => 2]]\nis preferred over\nreactant_stoich = [[3 => 1, 1 => 2, 4 = > 2], [3 => 2, 2 => 2]]","category":"page"},{"location":"jump_types/#Defining-a-Variable-Rate-Jump","page":"Jump types and JumpProblem","title":"Defining a Variable Rate Jump","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"The constructor for a VariableRateJump is:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"VariableRateJump(rate,affect!;\n                   idxs = nothing,\n                   rootfind=true,\n                   save_positions=(true,true),\n                   interp_points=10,\n                   abstol=1e-12,reltol=0)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Note that this is the same as defining a ContinuousCallback, except that instead of the condition function, you provide a rate(u,p,t) function for the rate at a given time and state.","category":"page"},{"location":"jump_types/#Defining-a-Jump-Problem","page":"Jump types and JumpProblem","title":"Defining a Jump Problem","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"To define a JumpProblem, you must first define the basic problem. This can be a DiscreteProblem if there is no differential equation, or an ODE/SDE/DDE/DAE if you would like to augment a differential equation with jumps. Denote this previously defined problem as prob. Then the constructor for the jump problem is:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"JumpProblem(prob,aggregator::Direct,jumps::JumpSet;\n            save_positions = typeof(prob) <: AbstractDiscreteProblem ? (false,true) : (true,true))","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"The aggregator is the method for aggregating the constant jumps. These are defined below. jumps is a JumpSet which is just a gathering of jumps. Instead of passing a JumpSet, one may just pass a list of jumps themselves. For example:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"JumpProblem(prob,aggregator,jump1,jump2)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"and the internals will automatically build the JumpSet. save_positions is the save_positions argument built by the aggregation of the constant rate jumps.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Note that a JumpProblem/JumpSet can only have 1 RegularJump (since a RegularJump itself describes multiple processes together). Similarly, it can only have one MassActionJump (since it also describes multiple processes together).","category":"page"},{"location":"jump_types/#Constant-Rate-Jump-Aggregators","page":"Jump types and JumpProblem","title":"Constant Rate Jump Aggregators","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Constant rate jump aggregators are the methods by which constant rate jumps, including MassActionJumps, are lumped together. This is required in all algorithms for both speed and accuracy. The current methods are:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Direct: the Gillespie Direct method SSA.\nRDirect: A variant of Gillespie's Direct method that uses rejection to sample the next reaction.\nDirectCR: The Composition-Rejection Direct method of Slepoy et al. For large networks and linear chain-type networks it will often give better performance than Direct. (Requires dependency graph, see below.)\nDirectFW: the Gillespie Direct method SSA with FunctionWrappers. This aggregator uses a different internal storage format for collections of ConstantRateJumps.\nFRM: the Gillespie first reaction method SSA. Direct should generally offer better performance and be preferred to FRM.\nFRMFW: the Gillespie first reaction method SSA with FunctionWrappers.\nNRM: The Gibson-Bruck Next Reaction Method. For some reaction network  structures this may offer better performance than Direct (for example,  large, linear chains of reactions). (Requires dependency graph, see below.)\nRSSA: The Rejection SSA (RSSA) method of Thanh et al. With RSSACR, for very large reaction networks it often offers the best performance of all methods. (Requires dependency graph, see below.)\nRSSACR: The Rejection SSA (RSSA) with Composition-Rejection method of Thanh et al. With RSSA, for very large reaction networks it often offers the best performance of all methods. (Requires dependency graph, see below.)\nSortingDirect: The Sorting Direct Method of McCollum et al. It will usually offer performance as good as Direct, and for some systems can offer substantially better performance. (Requires dependency graph, see below.)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"To pass the aggregator, pass the instantiation of the type. For example:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"JumpProblem(prob,Direct(),jump1,jump2)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"will build a problem where the constant rate jumps are solved using Gillespie's Direct SSA method.","category":"page"},{"location":"jump_types/#Constant-Rate-Jump-Aggregators-Requiring-Dependency-Graphs","page":"Jump types and JumpProblem","title":"Constant Rate Jump Aggregators Requiring Dependency Graphs","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Italicized constant rate jump aggregators require the user to pass a dependency graph to JumpProblem. DirectCR, NRM and SortingDirect require a jump-jump dependency graph, passed through the named parameter dep_graph. i.e.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"JumpProblem(prob,DirectCR(),jump1,jump2; dep_graph=your_dependency_graph)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"For systems with only MassActionJumps, or those generated from a Catalyst reaction_network, this graph will be auto-generated. Otherwise you must construct the dependency graph manually. Dependency graphs are represented as a Vector{Vector{Int}}, with the ith vector containing the indices of the jumps for which rates must be recalculated when the ith jump occurs. Internally, all MassActionJumps are ordered before ConstantRateJumps (with the latter internally ordered in the same order they were passed in).","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"RSSA and RSSACR require two different types of dependency graphs, passed through the following JumpProblem kwargs:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"vartojumps_map - A Vector{Vector{Int}} mapping each variable index, i, to a set of jump indices. The jump indices correspond to jumps with rate functions that depend on the value of u[i].\njumptovars_map - A Vector{Vector{Int}}  mapping each jump index to a set  of variable indices. The corresponding variables are those that have their  value, u[i], altered when the jump occurs.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"For systems generated from a Catalyst reaction_network these will be auto-generated. Otherwise you must explicitly construct and pass in these mappings.","category":"page"},{"location":"jump_types/#Recommendations-for-Constant-Rate-Jumps","page":"Jump types and JumpProblem","title":"Recommendations for Constant Rate Jumps","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"For representing and aggregating constant rate jumps","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Use a MassActionJump to handle all jumps that can be represented as mass action reactions. This will generally offer the fastest performance.\nUse ConstantRateJumps for any remaining jumps.\nFor a small number of jumps, < ~10, Direct will often perform as well as the other aggregators.\nFor > ~10 jumps SortingDirect will often offer better performance than Direct.\nFor large numbers of jumps with sparse chain like structures and similar jump rates, for example continuous time random walks, RSSACR, DirectCR and then NRM often have the best performance.\nFor very large networks, with many updates per jump, RSSA and RSSACR will often substantially outperform the other methods.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"In general, for systems with sparse dependency graphs if Direct is slow, one of SortingDirect, RSSA or RSSACR will usually offer substantially better performance. See DiffEqBenchmarks.jl for benchmarks on several example networks.","category":"page"},{"location":"jump_types/#Remaking-JumpProblems","page":"Jump types and JumpProblem","title":"Remaking JumpProblems","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"When running many simulations, it can often be convenient to update the initial condition or simulation parameters without having to create and initialize a new JumpProblem. In such situations remake can be used to change the initial condition, time span, and the parameter vector. Note, the new JumpProblem will alias internal data structures from the old problem, including core components of the SSA aggregators. As such, only the new problem generated by remake should be used for subsequent simulations.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"As an example, consider the following SIR model:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"rate1(u,p,t) = (0.1/1000.0)*u[1]*u[2]\nfunction affect1!(integrator)\n  integrator.u[1] -= 1\n  integrator.u[2] += 1\nend\njump = ConstantRateJump(rate1,affect1!)\n\nrate2(u,p,t) = 0.01u[2]\nfunction affect2!(integrator)\n  integrator.u[2] -= 1\n  integrator.u[3] += 1\nend\njump2 = ConstantRateJump(rate2,affect2!)\nu0    = [999,1,0]\np     = (0.1/1000,0.01)\ntspan = (0.0,250.0)\ndprob = DiscreteProblem(u0, tspan, p)\njprob = JumpProblem(dprob, Direct(), jump, jump2)\nsol   = solve(jprob, SSAStepper())","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"We can change any of u0, p and tspan by either making a new DiscreteProblem","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"u02    = [10,1,0]\np2     = (.1/1000, 0.0)\ntspan2 = (0.0,2500.0)\ndprob2 = DiscreteProblem(u02, tspan2, p2)\njprob2 = remake(jprob, prob=dprob2)\nsol2   = solve(jprob2, SSAStepper())","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"or by directly remaking with the new parameters","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"jprob2 = remake(jprob, u0=u02, p=p2, tspan=tspan2)\nsol2   = solve(jprob2, SSAStepper())","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"To avoid ambiguities, the following will give an error","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"jprob2 = remake(jprob, prob=dprob2, u0=u02)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"as will trying to update either p or tspan while passing a new DiscreteProblem using the prob kwarg.","category":"page"},{"location":"jump_solve/#jump_solve","page":"Jump solvers","title":"Jump Problem and Jump Diffusion Solvers","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"solve(prob::JumpProblem,alg;kwargs)","category":"page"},{"location":"jump_solve/#Recommended-Methods","page":"Jump solvers","title":"Recommended Methods","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"A JumpProblem(prob,aggregator,jumps...) comes in two forms. The first major form is if it does not have a RegularJump. In this case, it can be solved with any integrator on  prob. However, in the case of a pure JumpProblem (a JumpProblem over a  DiscreteProblem), there are special algorithms available.  The SSAStepper() is an efficient streamlined algorithm for running the  aggregator version of the SSA for pure ConstantRateJump and/or MassActionJump problems. However, it is not compatible with event handling. If events are necessary, then FunctionMap does well.","category":"page"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"If there is a RegularJump, then specific methods must be used. The current recommended method is TauLeaping if you need adaptivity, events, etc. If you just need the most barebones fixed time step leaping method, then SimpleTauLeaping can have performance benefits.","category":"page"},{"location":"jump_solve/#Special-Methods-for-Pure-Jump-Problems","page":"Jump solvers","title":"Special Methods for Pure Jump Problems","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"If you are using jumps with a differential equation, use the same methods as in the case of the differential equation solving. However, the following algorithms are optimized for pure jump problems.","category":"page"},{"location":"jump_solve/#DiffEqJump.jl","page":"Jump solvers","title":"DiffEqJump.jl","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"SSAStepper: a stepping algorithm for pure ConstantRateJump and/or MassActionJump JumpProblems. Supports handling of DiscreteCallback and saving controls like saveat.","category":"page"},{"location":"jump_solve/#RegularJump-Compatible-Methods","page":"Jump solvers","title":"RegularJump Compatible Methods","text":"","category":"section"},{"location":"jump_solve/#StochasticDiffEq.jl","page":"Jump solvers","title":"StochasticDiffEq.jl","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"These methods support mixing with event handling, other jump types, and all of the features of the normal differential equation solvers.","category":"page"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"TauLeaping: an adaptive tau-leaping algorithm with post-leap estimates.","category":"page"},{"location":"jump_solve/#DiffEqJump.jl-2","page":"Jump solvers","title":"DiffEqJump.jl","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"SimpleTauLeaping: a tau-leaping algorithm for pure RegularJump JumpProblems. Requires a choice of dt.\nRegularSSA: a version of SSA for pure RegularJump JumpProblems.","category":"page"},{"location":"jump_solve/#Regular-Jump-Diffusion-Compatible-Methods","page":"Jump solvers","title":"Regular Jump Diffusion Compatible Methods","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"Regular jump diffusions are JumpProblems where the internal problem is an SDEProblem and the jump process has designed a regular jump.","category":"page"},{"location":"jump_solve/#StochasticDiffEq.jl-2","page":"Jump solvers","title":"StochasticDiffEq.jl","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"EM: Explicit Euler-Maruyama.\nImplicitEM: Implicit Euler-Maruyama. See the SDE solvers page for more details.","category":"page"},{"location":"#DiffEqJump.jl","page":"Home","title":"DiffEqJump.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DiffEqJump.jl provides methods for simulating jump processes, known as stochastic simulation algorithms (SSAs), Doob's method, Gillespie methods, or Kinetic Monte Carlo methods across different fields of science. It also enables the incorporation of jump processes into hybrid jump-ODE and jump-SDE models, including jump diffusions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DiffEqJump is a component package in the SciML ecosystem, and one of the core solver libraries included in DifferentialEquations.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation includes","category":"page"},{"location":"","page":"Home","title":"Home","text":"a tutorial on simulating basic Poisson processes\na tutorial and details on using DiffEqJump to simulate jump processes via SSAs (i.e. Gillespie methods),\na tutorial on simulating jump-diffusion processes,\na reference on the types of jumps and available simulation methods,\na reference on jump time stepping methods\na FAQ with information on changing parameters between simulations and using callbacks.\nthe DiffEqJump.jl API documentation.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are two ways to install DiffEqJump.jl. First, users may install the meta DifferentialEquations.jl package, which installs and wraps OrdinaryDiffEq.jl for solving ODEs, StochasticDiffEq.jl for solving SDEs, and DiffEqJump.jl, along with a number of other useful packages for solving models involving ODEs, SDEs and/or jump process. This single install will provide the user with all of the facilities for developing and solving Jump problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the DifferentialEquations.jl package, refer to the following link for complete installation details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If the user wishes to separately install the DiffEqJump.jl library, which is a lighter dependency than DifferentialEquations.jl, then the following code will install DiffEqJump.jl using the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DiffEqJump\")","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nThere are a few community forums:\nthe #diffeq-bridged and #sciml-bridged channels on the Julia Slack\nJuliaDiffEq on Gitter\nthe Julia Discourse forums","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also the SciML Community page.","category":"page"},{"location":"faq/#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"faq/#My-simulation-is-really-slow-and/or-using-a-lot-of-memory,-what-can-I-do?","page":"FAQ","title":"My simulation is really slow and/or using a lot of memory, what can I do?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"To reduce memory use, use save_positions=(false,false) in the JumpProblem constructor as described earlier to turn off saving the system state before and after every jump. Combined with use of saveat in the call to solve this can dramatically reduce memory usage.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"While Direct is often fastest for systems with 10 or less ConstantRateJumps or MassActionJumps, if your system has many jumps or one jump occurs most frequently, other stochastic simulation algorithms may be faster. See Constant Rate Jump Aggregators and the subsequent sections there for guidance on choosing different SSAs (called aggregators in DiffEqJump).","category":"page"},{"location":"faq/#When-running-many-consecutive-simulations,-for-example-within-an-EnsembleProblem-or-loop,-how-can-I-update-JumpProblems?","page":"FAQ","title":"When running many consecutive simulations, for example within an EnsembleProblem or loop, how can I update JumpProblems?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In Remaking JumpProblems we show how to modify parameters, the initial condition, and other components of a generated JumpProblem. This can be useful when trying to call solve many times while avoiding reallocations of the internal aggregators for each new parameter value or initial condition.","category":"page"},{"location":"faq/#How-can-I-define-collections-of-many-different-jumps-and-pass-them-to-JumpProblem?","page":"FAQ","title":"How can I define collections of many different jumps and pass them to JumpProblem?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"We can use JumpSets to collect jumps together, and then pass them into JumpProblems directly. For example, using the MassActionJump and ConstantRateJump defined earlier we can write","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"jset = JumpSet(mass_act_jump, birth_jump)\njump_prob = JumpProblem(prob, Direct(), jset)\nsol = solve(jump_prob, SSAStepper())","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you have many jumps in tuples or vectors it is easiest to use the keyword argument-based constructor:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"cj1 = ConstantRateJump(rate1, affect1!)\ncj2 = ConstantRateJump(rate2, affect2!)\ncjvec = [cj1, cj2]\n\nvj1 = VariableRateJump(rate3, affect3!)\nvj2 = VariableRateJump(rate4, affect4!)\nvjtuple = (vj1, vj2)\n\njset = JumpSet(; constant_jumps=cjvec, variable_jumps=vjtuple,\n                 massaction_jumps=mass_act_jump)","category":"page"},{"location":"faq/#How-can-I-set-the-random-number-generator-used-in-the-jump-process-sampling-algorithms-(SSAs)?","page":"FAQ","title":"How can I set the random number generator used in the jump process sampling algorithms (SSAs)?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Random number generators can be passed to JumpProblem via the rng keyword argument. Continuing the previous example:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"#] add RandomNumbers\nusing RandomNumbers\njprob = JumpProblem(dprob, Direct(), maj,\n                    rng = Xorshifts.Xoroshiro128Star(rand(UInt64)))","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"uses the Xoroshiro128Star generator from RandomNumbers.jl.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"On version 1.7 and up DiffEqJump uses Julia's builtin random number generator by default. On versions below 1.7 it uses Xoroshiro128Star.","category":"page"},{"location":"faq/#What-are-these-aggregators-and-aggregations-in-DiffEqJump?","page":"FAQ","title":"What are these aggregators and aggregations in DiffEqJump?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"DiffEqJump provides a variety of methods for sampling the time the next ConstantRateJump or MassActionJump occurs, and which jump type happens at that time. These methods are examples of stochastic simulation algorithms (SSAs), also known as Gillespie methods, Doob's method, or Kinetic Monte Carlo methods. In the DiffEqJump terminology we call such methods \"aggregators\", and the cache structures that hold their basic data \"aggregations\". See Constant Rate Jump Aggregators for a list of the available SSA aggregators.","category":"page"},{"location":"faq/#How-should-jumps-be-ordered-in-dependency-graphs?","page":"FAQ","title":"How should jumps be ordered in dependency graphs?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Internally, DiffEqJump SSAs (aggregators) order all MassActionJumps first, then all ConstantRateJumps. i.e. in the example","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"using DiffEqJump\nrs = [[1 => 1], [2 => 1]]\nns = [[1 => -1, 2 => 1], [1 => 1, 2 => -1]]\np = [1.0, 0.0]\nmaj = MassActionJump(rs, ns; param_idxs=[1, 2])\nrate1(u, p, t) = u[1]\nfunction affect1!(integrator)\n    u[1] -= 1\nend\ncj1 = ConstantRateJump(rate1, affect1)\nrate2(u, p, t) = u[2]\nfunction affect2!(integrator)\n    u[2] -= 1\nend\ncj2 = ConstantRateJump(rate2, affect2)\njset = JumpSet(; constant_jumps=[cj1, cj2], massaction_jump=maj)","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The four jumps would be ordered by the first jump in maj, the second jump in maj, cj1, and finally cj2. Any user-generated dependency graphs should then follow this ordering when assigning an integer id to each jump.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"See also Constant Rate Jump Aggregators Requiring Dependency Graphs for more on dependency graphs needed for the various SSAs.","category":"page"},{"location":"faq/#How-do-I-use-callbacks-with-ConstantRateJump-or-MassActionJump-systems?","page":"FAQ","title":"How do I use callbacks with ConstantRateJump or MassActionJump systems?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Callbacks can be used with ConstantRateJumps and MassActionJumps. When solving a pure jump system with SSAStepper, only discrete callbacks can be used (otherwise a different time stepper is needed). When using an ODE or SDE time stepper any callback should work.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Note, when modifying u or p within a callback, you must call reset_aggregated_jumps! after making updates. This ensures that the underlying jump simulation algorithms know to reinitialize their internal data structures. Leaving out this call will lead to incorrect behavior!","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"A simple example that uses a MassActionJump and changes the parameters at a specified time in the simulation using a DiscreteCallback is","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"using DiffEqJump\nrs = [[1 => 1], [2 => 1]]\nns = [[1 => -1, 2 => 1], [1 => 1, 2 => -1]]\np = [1.0, 0.0]\nmaj = MassActionJump(rs, ns; param_idxs=[1, 2])\nu₀ = [100, 0]\ntspan = (0.0, 40.0)\ndprob = DiscreteProblem(u₀, tspan, p)\njprob = JumpProblem(dprob, Direct(), maj)\npcondit(u, t, integrator) = t == 20.0\nfunction paffect!(integrator)\n    integrator.p[1] = 0.0\n    integrator.p[2] = 1.0\n    reset_aggregated_jumps!(integrator)\n    nothing\nend\nsol = solve(jprob, SSAStepper(), tstops=[20.0], callback=DiscreteCallback(pcondit, paffect!))","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Here at time 20.0 we turn off production of u[2] while activating production of u[1], giving","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"(Image: callback_gillespie)","category":"page"},{"location":"faq/#How-can-I-access-earlier-solution-values-in-callbacks?","page":"FAQ","title":"How can I access earlier solution values in callbacks?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"When using an ODE or SDE time-stepper that conforms to the integrator interface one can simply use integrator.uprev. For efficiency reasons, the pure jump SSAStepper integrator does not have such a field. If one needs solution components at earlier times one can save them within the callback condition by making a functor:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"# stores the previous value of u[2] and represents the callback functions\nmutable struct UprevCondition{T}\n     u2::T\nend\n\n# condition\nfunction (upc::UprevCondition)(u, t, integrator)\n    # condition for the callback is that the new value of u[2]\n    # is smaller than the previous value\n    condit = u[2] - upc.u2 < 0\n\n    # save the new value as the previous value\n    upc.u2 = u[2]\n\n    condit\nend\n\n# affect!\nfunction (upc::UprevCondition)(integrator)\n    integrator.u[4] -= 1\n    nothing\nend\n\nupc = UprevCondition(u0[2])\ncb = DiscreteCallback(upc, upc)","category":"page"}]
}
