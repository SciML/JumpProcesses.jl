var documenterSearchIndex = {"docs":
[{"location":"api/#JumpProcesses.jl-API","page":"API","title":"JumpProcesses.jl API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = JumpProcesses","category":"page"},{"location":"api/#Core-Types","page":"API","title":"Core Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JumpProblem\nSSAStepper\nreset_aggregated_jumps!","category":"page"},{"location":"api/#JumpProcesses.JumpProblem","page":"API","title":"JumpProcesses.JumpProblem","text":"mutable struct JumpProblem{iip, P, A, C, J<:Union{Nothing, JumpProcesses.AbstractJumpAggregator}, J2, J3, J4, R, K} <: SciMLBase.AbstractJumpProblem{P, J<:Union{Nothing, JumpProcesses.AbstractJumpAggregator}}\n\nDefines a collection of jump processes to associate with another problem type.\n\nDocumentation Page\nTutorial Page\nFAQ Page\n\nConstructors\n\nJumpProblems can be constructed by first building another problem type to which the jumps will be associated. For example, to  simulate a collection of jump processes for which the transition rates are constant between jumps (called ConstantRateJumps or MassActionJumps), we must first construct a DiscreteProblem\n\nprob = DiscreteProblem(u0, p, tspan)\n\nwhere u0 is the initial condition, p the parameters and tspan the time span. If we wanted to have the jumps coupled with a system of ODEs, or have transition rates with explicit time dependence, we would use an ODEProblem instead that defines the ODE portion of the dynamics.\n\nGiven prob we define the jumps via\n\nJumpProblem(prob, aggregator::AbstractAggregatorAlgorithm, jumps::JumpSet ; kwargs...)\nJumpProblem(prob, aggregator::AbstractAggregatorAlgorithm, jumps...; kwargs...)\n\nHere aggregator specifies the underlying algorithm for calculating next jump times and types, for example Direct. The collection of different AbstractJump types can then be passed within a single JumpSet or as subsequent sequential arguments.\n\nFields\n\nprob: The type of problem to couple the jumps to. For a pure jump process use DiscreteProblem, to couple to ODEs, ODEProblem, etc.\naggregator: The aggregator algorithm that determines the next jump times and types for ConstantRateJumps and MassActionJumps. Examples include Direct.\ndiscrete_jump_aggregation: The underlying state data associated with the chosen aggregator.\njump_callback: CallBackSet with the underlying ConstantRate and VariableRate jumps.\nvariable_jumps: The VariableRateJumps.\nregular_jump: The RegularJumps.\nmassaction_jump: The MassActionJumps.\nrng: The random number generator to use.\nkwargs: kwargs to pass on to solve call.\n\nKeyword Arguments\n\nrng, the random number generator to use. On 1.7 and up defaults to Julia's built-in generator, below 1.7 uses RandomNumbers.jl's Xorshifts.Xoroshiro128Star(rand(UInt64)).\nsave_positions=(true,true), specifies whether to save the system's state (before, after) the jump occurs.\nspatial_system, for spatial problems the underlying spatial structure.\nhopping_constants, for spatial problems the spatial transition rate coefficients.\nuse_vrj_bounds = true, set to false to disable handling bounded VariableRateJumps with a supporting aggregator (such as Coevolve). They will then be handled via the continuous integration interface, and treated like general VariableRateJumps.\n\nPlease see the tutorial page in the DifferentialEquations.jl docs for usage examples and commonly asked questions.\n\n\n\n\n\n","category":"type"},{"location":"api/#JumpProcesses.SSAStepper","page":"API","title":"JumpProcesses.SSAStepper","text":"struct SSAStepper <: SciMLBase.AbstractDEAlgorithm\n\nHighly efficient integrator for pure jump problems that involve only ConstantRateJumps, MassActionJumps, and/or VariableRateJumps with rate bounds.\n\nNotes\n\nOnly works with JumpProblems defined from DiscreteProblems.\nOnly works with collections of ConstantRateJumps, MassActionJumps, and VariableRateJumps with rate bounds.\nOnly supports DiscreteCallbacks for events, which are checked after every step taken by SSAStepper.\nOnly supports a limited subset of the output controls from the common solver interface, specifically save_start, save_end, and saveat.\nAs when using jumps with ODEs and SDEs, saving controls for whether to save each time a jump occurs are via the save_positions keyword argument to JumpProblem. Note that when choosing SSAStepper as the timestepper, save_positions = (true,true), (true,false), or (false,true) are all equivalent. SSAStepper will save only the post-jump state in the solution object in each of these cases. This is because solution objects generated via SSAStepper use piecewise-constant interpolation, and can therefore exactly reconstruct the sampled jump process path with knowing just the post-jump state. That is, sol(t) for any 0 <= t <= tstop will give the exact value of the sampled solution path at t provided at least one component of save_positions is true.\n\nExamples\n\nSIR model:\n\nusing JumpProcesses\nβ = 0.1 / 1000.0; ν = .01;\np = (β,ν)\nrate1(u,p,t) = p[1]*u[1]*u[2]  # β*S*I\nfunction affect1!(integrator)\n  integrator.u[1] -= 1         # S -> S - 1\n  integrator.u[2] += 1         # I -> I + 1\nend\njump = ConstantRateJump(rate1,affect1!)\n\nrate2(u,p,t) = p[2]*u[2]      # ν*I\nfunction affect2!(integrator)\n  integrator.u[2] -= 1        # I -> I - 1\n  integrator.u[3] += 1        # R -> R + 1\nend\njump2 = ConstantRateJump(rate2,affect2!)\nu₀    = [999,1,0]\ntspan = (0.0,250.0)\nprob = DiscreteProblem(u₀, tspan, p)\njump_prob = JumpProblem(prob, Direct(), jump, jump2)\nsol = solve(jump_prob, SSAStepper())\n\nsee the tutorial for details.\n\n\n\n\n\n","category":"type"},{"location":"api/#JumpProcesses.reset_aggregated_jumps!","page":"API","title":"JumpProcesses.reset_aggregated_jumps!","text":"reset_aggregated_jumps!(integrator, uprev = nothing; update_jump_params=true)\n\nReset the state of jump processes and associated solvers following a change in parameters or such.\n\nNotes\n\nupdate_jump_params=true will recalculate the rates stored within any MassActionJump that was built from the parameter vector. If the parameter vector is unchanged, this can safely be set to false to improve performance.\n\n\n\n\n\n","category":"function"},{"location":"api/#Types-of-Jumps","page":"API","title":"Types of Jumps","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ConstantRateJump\nMassActionJump\nVariableRateJump\nRegularJump\nJumpSet","category":"page"},{"location":"api/#JumpProcesses.ConstantRateJump","page":"API","title":"JumpProcesses.ConstantRateJump","text":"struct ConstantRateJump{F1, F2} <: JumpProcesses.AbstractJump\n\nDefines a jump process with a rate (i.e. hazard, intensity, or propensity) that does not explicitly depend on time. More precisely, one where the rate function is constant between the occurrence of jumps. For detailed examples and usage information, see the\n\nTutorial\n\nFields\n\nrate: Function rate(u,p,t) that returns the jump's current rate.\naffect!: Function affect(integrator) that updates the state for one occurrence of the jump.\n\nExamples\n\nSuppose u[1] gives the number of particles and p[1] the probability per time each particle can decay away. A corresponding ConstantRateJump for this jump process is\n\nrate(u,p,t) = p[1]*u[1]\naffect!(integrator) = integrator.u[1] -= 1\ncrj = ConstantRateJump(rate, affect!)\n\nNotice, here that rate changes in time, but is constant between the occurrence of jumps (when u[1] will decrease).\n\n\n\n\n\n","category":"type"},{"location":"api/#JumpProcesses.MassActionJump","page":"API","title":"JumpProcesses.MassActionJump","text":"struct MassActionJump{T, S, U, V} <: JumpProcesses.AbstractMassActionJump\n\nOptimized representation for ConstantRateJumps that can be represented in mass action form, offering improved performance within jump algorithms compared to ConstantRateJump. For detailed examples and usage information, see the\n\nMain Docs\nTutorial\n\nConstructors\n\nMassActionJump(reactant_stoich, net_stoich; scale_rates = true, param_idxs = nothing)\n\nHere reactant_stoich denotes the reactant stoichiometry for each reaction and net_stoich the net stoichiometry for each reaction.\n\nFields\n\nscaled_rates: The (scaled) reaction rate constants.\nreactant_stoch: The reactant stoichiometry vectors.\nnet_stoch: The net stoichiometry vectors.\nparam_mapper: Parameter mapping functor to identify reaction rate constants with parameters in p vectors.\n\nKeyword Arguments\n\nscale_rates = true, whether to rescale the reaction rate constants according to the stoichiometry.\nnocopy = false, whether the MassActionJump can alias the scaled_rates and reactant_stoch from the input. Note, if scale_rates=true this will potentially modify both of these.\nparam_idxs = nothing, indexes in the parameter vector, JumpProblem.prob.p, that correspond to each reaction's rate.\n\nSee the tutorial and main docs for details.\n\nExamples\n\nAn SIR model with S + I --> 2I at rate β as the first reaction and I --> R at rate ν as the second reaction can be encoded by\n\np        = (β=1e-4, ν=.01)\nu0       = [999, 1, 0]       # (S,I,R)\ntspan    = (0.0, 250.0)\nrateidxs = [1, 2]           # i.e. [β,ν]\nreactant_stoich =\n[\n  [1 => 1, 2 => 1],         # 1*S and 1*I\n  [2 => 1]                  # 1*I\n]\nnet_stoich =\n[\n  [1 => -1, 2 => 1],        # -1*S and 1*I\n  [2 => -1, 3 => 1]         # -1*I and 1*R\n]\nmaj = MassActionJump(reactant_stoich, net_stoich; param_idxs=rateidxs)\nprob = DiscreteProblem(u0, tspan, p)\njprob = JumpProblem(prob, Direct(), maj)\n\nNotes\n\nBy default, reaction rates are rescaled when constructing the MassActionJump as explained in the main docs. Disable this with the kwarg scale_rates=false.\nAlso see the main docs for how to specify reactions with no products or no reactants.\n\n\n\n\n\n","category":"type"},{"location":"api/#JumpProcesses.VariableRateJump","page":"API","title":"JumpProcesses.VariableRateJump","text":"struct VariableRateJump{R, F, R2, R3, R4, I, T, T2} <: JumpProcesses.AbstractJump\n\nDefines a jump process with a rate (i.e. hazard, intensity, or propensity) that may explicitly depend on time. More precisely, one where the rate function is allowed to change between the occurrence of jumps. For detailed examples and usage information, see the\n\nTutorial\n\nNote that two types of VariableRateJumps are currently supported, with different performance characteritistics.\n\nA general VariableRateJump or VariableRateJump will refer to one in which only rate and affect functions are specified.\nThese are the most general in what they can represent, but require the use of an ODEProblem or SDEProblem whose underlying timestepper handles their evolution in time (via the callback interface).\nThis is the least performant jump type in simulations.\nBounded VariableRateJumps require passing the keyword arguments urate and rateinterval, corresponding to functions urate(u, p, t) and rateinterval(u, p, t), see below. These must calculate a time window over which the rate function is bounded by a constant. Note that it is ok if the rate bound would be violated within the time interval due to a change in u arising from another ConstantRateJump, MassActionJump or bounded VariableRateJump being executed, as the chosen aggregator will then handle recalculating the rate bound and interval. However, if the bound could be violated within the time interval due to a change in u arising from continuous dynamics such as a coupled ODE, SDE, or a general VariableRateJump, bounds should not be given. This ensures the jump is classified as a general VariableRateJump and properly handled. One can also optionally provide a lower bound function, lrate(u, p, t), via the lrate keyword argument. This can lead to increased performance. The validity of the lower bound should hold under the same conditions and rate interval as urate.\nBounded VariableRateJumps can currently be used in the Coevolve aggregator, and can therefore be efficiently simulated in pure-jump DiscreteProblems using the SSAStepper time-stepper.\nThese can be substantially more performant than general VariableRateJumps without the rate bound functions.\n\nReemphasizing, the additional user provided functions leveraged by bounded VariableRateJumps, urate(u, p, t), rateinterval(u, p, t), and the optional lrate(u, p, t) require that\n\nFor s in [t, t + rateinterval(u, p, t)], we have that lrate(u, p, t) <= rate(u, p, s) <= urate(u, p, t).\nIt is ok if these bounds would be violated during the time window due to another ConstantRateJump, MassActionJump or bounded VariableRateJump occurring. However, they must remain valid if u changes for any other reason (for example, due to continuous dynamics like ODEs, SDEs, or general VariableRateJumps).\n\nFields\n\nrate: Function rate(u,p,t) that returns the jump's current rate given state u, parameters p and time t.\naffect!: Function affect!(integrator) that updates the state for one occurrence of the jump given integrator.\nlrate: Optional function lrate(u, p, t) that computes a lower bound on the rate in the interval t to t + rateinterval(u, p, t) at time t given state u and parameters p. This bound must rigorously hold during the time interval as long as another ConstantRateJump, MassActionJump, or bounded VariableRateJump has not been sampled. When using aggregators that support bounded VariableRateJumps, currently only Coevolve, providing a lower-bound can lead to improved performance.\n\nurate: Optional function urate(u, p, t) for general VariableRateJumps, but is required to define a bounded VariableRateJump, which can be used with supporting aggregators,  currently only Coevolve, and offers improved computational performance. Computes an upper bound for the rate in the interval t to t + rateinterval(u, p, t) at time t given state u and parameters p. This bound must rigorously hold during the time interval as long as another ConstantRateJump, MassActionJump, or bounded VariableRateJump has not been sampled.\nrateinterval: Optional function rateinterval(u, p, t) for general VariableRateJumps, but is required to define a bounded VariableRateJump, which can be used with supporting  aggregators, currently only Coevolve, and offers improved computational performance. Computes the time interval from time t over which the urate and lrate bounds will hold, t to t + rateinterval(u, p, t), given state u and parameters p. This bound must rigorously hold during the time interval as long as another ConstantRateJump, MassActionJump, or bounded VariableRateJump has not been sampled.\nidxs\nrootfind\ninterp_points\nsave_positions\nabstol\nreltol\n\nExamples\n\nSuppose u[1] gives the number of particles and t*p[1] the probability per time each particle can decay away. A corresponding VariableRateJump for this jump process is\n\nrate(u,p,t) = t*p[1]*u[1]\naffect!(integrator) = integrator.u[1] -= 1\nvrj = VariableRateJump(rate, affect!)\n\nTo define a bounded VariableRateJump that can be used with supporting aggregators such as Coevolve, we must define bounds and a rate interval:\n\nrateinterval(u,p,t) = (1 / p[1]) * 2\nrate(u,p,t) = t * p[1] * u[1]\nlrate(u, p, t) = rate(u, p, t)\nurate(u,p,t) = rate(u, p, t + rateinterval(u,p,t))\naffect!(integrator) = integrator.u[1] -= 1\nvrj = VariableRateJump(rate, affect!; lrate = lrate, urate = urate,\n                                      rateinterval = rateinterval)\n\nNotes\n\nWhen using an aggregator that supports bounded VariableRateJumps, DiscreteProblem can be used. Otherwise, ODEProblem or SDEProblem must be used.\nWhen not using aggregators that support bounded VariableRateJumps, or when there are general VariableRateJumps, integrators store an effective state type that wraps the main state vector. See ExtendedJumpArray for details on using this object. In this case all ConstantRateJump, VariableRateJump and callback affect! functions receive an integrator with integrator.u an ExtendedJumpArray.\nSalis H., Kaznessis Y.,  Accurate hybrid stochastic simulation of a system of coupled chemical or biochemical reactions, Journal of Chemical Physics, 122 (5), DOI:10.1063/1.1835951 is used for calculating jump times with VariableRateJumps within ODE/SDE integrators.\n\n\n\n\n\n","category":"type"},{"location":"api/#JumpProcesses.RegularJump","page":"API","title":"JumpProcesses.RegularJump","text":"struct RegularJump{iip, R, C, MD}\n\n\n\n\n\n","category":"type"},{"location":"api/#JumpProcesses.JumpSet","page":"API","title":"JumpProcesses.JumpSet","text":"struct JumpSet{T1, T2, T3, T4} <: JumpProcesses.AbstractJump\n\nDefines a collection of jumps that should collectively be included in a simulation.\n\nFields\n\nvariable_jumps: Collection of VariableRateJumps\nconstant_jumps: Collection of ConstantRateJumps\nregular_jump: Collection of RegularJumps\nmassaction_jump: Collection of MassActionJumps\n\nExamples\n\nHere we construct two jumps, store them in a JumpSet, and then simulate the resulting process.\n\nusing JumpProcesses, OrdinaryDiffEq\n\nrate1(u,p,t) = p[1]\naffect1!(integrator) = (integrator.u[1] += 1)\ncrj = ConstantRateJump(rate1, affect1!)\n\nrate2(u,p,t) = (t/(1+t))*p[2]*u[1]\naffect2!(integrator) = (integrator.u[1] -= 1)\nvrj = VariableRateJump(rate2, affect2!)\n\njset = JumpSet(crj, vrj)\n\nf!(du,u,p,t) = (du .= 0)\nu0 = [0.0]\np = (20.0, 2.0)\ntspan = (0.0, 200.0)\noprob = ODEProblem(f!, u0, tspan, p)\njprob = JumpProblem(oprob, Direct(), jset)\nsol = solve(jprob, Tsit5())\n\n\n\n\n\n","category":"type"},{"location":"api/#Aggregators","page":"API","title":"Aggregators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Aggregators are the underlying algorithms used for sampling ConstantRateJumps, MassActionJumps, and VariableRateJumps.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Coevolve\nDirect\nDirectCR\nFRM\nNRM\nRDirect\nRSSA\nRSSACR\nSortingDirect","category":"page"},{"location":"api/#JumpProcesses.Coevolve","page":"API","title":"JumpProcesses.Coevolve","text":"An improvement of the COEVOLVE algorithm for simulating any compound jump process that evolves through time. This method handles variable intensity rates with user-defined bounds and inter-dependent processes. It reduces to NRM when rates are constant. As opposed to COEVOLVE, this method syncs the thinning procedure with the stepper which allows it to handle dependencies on continuous dynamics.\n\nM. Farajtabar, Y. Wang, M. Gomez-Rodriguez, S. Li, H. Zha, and L. Song, COEVOLVE: a joint point process model for information diffusion and network evolution, Journal of Machine Learning Research 18(1), 1305–1353 (2017). doi: 10.5555/3122009.3122050.\n\n\n\n\n\n","category":"type"},{"location":"api/#JumpProcesses.Direct","page":"API","title":"JumpProcesses.Direct","text":"Gillespie's Direct method. ConstantRateJump rates and affects are stored in tuples. Fastest for a small (total) number of ConstantRateJumps or MassActionJumps (~10). For larger numbers of possible jumps, use other methods.\n\nDaniel T. Gillespie, A general method for numerically simulating the stochastic time evolution of coupled chemical reactions, Journal of Computational Physics, 22 (4), 403–434 (1976). doi:10.1016/0021-9991(76)90041-3.\n\n\n\n\n\n","category":"type"},{"location":"api/#JumpProcesses.DirectCR","page":"API","title":"JumpProcesses.DirectCR","text":"The Composition-Rejection Direct method. Performs best relative to other methods for systems with large numbers of jumps with special structure (for example a linear chain of reactions, or jumps corresponding to particles hopping on a grid or graph).\n\nA. Slepoy, A.P. Thompson and S.J. Plimpton, A constant-time kinetic Monte Carlo algorithm for simulation of large biochemical reaction networks, Journal of Chemical Physics, 128 (20), 205101 (2008). doi:10.1063/1.2919546.\n\nS. Mauch and M. Stalzer, Efficient formulations for exact stochastic simulation of chemical systems, ACM Transactions on Computational Biology and Bioinformatics, 8 (1), 27-35 (2010). doi:10.1109/TCBB.2009.47.\n\n\n\n\n\n","category":"type"},{"location":"api/#JumpProcesses.FRM","page":"API","title":"JumpProcesses.FRM","text":"Gillespie's First Reaction Method. Should not be used for practical applications due to slow performance relative to all other methods.\n\nDaniel T. Gillespie, A general method for numerically simulating the stochastic time evolution of coupled chemical reactions, Journal of Computational Physics, 22 (4), 403–434 (1976). doi:10.1016/0021-9991(76)90041-3.\n\n\n\n\n\n","category":"type"},{"location":"api/#JumpProcesses.NRM","page":"API","title":"JumpProcesses.NRM","text":"The Next Reaction Method. Can significantly outperform Direct for systems with large numbers of jumps and sparse dependency graphs, but is usually slower than one of DirectCR, RSSA, or RSSACR for such systems.\n\nM. A. Gibson and J. Bruck, Efficient exact stochastic simulation of chemical systems with many species and many channels, Journal of Physical Chemistry A, 104 (9), 1876-1889 (2000). doi:10.1021/jp993732q.\n\n\n\n\n\n","category":"type"},{"location":"api/#JumpProcesses.RDirect","page":"API","title":"JumpProcesses.RDirect","text":"A rejection-based direct method.\n\n\n\n\n\n","category":"type"},{"location":"api/#JumpProcesses.RSSA","page":"API","title":"JumpProcesses.RSSA","text":"The Rejection SSA method. One of the best methods for systems with hundreds to many thousands of jumps (along with RSSACR) and sparse dependency graphs.\n\nV. H. Thanh, C. Priami and R. Zunino, Efficient rejection-based simulation of biochemical reactions with stochastic noise and delays, Journal of Chemical Physics, 141 (13), 134116 (2014). doi:10.1063/1.4896985\n\nV. H. Thanh, R. Zunino and C. Priami, On the rejection-based algorithm for simulation and analysis of large-scale reaction networks, Journal of Chemical Physics, 142 (24), 244106 (2015). doi:10.1063/1.4922923.\n\n\n\n\n\n","category":"type"},{"location":"api/#JumpProcesses.RSSACR","page":"API","title":"JumpProcesses.RSSACR","text":"The Rejection SSA Composition-Rejection method. Often the best performer for systems with tens of thousands of jumps and sparse dependency graphs.\n\nV. H. Thanh, R. Zunino, and C. Priami, Efficient constant-time complexity algorithm for stochastic simulation of large reaction networks, IEEE/ACM Transactions on Computational Biology and Bioinformatics, 14 (3), 657-667 (2017). doi:10.1109/TCBB.2016.2530066.\n\n\n\n\n\n","category":"type"},{"location":"api/#JumpProcesses.SortingDirect","page":"API","title":"JumpProcesses.SortingDirect","text":"The Sorting Direct method. Often the fastest algorithm for smaller to moderate sized systems (tens of jumps), or systems where a few jumps occur much more frequently than others.\n\nJ. M. McCollum, G. D. Peterson, C. D. Cox, M. L. Simpson and N. F. Samatova, The sorting direct method for stochastic simulation of biochemical systems with varying reaction execution behavior, Computational Biology and Chemistry, 30 (1), 39049 (2006). doi:10.1016/j.compbiolchem.2005.10.007.\n\n\n\n\n\n","category":"type"},{"location":"api/#Private-API-Functions","page":"API","title":"Private API Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ExtendedJumpArray\nSSAIntegrator","category":"page"},{"location":"api/#JumpProcesses.ExtendedJumpArray","page":"API","title":"JumpProcesses.ExtendedJumpArray","text":"struct ExtendedJumpArray{T3<:Number, T1, T<:AbstractArray{T3<:Number, T1}, T2} <: AbstractArray{T3<:Number, 1}\n\nExtended state definition used within integrators when there are VariableRateJumps in a system. For detailed examples and usage information, see the\n\nTutorial\n\nFields\n\nu: The current state.\njump_u: The current rate (i.e. hazard, intensity, or propensity) values for the VariableRateJumps.\n\nExamples\n\nusing JumpProcesses, OrdinaryDiffEq\nf(du,u,p,t) = du .= 0\nrate(u,p,t) = (1+t)*u[1]*u[2]\n\n# suppose we wish to decrease each of the two variables by one\n# when a jump occurs\nfunction affect!(integrator)\n   # Method 1, direct indexing works like normal\n   integrator.u[1] -= 1\n   integrator.u[2] -= 1\n\n   # Method 2, if we want to broadcast or use array operations we need\n   # to access integrator.u.u which is the actual state object.\n   # So equivalently to above we could have said:\n   # integrator.u.u .-= 1\nend\n\nu0 = [10.0, 10.0]\nvrj = VariableRateJump(rate, affect!)\noprob = ODEProblem(f, u0, (0.0,2.0))\njprob = JumpProblem(oprob, Direct(), vrj)\nsol = solve(jprob,Tsit5())\n\nNotes\n\nIf ueja isa ExtendedJumpArray with ueja.u of size N and ueja.jump_u of size num_variableratejumps then\n# for 1 <= i <= N\nueja[i] == ueja.u[i]\n\n# for N < i <= (N+num_variableratejumps)\nueja[i] == ueja.jump_u[i]\nIn a system with VariableRateJumps all callback, ConstantRateJump, and VariableRateJump affect! functions will receive integrators with integrator.u an ExtendedJumpArray.\nAs such, affect! functions that wish to modify the state via vector operations should use ueja.u.u to obtain the aliased state object.\n\n\n\n\n\n","category":"type"},{"location":"api/#JumpProcesses.SSAIntegrator","page":"API","title":"JumpProcesses.SSAIntegrator","text":"mutable struct SSAIntegrator{F, uType, tType, tdirType, P, S, CB, SA, OPT, TS} <: JumpProcesses.AbstractSSAIntegrator{SSAStepper, Nothing, uType, tType}\n\nSolution objects for pure jump problems solved via SSAStepper.\n\nFields\n\nf: The underlying prob.f function. Not currently used.\nu: The current solution values.\nt: The current solution time.\ntprev: The previous time a jump occurred.\ntdir: The direction time is changing in (must be positive, indicating time is increasing)\np: The current parameters.\nsol: The current solution object.\ni\ntstop: The next jump time.\ncb: The jump aggregator callback.\nsaveat: Times to save the solution at.\nsave_everystep: Whether to save every time a jump occurs.\nsave_end: Whether to save at the final step.\ncur_saveat: Index of the next saveat time.\nopts: Tuple storing callbacks.\ntstops: User supplied times to step to, useful with callbacks.\ntstops_idx\nu_modified\nkeep_stepping\n\n\n\n\n\n","category":"type"},{"location":"tutorials/simple_poisson_process/#poisson_proc_tutorial","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"","category":"section"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"In this tutorial, we show how to simulate several Poisson jump processes, for several types of intensities and jump distributions. Readers interested primarily in chemical or population process models, where several types of jumps may occur, can skip directly to the second tutorial for a tutorial covering similar material but focused on the SIR model.","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"JumpProcesses allows the simulation of jump processes where the transition rate, i.e., intensity or propensity, can be a function of the current solution, current parameters, and current time. Throughout this tutorial these are denoted by u, p and t. Likewise, when a jump occurs any DifferentialEquations.jl-compatible change to the current system state, as encoded by a DifferentialEquations.jl integrator, is allowed. This includes changes to the current state or to parameter values (for example via a callback).","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"This tutorial requires several packages, which can be added if not already installed via","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"using Pkg\nPkg.add(\"JumpProcesses\")\nPkg.add(\"Plots\")","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"Let's also load our packages and set some defaults for our plot formatting","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"using JumpProcesses, Plots\ndefault(; lw = 2)","category":"page"},{"location":"tutorials/simple_poisson_process/#ConstantRateJumps","page":"Simple Poisson Processes in JumpProcesses","title":"ConstantRateJumps","text":"","category":"section"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"Our first example will be to simulate a simple Poisson counting process, N(t), with a constant transition rate of λ. We can interpret this as a birth process where new individuals are created at the constant rate λ. N(t) then gives the current population size. In terms of a unit Poisson counting process, Y_b(t), we have","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"N(t) = Y_bleft( lambda t right)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"(Here by a unit Poisson counting process we just mean a Poisson counting process with a constant rate of one.)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"In the remainder of this tutorial we will use transition rate, rate, propensity, and intensity interchangeably. Here is the full program listing, which we will subsequently explain line by line","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"using JumpProcesses, Plots\n\nrate(u, p, t) = p.λ\naffect!(integrator) = (integrator.u[1] += 1)\ncrj = ConstantRateJump(rate, affect!)\n\nu₀ = [0]\np = (λ = 2.0,)\ntspan = (0.0, 10.0)\n\ndprob = DiscreteProblem(u₀, tspan, p)\njprob = JumpProblem(dprob, Direct(), crj)\n\nsol = solve(jprob, SSAStepper())\nplot(sol, label = \"N(t)\", xlabel = \"t\", legend = :bottomright)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"We can define and simulate our jump process as follows. We first load our packages","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"using JumpProcesses, Plots","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"To specify our jump process, we need to define two functions. One that given the current state of the system, u, the parameters, p, and the time, t, can determine the current transition rate (intensity)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"rate(u, p, t) = p.λ","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"This corresponds to the instantaneous probability per time a jump occurs when the current state is u, current parameters are p, and the time is t. We also give a function that updates the system state when a jump is known to have occurred (at time integrator.t)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"affect!(integrator) = (integrator.u[1] += 1)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"Here, the convention is to take a DifferentialEquations.jl integrator, and directly modify the current solution value it stores. i.e., integrator.u is the current solution vector, with integrator.u[1] the first component of this vector. In our case, we will only have one unknown, so this will be the current value of the counting process. As our jump process's transition rate is constant between jumps, we can use a ConstantRateJump to encode it","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"crj = ConstantRateJump(rate, affect!)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"We then specify the parameters needed to simulate our jump process","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"# the initial condition vector, notice we make it an integer\n# since we have a discrete counting process\nu₀ = [0]\n\n# the parameters of the model, in this case a named tuple storing the rate, λ\np = (λ = 2.0,)\n\n# the time interval to solve over\ntspan = (0.0, 10.0)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"Finally, we construct the associated SciML problem types and generate one realization of the process. We first create a DiscreteProblem to encode that we are simulating a process that evolves in discrete time steps.","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"dprob = DiscreteProblem(u₀, tspan, p)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"We next create a JumpProblem that wraps the discrete problem, and specifies which algorithm, called an aggregator in JumpProcesses, to use for determining next jump times (and in the case of multiple possible jumps the next jump type). Here we use the classical Direct method, proposed by Gillespie in the chemical reaction context, but going back to earlier work by Doob and others (and also known as Kinetic Monte Carlo in the physics literature)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"# a jump problem, specifying we will use the Direct method to sample\n# jump times and events, and that our jump is encoded by crj\njprob = JumpProblem(dprob, Direct(), crj)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"We are finally ready to simulate one realization of our jump process, selecting SSAStepper to handle time-stepping our system from jump to jump","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"# now we simulate the jump process in time, using the SSAStepper time-stepper\nsol = solve(jprob, SSAStepper())\n\nplot(sol, labels = \"N(t)\", xlabel = \"t\", legend = :bottomright)","category":"page"},{"location":"tutorials/simple_poisson_process/#More-general-ConstantRateJumps","page":"Simple Poisson Processes in JumpProcesses","title":"More general ConstantRateJumps","text":"","category":"section"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"The previous counting process could be interpreted as a birth process, where new individuals were created with a constant transition rate λ. Suppose we also allow individuals to be killed with a death rate of μ. The transition rate at time t for some individual to die, assuming the deaths of individuals are independent, is just mu N(t). Suppose we also wish to keep track of the number of deaths, D(t), that have occurred. We can store these as an auxiliary variable in u[2]. Our processes are then given mathematically by","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"beginalign*\nN(t) = Y_b(lambda t) - Y_d left(int_0^t mu N(s^-)  ds right) \nD(t) = Y_d left(int_0^t mu N(s^-)  ds right)\nendalign*","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"where Y_d(t) denotes a second, independent, unit Poisson counting process.","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"We can encode this as a second jump for our system like","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"deathrate(u, p, t) = p.μ * u[1]\ndeathaffect!(integrator) = (integrator.u[1] -= 1; integrator.u[2] += 1)\ndeathcrj = ConstantRateJump(deathrate, deathaffect!)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"As the death rate is constant between jumps, we can encode this process as a second ConstantRateJump. We then construct the corresponding problems, passing both jumps to JumpProblem, and can solve as before","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"p = (λ = 2.0, μ = 1.5)\nu₀ = [0, 0]   # (N(0), D(0))\ndprob = DiscreteProblem(u₀, tspan, p)\njprob = JumpProblem(dprob, Direct(), crj, deathcrj)\nsol = solve(jprob, SSAStepper())\nplot(sol, labels = [\"N(t)\" \"D(t)\"], xlabel = \"t\", legend = :topleft)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"In the next tutorial, we will also introduce MassActionJumps, which are a special type of ConstantRateJumps that require a more specialized form of transition rate and state update, but can offer better computational performance. They can encode any mass action reaction, as commonly arise in chemical and population process models, and essentially require that rate(u,p,t) be a monomial in the components of u and state changes be given by adding or subtracting a constant vector from u.","category":"page"},{"location":"tutorials/simple_poisson_process/#VariableRateJumps-for-processes-that-are-not-constant-between-jumps","page":"Simple Poisson Processes in JumpProcesses","title":"VariableRateJumps for processes that are not constant between jumps","text":"","category":"section"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"So far, we have assumed that our jump processes have transition rates that are constant in between jumps. In many applications, this may be a limiting assumption. To support such models, JumpProcesses has the VariableRateJump type, which represents jump processes that have an arbitrary time dependence in the calculation of the transition rate, including transition rates that depend on states which can change in between two jumps occurring. Let's consider the previous example, but now let the birth rate be time-dependent, b(t) = lambda left(sin(pi t  2) + 1right), so that our model becomes","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"beginalign*\nN(t) = Y_bleft(int_0^t left( lambda sinleft(tfracpi s2right) + 1 right)  d sright) - Y_d left(int_0^t mu N(s^-)  ds right) \nD(t) = Y_d left(int_0^t mu N(s^-)  ds right)\nendalign*","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"The birth rate is cyclical, bounded between a lower-bound of λ and an upper-bound of 2 λ. We'll then re-encode the first (birth) jump as a VariableRateJump. Two types of VariableRateJumps are supported, general and bounded. The latter are generally more performant, but are also more restrictive in when they can be used. They also require specifying additional information beyond just rate and affect! functions.","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"Let's see how to build a bounded VariableRateJump encoding our new birth process. We first specify the rate and affect functions, just like for a ConstantRateJump,","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"rate1(u, p, t) = p.λ * (sin(pi * t / 2) + 1)\naffect1!(integrator) = (integrator.u[1] += 1)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"We next provide functions that determine a time interval over which the rate is bounded from above given u, p and t. From these, we can construct the new bounded VariableRateJump:","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"# We require that rate1(u,p,s) <= urate(u,p,s)\n# for t <= s <= t + rateinterval(u,p,t)\nrateinterval(u, p, t) = typemax(t)\nurate(u, p, t) = 2 * p.λ\n\n# Optionally, we can give a lower bound over the same interval.\n# This may boost computational performance.\nlrate(u, p, t) = p.λ\n\n# now we construct the bounded VariableRateJump\nvrj1 = VariableRateJump(rate1, affect1!; lrate, urate, rateinterval)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"Finally, to efficiently simulate the new jump process, we must also specify a dependency graph. This indicates when a given jump occurs, which jumps in the system need to have their rates and/or rate bounds recalculated (for example, due to depending on changed components in u). We also assume the convention that a given jump depends on itself. Internally, JumpProcesses preserves the relative ordering of jumps of each distinct type, but always reorders all ConstantRateJumps to appear before any VariableRateJumps. As such, the ConstantRateJump representing the death process will have internal index 1, and our new bounded VariableRateJump for birth will have internal index 2. Since birth modifies the population size u[1], and death occurs at a rate proportional to u[1], when birth occurs we need to recalculate both rates. In contrast, death does not change u[1], and so when death occurs we only need to recalculate the death rate. The graph below encodes the dependents of the death (dep_graph[1]) and birth (dep_graph[2]) jumps, respectively","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"dep_graph = [[1], [1, 2]]","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"We can then construct the corresponding problem, passing both jumps to JumpProblem as well as the dependency graph. We must use an aggregator that supports bounded VariableRateJumps, in this case we choose the Coevolve aggregator.","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"jprob = JumpProblem(dprob, Coevolve(), vrj1, deathcrj; dep_graph)\nsol = solve(jprob, SSAStepper())\nplot(sol, labels = [\"N(t)\" \"D(t)\"], xlabel = \"t\", legend = :topleft)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"If we did not know the upper rate bound or rate interval functions for the time-dependent rate, we would have to use a continuous problem type and general VariableRateJump to correctly handle calculating the jump times. Under this assumption, we would define a general VariableRateJump as following:","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"vrj2 = VariableRateJump(rate1, affect1!)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"Since the death rate now depends on a variable, u[2], modified by a general VariableRateJump (i.e., one that is not bounded), we also need to redefine the death jump process as a general VariableRateJump","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"deathvrj = VariableRateJump(deathrate, deathaffect!)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"To simulate our jump process, we now need to construct a continuous problem type to couple the jumps to, for example an ordinary differential equation (ODE) or stochastic differential equation (SDE). Let's use an ODE, encoded via an ODEProblem. We simply set the ODE derivative to zero to preserve the state. We are essentially defining a combined ODE-jump process, i.e., a piecewise deterministic Markov process, but one where the ODE is trivial and does not change the state. To use this problem type and the ODE solvers, we first load OrdinaryDiffEq.jl or DifferentialEquations.jl. If neither is installed, we first","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"using Pkg\nPkg.add(\"OrdinaryDiffEq\")\n# or Pkg.add(\"DifferentialEquations\")","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"and then load it via","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"using OrdinaryDiffEq\n# or using DifferentialEquations","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"We can then construct our ODE problem with a trivial ODE derivative component. Note, to work with the ODE solver time stepper we must also change our initial condition to be floating point valued","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"function f!(du, u, p, t)\n    du .= 0\n    nothing\nend\nu₀ = [0.0, 0.0]\noprob = ODEProblem(f!, u₀, tspan, p)\njprob = JumpProblem(oprob, Direct(), vrj2, deathvrj)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"We can now simulate our jump process, using the Tsit5 ODE solver as the time stepper, in place of SSAStepper","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"sol = solve(jprob, Tsit5())\nplot(sol, label = [\"N(t)\" \"D(t)\"], xlabel = \"t\", legend = :topleft)","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"For more details on when bounded vs. general VariableRateJumps can be used, see the next tutorial and the Jump Problems documentation page.","category":"page"},{"location":"tutorials/simple_poisson_process/#Having-a-Random-Jump-Distribution","page":"Simple Poisson Processes in JumpProcesses","title":"Having a Random Jump Distribution","text":"","category":"section"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"Suppose we want to simulate a compound Poisson process, G(t), where","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"G(t) = sum_i=1^N(t) C_i","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"with N(t) a Poisson counting process with constant transition rate lambda, and the C_i independent and identical samples from a uniform distribution over -11. We can simulate such a process as follows.","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"We first ensure that we use the same random number generator as JumpProcesses. We can either pass one as an input to JumpProblem via the rng keyword argument, and make sure it is the same one we use in our affect! function, or we can just use the default generator chosen by JumpProcesses if one is not specified, JumpProcesses.DEFAULT_RNG. Let's do the latter","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"rng = JumpProcesses.DEFAULT_RNG","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"Let's assume u[1] is N(t) and u[2] is G(t). We now proceed as in the previous examples","category":"page"},{"location":"tutorials/simple_poisson_process/","page":"Simple Poisson Processes in JumpProcesses","title":"Simple Poisson Processes in JumpProcesses","text":"rate3(u, p, t) = p.λ\n\n# define the affect function via a closure\naffect3! = integrator -> let rng = rng\n    # N(t) <-- N(t) + 1\n    integrator.u[1] += 1\n\n    # G(t) <-- G(t) + C_{N(t)}\n    integrator.u[2] += rand(rng, (-1, 1))\n    nothing\nend\ncrj = ConstantRateJump(rate3, affect3!)\n\nu₀ = [0, 0]\np = (λ = 1.0,)\ntspan = (0.0, 100.0)\ndprob = DiscreteProblem(u₀, tspan, p)\njprob = JumpProblem(dprob, Direct(), crj)\nsol = solve(jprob, SSAStepper())\nplot(sol, label = [\"N(t)\" \"G(t)\"], xlabel = \"t\")","category":"page"},{"location":"tutorials/discrete_stochastic_example/#ssa_tutorial","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"In this tutorial, we will describe how to define and simulate continuous-time jump (or point) processes, also known in biological fields as stochastic chemical kinetics (i.e., Gillespie) models. It is not necessary to have read the first tutorial. We will illustrate:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"The different types of jumps that can be represented in JumpProcesses and their use cases.\nHow to speed up pure-jump simulations with only ConstantRateJumps, MassActionJumps, and bounded VariableRateJumps by using the SSAStepper time stepper.\nHow to define and use MassActionJumps, a more specialized type of ConstantRateJump that offers improved computational performance.\nHow to define and use bounded VariableRateJumps in pure-jump simulations.\nHow to use saving controls to reduce memory use per simulation.\nHow to use general VariableRateJumps and when they should be preferred over the other jump types.\nHow to create hybrid problems, mixing the various jump types with ODEs or SDEs.\nHow to use RegularJumps to enable faster, but approximate, time stepping via τ-leaping methods.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"note: Note\nThis tutorial assumes you have read the Ordinary Differential Equations tutorial in DifferentialEquations.jl.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We begin by demonstrating how to build jump processes using JumpProcesses.jl's different jump types, which encode the rate functions (i.e., transition rates, intensities, or propensities) and state changes when a given jump occurs.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note, the SIR model considered here is a type of stochastic chemical kinetics jump process model, and as such the biological modeling functionality of Catalyst.jl can be used to easily specify the model and automatically calculate inputs needed for JumpProcesses's optimized simulation algorithms. We summarize this alternative approach at the beginning for users who may be interested in modeling chemical systems, but note this tutorial is intended to explain the general jump process formulation of JumpProcesses for all users. However, for those users constructing models that can be represented as a collection of chemical reactions we strongly recommend using Catalyst, which should ensure optimal jump types are selected to represent each reaction, and necessary data structures for the simulation algorithms, such as dependency graphs, are automatically calculated.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We'll make use of the DifferentialEquations.jl meta package, which includes JumpProcesses and ODE/SDE solvers, Plots.jl, and (optionally) Catalyst.jl in this tutorial. If not already installed, they can be added as follows:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using Pkg\nPkg.add(\"DifferentialEquations\")\nPkg.add(\"Plots\")\nPkg.add(\"Catalyst\")                # optional","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Let's now load the required packages and set some default plot settings","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using DifferentialEquations, Plots, LinearAlgebra\ndefault(; lw = 2)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using DifferentialEquations, Plots, LinearAlgebra\ndefault(; lw = 2)","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Illustrative-Model:-SIR-Disease-Dynamics","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Illustrative Model: SIR Disease Dynamics","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"To illustrate the jump process solvers, we will build an SIR model which matches the tutorial from Gillespie.jl. SIR stands for susceptible, infected, and recovered, and is a model of disease spread. When a susceptible person comes in contact with an infected person, the disease has a chance of infecting the susceptible person. This \"chance\" is determined by the number of susceptible persons and the number of infected persons, since in larger populations there is a greater chance that two people come into contact. Every infected person will in turn have a rate at which they recover. In our model, we'll assume there are no births or deaths, and a recovered individual is protected from reinfection.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We'll begin by giving the mathematical equations for the jump processes of the number of susceptible (S(t)), number of infected (I(t)), and number of recovered (R(t)). In the next section, we give a more intuitive and biological description of the model for users that are less familiar with jump processes. Let Y_i(t), i = 12, denote independent unit Poisson processes. Our basic mathematical model for the evolution of (S(t)I(t)R(t)), written using Kurtz's time-change representation, is then","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginaligned\nS(t) = S(0) - Y_1left(  int_0^t beta S(s^-) I(s^-)  dsright) \nI(t) = I(0) + Y_1left(  int_0^t beta S(s^-) I(s^-)  dsright)\n        - Y_2 left( int_0^t nu I(s^-)   ds right) \nR(t) = R(0) + Y_2 left( int_0^t nu I(s^-)   ds right)\nendaligned","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice, our model involves two jump processes with rate functions, also known as intensities or propensities, given by beta S(t) I(t) and nu I(t) respectively. These give the probability per time a new infected individual is created, and the probability per time some infected individual recovers.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"For those less-familiar with the time-change representation, we next give a more intuitive explanation of the model as a collection of chemical reactions, and then demonstrate how these reactions can be written in Catalyst.jl and seamlessly converted into a form that can be used with the JumpProcesses.jl solvers. Users interested in how to directly define jumps using the lower-level JumpProcesses interface can skip to Building and Simulating the Jump Process Using the JumpProcesses Low-Level Interface.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Specifying-the-SIR-Model-with-Chemical-Reactions","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Specifying the SIR Model with Chemical Reactions","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"The SIR model described above involves two basic chemical reactions,","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginaligned\nS + I oversetbetato 2 I \nI oversetnuto R\nendaligned","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"where beta and nu are the rate constants of the reactions (with units of probability per time). In a jump process (stochastic chemical kinetics) model, we keep track of the non-negative integer number of each species at each time (i.e., (S(t) I(t) R(t)) above). Each reaction has an associated rate function (i.e., intensity or propensity) giving the probability per time it can occur when the system is in state (S(t)I(t)R(t)):","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginmatrix\ntextReaction  textRate Functions \nhline\nS + I oversetbetato 2 I  beta S(t) I(t) \nI oversetnuto R  nu I(t)\nendmatrix","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beta is determined by factors like the type of the disease. It can be interpreted as the probability per time one pair of susceptible and infected people encounter each other, with the susceptible person becoming sick. The overall rate (i.e., probability per time) that some susceptible person gets sick is then given by the rate constant multiplied by the number of possible pairs of susceptible and infected people. This formulation is known as the law of mass action. Similarly, we have that each individual infected person is assumed to recover with probability per time nu, so that the probability per time some infected person recovers is nu times the number of infected people, i.e., nu I(t).","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Rate functions give the probability per time for each of the two types of jumps to occur, and hence determine when the state of our system changes. To fully specify our model, we also need to specify how the state changes when a jump occurs, giving what are called affect! functions in JumpProcesses. For example, when the S + I to 2 I reaction occurs, and some susceptible person becomes infected, the subsequent (instantaneous) state change is that","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginaligned\nS to S - 1  I to I + 1\nendaligned","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Likewise, when the I to R reaction occurs so that some infected person becomes recovered, the state change is","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginaligned\nI to I - 1  R to R + 1\nendaligned","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"In summary, our model is described by two chemical reactions, which each in turn correspond to a jump process determined by a rate function specifying how frequently jumps should occur, and an affect! function for how the state should change when that jump type occurs.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Building-and-Simulating-the-Jump-Processes-from-Catalyst-Models","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Building and Simulating the Jump Processes from Catalyst Models","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Using Catalyst.jl we can input our full reaction network in a form that can be easily used with JumpProcesses's solvers","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using Catalyst\nsir_model = @reaction_network begin\n    β, S + I --> 2I\n    ν, I --> R\nend","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"To build a pure jump process model of the reaction system, where the state is constant between jumps, we will use a DiscreteProblem. This encodes that the state only changes at the jump times. We do this by giving the constructor u₀, the initial condition, and tspan, the timespan. Here, we will start with 999 susceptible people, 1 infected person, and 0 recovered people, and solve the problem from t=0.0 to t=250.0. We use the parameters β = 0.1/1000 and ν = 0.01. Thus, we build the problem via:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"p = (:β => 0.1 / 1000, :ν => 0.01)\nu₀ = [:S => 999, :I => 10, :R => 0]\ntspan = (0.0, 250.0)\nprob = DiscreteProblem(sir_model, u₀, tspan, p)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice, the initial populations are integers, since we want the exact number of people in the different states.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"The Catalyst reaction network can be converted into various DifferentialEquations.jl problem types, including JumpProblems, ODEProblems, or SDEProblems. To turn it into a JumpProblem representing the SIR jump process model, we simply write","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump_prob = JumpProblem(sir_model, prob, Direct())","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Here Direct() indicates that we will determine the random times and types of reactions using Gillespie's Direct stochastic simulation algorithm (SSA), also known as Doob's method or Kinetic Monte Carlo. See Jump Aggregators for Exact Simulation for other supported SSAs.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We now have a problem that can be evolved in time using the JumpProcesses solvers. Since our model is a pure jump process (no continuously-varying components), we will use SSAStepper() to handle time-stepping the Direct method from jump to jump:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"sol = solve(jump_prob, SSAStepper())","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"This solve command takes the standard commands of the common interface, and the solution object acts just like any other differential equation solution. Thus, there exists a plot recipe, which we can plot with:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"plot(sol)","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Building-and-Simulating-the-Jump-Process-Using-the-JumpProcesses-Low-Level-Interface","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Building and Simulating the Jump Process Using the JumpProcesses Low-Level Interface","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We now show how to directly use JumpProcesses's low-level interface to construct and solve our jump process model for (S(t)I(t)R(t)). Each individual jump that can occur is represented through specifying two pieces of information; a rate function (i.e., intensity or propensity) for the jump and an affect! function for the jump. The former gives the probability per time a particular jump can occur given the current state of the system, and hence determines the time at which jumps can happen. The latter specifies the instantaneous change in the state of the system when the jump occurs.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"In our SIR model, we have two possible jumps that can occur (one for susceptibles becoming infected and one for infected becoming recovered), with the corresponding (mathematical) rates and affects given by","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beginmatrix\ntextRates  textAffects\nhline\nbeta S(t) I(t)  S to S - 1 I to I + 1 \nnu I(t)  I to I - 1  R to R + 1\nendmatrix","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"JumpProcesses offers three different ways to (exactly) represent jumps: MassActionJump, ConstantRateJump, and VariableRateJump. Choosing which to use is a trade-off between the desired generality of the rate and affect! functions vs. the computational performance of the resulting simulated system. In general","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Jump Type Performance Generality\nMassActionJump Fastest Restrictive rates/affects\nConstantRateJump Somewhat Slower than MassActionJump Rate function must be constant between jumps\nVariableRateJump with rate bounds Somewhat Slower than ConstantRateJump Rate functions can explicitly depend on time, but require an upper bound that is guaranteed constant between jumps over some time interval\nVariableRateJump Slowest Completely general","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"It is recommended to try to encode jumps using the most performant option that supports the desired generality of the underlying rate and affect! functions. Below we describe the different jump types, and show how the SIR model can be formulated using first ConstantRateJumps, then more performant MassActionJumps, and finally with VariableRateJumps using rate bounds. We conclude by presenting several completely general models that use VariableRateJumps without rate bounds, and which require an ODE solver to handle time-stepping.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We note, in the remainder we will refer to bounded VariableRateJumps as those for which we can specify functions calculating a time window over which the rate is bounded by a constant (as long as the state is unchanged), see the section on bounded VariableRateJumps for details. VariableRateJumps or general VariableRateJumps will refer to those for which such functions are not available.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#ConstantRateJumpSect","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Defining the Jumps Directly: ConstantRateJump","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"The constructor for a ConstantRateJump is:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump = ConstantRateJump(rate, affect!)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"where rate is a function rate(u,p,t) and affect! is a function of the integrator affect!(integrator) (for details on the integrator, see the integrator interface docs). Here u corresponds to the current state vector of the system; for our SIR model u[1] = S(t), u[2] = I(t) and u[3] = R(t). p corresponds to the parameters of the model, just as used for passing parameters to derivative functions in ODE solvers. Thus, to define the two possible jumps for our model, we take (with β = .1/1000.0 and ν = .01).","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"β = 0.1 / 1000.0\nν = 0.01;\np = (β, ν)\nrate1(u, p, t) = p[1] * u[1] * u[2]  # β*S*I\nfunction affect1!(integrator)\n    integrator.u[1] -= 1         # S -> S - 1\n    integrator.u[2] += 1         # I -> I + 1\n    nothing\nend\njump = ConstantRateJump(rate1, affect1!)\n\nrate2(u, p, t) = p[2] * u[2]         # ν*I\nfunction affect2!(integrator)\n    integrator.u[2] -= 1        # I -> I - 1\n    integrator.u[3] += 1        # R -> R + 1\n    nothing\nend\njump2 = ConstantRateJump(rate2, affect2!)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We will start with 999 susceptible people, 1 infected person, and 0 recovered people, and solve the problem from t=0.0 to t=250.0 so that","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"u₀ = [999, 10, 0]\ntspan = (0.0, 250.0)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice, the initial populations are integers, since we want the exact number of people in the different states.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Since we want the system state to change only at the discrete jump times, we will build a DiscreteProblem","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"prob = DiscreteProblem(u₀, tspan, p)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We can then use JumpProblem from JumpProcesses to augment the discrete problem with jumps and select the stochastic simulation algorithm (SSA) to use in sampling the jump processes. To create a JumpProblem we would simply do:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump_prob = JumpProblem(prob, Direct(), jump, jump2)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Here Direct() indicates that we will determine the random times and types of jumps that occur using Gillespie's Direct stochastic simulation algorithm (SSA), also known as Doob's method or Kinetic Monte Carlo. See Jump Aggregators for Exact Simulation for other supported SSAs.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We now have a problem that can be evolved in time using the JumpProcesses solvers. Since our model is a pure jump process with all rates being constant in between jumps (i.e., no continuously-varying components), we will use SSAStepper to handle time-stepping the Direct method from jump to jump:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"sol = solve(jump_prob, SSAStepper())","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"This solve command takes the standard commands of the common interface, and the solution object acts just like any other differential equation solution. Thus there exists a plot recipe, which we can plot with:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"plot(sol, label = [\"S(t)\" \"I(t)\" \"R(t)\"])","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note, in systems with more than a few jumps (more than ~10), it can be advantageous to use more sophisticated SSAs than Direct. For such systems it is recommended to use SortingDirect, RSSA or RSSACR, see the list of JumpProcesses SSAs at Jump Aggregators for Exact Simulation.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#SSAStepper","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"SSAStepper","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Any common interface algorithm can be used to perform the time-stepping, since it is implemented over the callback interface. This allows for hybrid systems that mix ODEs, SDEs and jumps. In many cases, we may have a pure jump system that only involves ConstantRateJumps, MassActionJumps, and/or bounded VariableRateJumps (see below). In those cases, a substantial performance benefit may be gained by using SSAStepper. Note, SSAStepper is a more limited time-stepper which only supports discrete events, and does not allow simultaneous coupled ODEs/SDEs, or general VariableRateJumps. It is, however, very efficient for pure jump problems involving only ConstantRateJumps, MassActionJumps, and bounded VariableRateJumps.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#MassActionJumpSect","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Defining the Jumps Directly: MassActionJump","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"For ConstantRateJumps that can be represented as mass action reactions a further specialization of the jump type is possible that offers improved computational performance; MassActionJump. Suppose the system has N chemical species S_1dotsS_N. A general mass action reaction has the form","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"R_1 S_1 + R_2 S_2 + dots + R_N S_N oversetkrightarrow P_1 S_1 + P_2 S_2 + dots + P_N S_N","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"where the non-negative integers (R_1dotsR_N) denote the reactant stoichiometry of the reaction, and the non-negative integers (P_1dotsP_N) the product stoichiometry. The net stoichiometry is the net change in each chemical species from the reaction occurring one time, given by mathbfnu = (P_1-R_1dotsP_N-R_N). As such, the affect! function associated with a MassActionJump simply changes the state, mathbfu(t) = (u_1(t)dotsu_N(t)), by updating","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"mathbfu(t) to mathbfu(t) + mathbfnu","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"The default rate function, ρ = rate(u,p,t), is based on stochastic chemical kinetics and given by","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"ρ(mathbfu(t)) = k prod_i=1^N beginpmatrix u_i  R_i endpmatrix\n= k prod_i=1^N fracu_iR_i (u_i - R_i)\n= k prod_i=1^N fracu_i (u_i - 1) cdots (u_i - R_i + 1)R_i","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"where k denotes the rate constant of the reaction (in units of per time).","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"As an example, consider again the SIR model. The species are u = (S,I,R). The first reaction has rate β, reactant stoichiometry (1, 1, 0), product stoichiometry (0, 2, 0), and net stoichiometry (-1, 1, 0). The second reaction has rate ν, reactant stoichiometry (0, 1, 0), product stoichiometry (0, 0, 1), and net stoichiometry (0, -1, 1).","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We can manually encode this system as a mass action jump by specifying the indexes of the rate constants in p, the reactant stoichiometry, and the net stoichiometry. We note that the first two determine the rate function, with the latter determining the affect function.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"rateidxs = [1, 2]           # i.e., [β, ν]\nreactant_stoich = [\n    [1 => 1, 2 => 1],         # 1*S and 1*I\n    [2 => 1],                  # 1*I\n]\nnet_stoich = [\n    [1 => -1, 2 => 1],        # -1*S and 1*I\n    [2 => -1, 3 => 1],         # -1*I and 1*R\n]\nmass_act_jump = MassActionJump(reactant_stoich, net_stoich; param_idxs = rateidxs)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice, one typically should define one MassActionJump that encodes each possible jump that can be represented via a mass action reaction. This contrasts with ConstantRateJumps or VariableRateJumps where separate instances are created for each distinct jump type.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Just like for ConstantRateJumps, to then simulate the system we create a JumpProblem and call solve:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump_prob = JumpProblem(prob, Direct(), mass_act_jump)\nsol = solve(jump_prob, SSAStepper())\nplot(sol; label = [\"S(t)\" \"I(t)\" \"R(t)\"])","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"For more details about MassActionJumps see Defining a Mass Action Jump. We note that one could include the factors of 1  R_i directly in the rate constant passed into a MassActionJump, so that the desired rate function that gets evaluated is","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"hatk prod_i=1^N u_i (u_i - 1) cdots (u_i - R_i + 1)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"with hatk = k  prod_i=1^N R_i the renormalized rate constant. Passing the keyword argument scale_rates = false will disable MassActionJumps internally rescaling the rate constant by (prod_i=1^N R_i)^-1.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"For chemical reaction systems Catalyst.jl automatically groups reactions into their optimal jump representation.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#*Caution-about-ConstantRateJumps-and-MassActionJumps*","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Caution about ConstantRateJumps and MassActionJumps","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"ConstantRateJumps and MassActionJumps are restricted in that they assume the rate functions are constant at all times between two consecutive jumps of the system. That is, any species/states or parameters that a rate function depends on must not change between the times at which two consecutive jumps occur. Such conditions are violated if one has a time-dependent parameter like beta(t) or if some solution components, say u[2], may also evolve through a coupled ODE, SDE, or a general VariableRateJump (see below for examples). For problems where the rate function may change between consecutive jumps, bounded or general VariableRateJumps must be used.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Thus, in the examples above,","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"rate1(u, p, t) = p[1] * u[1] * u[2]\nrate2(u, p, t) = p[2] * u[2]","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"both must be constant, besides changes due to some other ConstantRateJump or MassActionJump (the same restriction applies to MassActionJumps). Since these rates only change when u[1] or u[2] is changed, and u[1] and u[2] only change when one of the jumps occur, this setup is valid. However, a rate of t*p[1]*u[1]*u[2] would not be valid because the rate would change in between jumps, as would p[2]*u[1]*u[4] when u[4] is the solution to a continuous problem such as an ODE/SDE, or can be changed by a general VariableRateJump. Thus, one must be careful to follow this rule when choosing rates.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"In summary, if a particular jump process has a rate function that depends explicitly or implicitly on a continuously changing quantity, you need to use a VariableRateJump.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#VariableRateJumpWithBnds","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Defining the Jumps Directly using a bounded VariableRateJump","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Assume that the infection rate is now decreasing over time. That is, when individuals get infected, they immediately reach peak infectivity. The force of infection then decreases exponentially to a basal level. In this case, we must keep track of the time of infection events. Let the history H(t) contain the timestamps of all I(t) active infections. The rate of infection is then","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"beta_1 S(t) I(t) + alpha S(t) sum_t_i in H(t) exp(-gamma (t - t_i))","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"where beta_1 is the basal rate of infection, alpha is the spike in the rate of infection, and gamma is the rate at which the spike decreases. Here, we choose parameters such that infectivity rate due to a single infected individual returns to the basal rate after spiking to beta_1 + alpha. In other words, we are modelling a situation in infected individuals gradually become less infectious prior to recovering. Our parameters are then","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"β1 = 0.001 / 1000.0\nα = 0.1 / 1000.0\nγ = 0.05\np1 = (β1, ν, α, γ)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We define a vector H to hold the timestamp of active infections. Then, we define an infection reaction as a bounded VariableRateJump, requiring us to again provide rate and affect functions, but also give functions that calculate an upper-bound on the rate (urate(u,p,t)), an optional lower-bound on the rate (lrate(u,p,t)), and a time window over which the bounds are valid as long as any states these three rates depend on are unchanged (rateinterval(u,p,t)). The lower- and upper-bounds of the rate should be valid from the time they are computed t until t + rateinterval(u, p, t):","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"H = zeros(Float64, 10)\nrate3(u, p, t) = p[1] * u[1] * u[2] + p[3] * u[1] * sum(exp(-p[4] * (t - _t)) for _t in H)\nlrate = rate1              # β*S*I\nurate = rate3\nrateinterval(u, p, t) = 1 / (2 * urate(u, p, t))\nfunction affect3!(integrator)\n    integrator.u[1] -= 1     # S -> S - 1\n    integrator.u[2] += 1     # I -> I + 1\n    push!(H, integrator.t)\n    nothing\nend\njump3 = VariableRateJump(rate3, affect3!; lrate, urate, rateinterval)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note that here we set the lower bound rate to be the normal SIR infection rate, and set the upper bound rate equal to the new rate of infection (rate3). As required for bounded VariableRateJumps, we have for any s in [t,t + rateinterval(u,p,t)] the bound lrate(u,p,t) <= rate3(u,p,s) <= urate(u,p,t) will hold provided the dependent states u[1] and u[2] have not changed.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Next, we redefine the recovery jump's affect! such that a random infection is removed from H for every recovery.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"rate4(u, p, t) = p[2] * u[2]         # ν*I\nfunction affect4!(integrator)\n    integrator.u[2] -= 1\n    integrator.u[3] += 1\n    length(H) > 0 && deleteat!(H, rand(1:length(H)))\n    nothing\nend\njump4 = ConstantRateJump(rate4, affect4!)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"With the jumps defined, we can build a DiscreteProblem. Bounded VariableRateJumps over a DiscreteProblem can currently only be simulated with Coevolve. The aggregator requires a dependency graph to indicate when a given jump occurs and which other jumps in the system should have their rate recalculated (i.e., their rate depends on states modified by one occurrence of the first jump). This ensures that rates, rate bounds, and rate intervals are recalculated when invalidated due to changes in u. For the current example, both processes mutually affect each other, so we have","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"dep_graph = [[1, 2], [1, 2]]","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Here dep_graph[2] = [1,2] indicates that when the second jump occurs, both the first and second jumps need to have their rates recalculated. We can then construct our JumpProblem as before, specifying the Coevolve aggregator:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"prob = DiscreteProblem(u₀, tspan, p1)\njump_prob = JumpProblem(prob, Coevolve(), jump3, jump4; dep_graph)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We now have a problem that can be solved with SSAStepper to handle time-stepping the Coevolve aggregator from jump to jump:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"sol = solve(jump_prob, SSAStepper())\nplot(sol, label = [\"S(t)\" \"I(t)\" \"R(t)\"])","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We see that the time-dependent infection rate leads to a lower peak of the infection throughout the population.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note that bounded VariableRateJumps over DiscreteProblems can be quite general. However, when handling rates that change according to an ODE/SDE modified variable we will need a continuous integrator. One example is discussed below in which we have a new reaction added to the model with rate p[2]*u[1]*u[4] where u[4] is the solution of an ODE. In such models, you will also need to be more careful in setting rate bounds as they must be valid for the full coupled system's dynamics.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#save_positions_docs","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Reducing Memory Use: Controlling Saving Behavior","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note that jumps act via DifferentialEquations.jl's callback interface, which defaults to saving at each event. This is required in order to accurately resolve every discontinuity exactly (and this is what allows for perfectly vertical lines in plots!). However, in many cases when using jump problems, you may wish to decrease the saving pressure given by large numbers of jumps. To do this, you set the save_positions keyword argument to JumpProblem. Just like for other callbacks, this is a tuple (bool1, bool2) which sets whether to save before or after a jump. If we do not want to save at every jump, we would thus pass:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"prob = DiscreteProblem(u₀, tspan, p)\njump_prob = JumpProblem(prob, Direct(), jump, jump2; save_positions = (false, false))","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Now the saving controls associated with the integrator should be specified, see the main SciML Docs for saving options. For example, we can use saveat = 10.0 to save at an evenly spaced grid:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"sol = solve(jump_prob, SSAStepper(); saveat = 10.0)\n\n# we plot each solution component separately since\n# the graph should no longer be a step function\nplot(sol.t, sol[1, :]; marker = :o, label = \"S(t)\", xlabel = \"t\")\nplot!(sol.t, sol[2, :]; marker = :x, label = \"I(t)\", xlabel = \"t\")\nplot!(sol.t, sol[3, :]; marker = :d, label = \"R(t)\", xlabel = \"t\")","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice that our plot (and solutions) are now defined at precisely the specified time points. It is important to note that interpolation of the solution object will no longer be exact for a pure jump process, as the solution values at jump times have not been stored. i.e for t a time we did not save at sol(t) will no longer give the exact value of the solution at t.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Defining-the-Jumps-Directly:-Mixing-ConstantRateJump/VariableRateJump-and-MassActionJump","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Defining the Jumps Directly: Mixing ConstantRateJump/VariableRateJump and MassActionJump","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Suppose we now want to add in to the original SIR model another jump that cannot be represented as a mass action reaction. We can create a new ConstantRateJump and simulate a hybrid system using both the MassActionJump for the two original reactions, and the new ConstantRateJump. Let's suppose we want to let susceptible people be born with the following jump rate:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"birth_rate(u, p, t) = 10.0 * u[1] / (200.0 + u[1]) + 10.0\nfunction birth_affect!(integrator)\n    integrator.u[1] += 1\n    nothing\nend\nbirth_jump = ConstantRateJump(birth_rate, birth_affect!)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We can then simulate the hybrid system as","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump_prob = JumpProblem(prob, Direct(), mass_act_jump, birth_jump)\nsol = solve(jump_prob, SSAStepper())\nplot(sol; label = [\"S(t)\" \"I(t)\" \"R(t)\"])","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note that we can combine MassActionJumps, ConstantRateJumps and bounded VariableRateJumps using the Coevolve aggregators.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#Adding-Jumps-to-a-Differential-Equation","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Adding Jumps to a Differential Equation","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"If we instead used some form of differential equation via an ODEProblem instead of a DiscreteProblem, we can couple the jumps/reactions to the differential equation. Let's define an ODE problem, where the continuous part only acts on some new 4th component:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using OrdinaryDiffEq\nfunction f(du, u, p, t)\n    du[4] = u[2] * u[3] / 1e5 - u[1] * u[4] / 1e5\n    nothing\nend\nu₀ = [999.0, 10.0, 0.0, 100.0]\nprob = ODEProblem(f, u₀, tspan, p)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice we gave the 4th component a starting value of 100.0, and used floating-point numbers for the initial condition, since some solution components now evolve continuously. The same steps as above will allow us to solve this hybrid equation when using ConstantRateJumps, MassActionJumps, or VariableRateJumps. For example, we can solve it using the Tsit5() method via:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump_prob = JumpProblem(prob, Direct(), jump, jump2)\nsol = solve(jump_prob, Tsit5())\nplot(sol; label = [\"S(t)\" \"I(t)\" \"R(t)\" \"u₄(t)\"])","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note that in general, the ODE derivative f(du, u, p, t) could modify any element in du which the jump rate functions depend on. In this section, f(du, u, p, t) does not modify the jump rates so it is safe to couple them with any type of jump and use any type of aggregator. However, the implementation does not enforce this requirement, so one must be careful. Alternatively, when f(du, u, p, t) does modify variables that affect the jump rate, we have to implement another strategy as described in the next [next Section](@ref VariableRateJumpSect].","category":"page"},{"location":"tutorials/discrete_stochastic_example/#VariableRateJumpSect","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Adding a general VariableRateJump that Depends on a Continuously Evolving Variable","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Now let's consider adding a reaction whose rate changes continuously with the differential equation. To continue our example, let there be a new reaction with rate depending on u[4] of the form u_4 to u_4 + textrmI, with a rate constant of 1e-2:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"rate5(u, p, t) = 1e-2 * u[4]\nfunction affect5!(integrator)\n    integrator.u[2] += 1    # I -> I + 1\n    nothing\nend\njump5 = VariableRateJump(rate5, affect5!)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Notice, since rate5 depends on a variable that evolves continuously, and hence is not constant between jumps, we must either use a general VariableRateJump without upper/lower bounds or a bounded VariableRateJump.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"In the general case, solving the equation is exactly the same:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"u₀ = [999.0, 10.0, 0.0, 1.0]\nprob = ODEProblem(f, u₀, tspan, p)\njump_prob = JumpProblem(prob, Direct(), jump, jump2, jump5)\nsol = solve(jump_prob, Tsit5())\nplot(sol; label = [\"S(t)\" \"I(t)\" \"R(t)\" \"u₄(t)\"])","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note that general VariableRateJumps require using a continuous problem, like an ODE/SDE/DDE/DAE problem, and using floating point initial conditions.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Alternatively, the case of bounded VariableRateJump requires some maths. First, we need to obtain the upper bounds of rate5 at time t given u. Note that rate5 evolves according to u[4] which is a separable first order differential equation of the form x = b - a x with general solution:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"x(t) = - frace^-a t - c_1 aa + fracba","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"This is bounded by b  a which is too high for our purposes since it would lead to a high rate of rejection during sampling. However, since the function is increasing we can compute the upper bound given an interval Delta t as following:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"barx(s) = x(t)  e^-a (t + Delta t) + fracba (1 - e^- a (t + Delta t)) text   forall s in t t + Delta t","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"However, when a = 0 the differential equation becomes x = b whose solution is x(t) = b t. In which case, we obtain a different upper bound given by:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"barx(s) = x(t) + b * (t + Delta t) text   forall s in t t + Delta t","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"These expressions allow us to write the upper-bound and the rate interval in Julia. In this example we use analytical boundaries for illustration purposes. However, in some circumstances with complex model of many variables it can be difficult to determine good a priori bounds on the ODE variables. Moreover, numerical and analytical solutions are generally not guaranteed to strictly satisfy the same bounds. In most cases the bounds should be close enough. Thus, consider adding some slack on the bounds and approach complex models with care.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"function urate2(u, p, t)\n    if u[1] > 0\n        1e-2 * max(u[4],\n            (u[4] * exp(-1 * u[1] / 1e5) +\n             (u[2] * u[3] / u[1]) * (1 - exp(-1 * u[1] / 1e5))))\n    else\n        1e-2 * (u[4] + 1 * u[2] * u[3] / 1e5)\n    end\nend\nrateinterval2(u, p, t) = 1","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We can then formulate the jump problem. The only aggregator that supports bounded VariableRateJumps is Coevolve. We formulate and solve the jump problem with this aggregator. Coevolve can be formulated as either a discrete or continuous problem. In this case, we must formulate the problem as continuous as it depends on a continuous variable.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"jump6 = VariableRateJump(rate5, affect5!; urate = urate2, rateinterval = rateinterval2)\ndep_graph2 = [[1, 2, 3], [1, 2, 3], [1, 2, 3]]\njump_prob = JumpProblem(prob, Coevolve(), jump, jump2, jump6; dep_graph = dep_graph2)\nsol = solve(jump_prob, Tsit5())\nplot(sol; label = [\"S(t)\" \"I(t)\" \"R(t)\" \"u₄(t)\"])","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We obtain the same solution as with Direct, but Coevolve runs faster because it doesn't need to compute the derivative of rate5. Each aggregator faces a different trade-off, so the the choice of best aggregator will depend on the problem at hand. Coevolve requires a good understanding of the equations involved, passing a wrong boundary can result in silent bugs.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Lastly, we are not restricted to ODEs. For example, we can solve the same jump problem except with multiplicative noise on u[4] by using an SDEProblem instead:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"using StochasticDiffEq\nfunction g(du, u, p, t)\n    du[4] = 0.1u[4]\nend\nprob = SDEProblem(f, g, [999.0, 1.0, 0.0, 1.0], (0.0, 250.0), p)\njump_prob = JumpProblem(prob, Direct(), jump, jump2, jump5)\nsol = solve(jump_prob, SRIW1())\nplot(sol; label = [\"S(t)\" \"I(t)\" \"R(t)\" \"u₄(t)\"])","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"For more details about general VariableRateJumps see Defining a Variable Rate Jump.","category":"page"},{"location":"tutorials/discrete_stochastic_example/#RegularJumps-and-τ-Leaping","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"RegularJumps and τ-Leaping","text":"","category":"section"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"The previous parts described how to use ConstantRateJumps, MassActionJumps, and VariableRateJumps. However, in many cases one does not require the exactness of stepping to every jump time. Instead, regular jumping (i.e., τ-leaping) allows pooling jumps together, and performing larger updates in a statistically-correct but more efficient manner. The trade-off is the introduction of a time-discretization error due to the time-stepping, but one that is controlled and convergent as the time-step is reduced to zero.","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Let's see how to define the SIR model in terms of a RegularJump. We need two functions, rate and change!. rate is a vector equation which computes the rates of each jump process","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"function rate(out, u, p, t)\n    out[1] = p[1] * u[1] * u[2]   # β * S * I\n    out[2] = p[2] * u[2]          # ν * I\n    nothing\nend","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We then define a function that given a vector storing the number of times each jump occurs during a time-step, counts, calculates the change in the state, du. For the SIR example, we do this by multiplying counts by a matrix that encodes the change in the state due to one occurrence of each reaction (i.e., the net stoichiometry matrix). Below c[i,j] gives the change in u[i] due to the jth jump:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"c = zeros(3, 2)\n# S + I --> I\nc[1, 1] = -1    # S -> S - 1\nc[2, 1] = 1     # I -> I + 1\n\n# I --> R\nc[2, 2] = -1    # I -> I - 1\nc[3, 2] = 1     # R -> R + 1\n\nfunction change(du, u, p, t, counts, mark)\n    mul!(du, c, counts)\n    nothing\nend","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"We are now ready to create our RegularJump, passing in the rate function, change function, and the number of jumps being encoded","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"rj = RegularJump(rate, change, 2)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"From there we build a JumpProblem","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"u₀ = [1000.0, 50.0, 0.0]\nprob = DiscreteProblem(u₀, tspan, p)\njump_prob = JumpProblem(prob, Direct(), rj)","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"Note that when a JumpProblem has a RegularJump, τ-leaping algorithms are required for simulating it. This is detailed on the jump solvers page. One such algorithm is TauLeaping from StochasticDiffEq.jl, which we use as follows:","category":"page"},{"location":"tutorials/discrete_stochastic_example/","page":"Continuous-Time Jump Processes and Gillespie Methods","title":"Continuous-Time Jump Processes and Gillespie Methods","text":"sol = solve(jump_prob, TauLeaping(); dt = 0.001)\nplot(sol; label = [\"S(t)\" \"I(t)\" \"R(t)\"])","category":"page"},{"location":"tutorials/jump_diffusion/#jump_diffusion_tutorial","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"","category":"section"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"note: Note\nThis tutorial assumes you have read the Ordinary Differential Equations tutorial in DifferentialEquations.jl.","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Jump Diffusion equations are stochastic differential equations with discontinuous jumps. These can be written as:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"du = f(upt)dt + sum_jg_j(upt)dW_j(t) + sum_ih_i(upt)dN_i(t)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"where N_i is a Poisson-counter which denotes jumps of size h_i. In this tutorial, we will show how to solve problems with even more general jumps. In the special case that g_j = 0 for all j, we'll call the resulting jump-ODE a piecewise deterministic Markov process.","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Before running this tutorial, please install the following packages if they are not already installed","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"using Pkg\nPkg.add(\"DifferentialEquations\")\nPkg.add(\"Plots\")","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"DifferentialEquations.jl will install JumpProcesses, along with the needed ODE and SDE solvers.","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"We then load these packages, and set some plotting defaults, as","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"using DifferentialEquations, Plots\ndefault(; lw = 2)","category":"page"},{"location":"tutorials/jump_diffusion/#Defining-a-ConstantRateJump-Problem","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Defining a ConstantRateJump Problem","text":"","category":"section"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"To start, let's solve an ODE that is coupled to a ConstantRateJump. A jump is defined as being \"constant rate\" if the rate is only dependent on values from other ConstantRateJumps or MassActionJumps (a special type of ConstantRateJump). This means that its rate must not be coupled with time, the solution to the differential equation, or a solution component that is changed by a VariableRateJump. ConstantRateJumps are cheaper to compute than VariableRateJumps, and so should be preferred when mathematically appropriate.","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"(Note: if your rate is only \"slightly\" dependent on the solution of the differential equation, then it may be okay to use a ConstantRateJump. Accuracy loss will be related to the percentage that the rate changes over the jump intervals.)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Let's solve the following problem. We will have a linear ODE with a Poisson counter of rate 2 (which is the mean and variance), where at each jump the current solution will be halved. To solve this problem, we first define the ODEProblem:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"function f(du, u, p, t)\n    du[1] = u[1]\n    nothing\nend\n\nprob = ODEProblem(f, [0.2], (0.0, 10.0))","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Notice that, even though our equation is scalar, we define it using the in-place array form. Variable rate jump equations will require this form. Note that for this tutorial, we solve a one-dimensional problem, but the same syntax applies for solving a system of differential equations with multiple jumps.","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Now we define our rate equation for our jump. Since it's just the constant value 2, we do:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"rate(u, p, t) = 2","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Now we define the affect! of the jump. This is the same as an affect! from a DiscreteCallback, and thus acts directly on the integrator. Therefore, to make it halve the current value of u, we do:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"function affect!(integrator)\n    integrator.u[1] = integrator.u[1] / 2\n    nothing\nend","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Then we build our jump:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"jump = ConstantRateJump(rate, affect!)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Next, we extend our ODEProblem to a JumpProblem by attaching the jump:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"jump_prob = JumpProblem(prob, Direct(), jump)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"We can now solve this extended problem using any ODE solver:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"sol = solve(jump_prob, Tsit5())\nplot(sol)","category":"page"},{"location":"tutorials/jump_diffusion/#Variable-Rate-Jumps","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Variable Rate Jumps","text":"","category":"section"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Now let's define a jump with a rate that is dependent on the differential equation via the solution vector. Let's set the rate to be the current value of the solution, that is:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"rate(u, p, t) = u[1]","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Using the same affect! we build a VariableRateJump:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"jump = VariableRateJump(rate, affect!)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"To make things interesting, let's copy this jump:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"jump2 = deepcopy(jump)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"so that way we have two independent jump processes. We now couple these jumps to the ODEProblem:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"jump_prob = JumpProblem(prob, Direct(), jump, jump2)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"which we once again solve using an ODE solver:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"sol = solve(jump_prob, Tsit5())\nplot(sol)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"In this way we have solved a mixed jump-ODE, i.e., a piecewise deterministic Markov process.","category":"page"},{"location":"tutorials/jump_diffusion/#Jump-Diffusion","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Jump Diffusion","text":"","category":"section"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"Now we will finally solve the jump diffusion problem. The steps are the same as before, except we now start with a SDEProblem instead of an ODEProblem. Using the same drift function f as before, we add multiplicative noise via:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"function g(du, u, p, t)\n    du[1] = u[1]\n    nothing\nend\n\nprob = SDEProblem(f, g, [0.2], (0.0, 10.0))","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"and couple it to the jumps:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"jump_prob = JumpProblem(prob, Direct(), jump, jump2)","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"We then solve it using an SDE algorithm:","category":"page"},{"location":"tutorials/jump_diffusion/","page":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","title":"Piecewise Deterministic Markov Processes and Jump Diffusion Equations","text":"sol = solve(jump_prob, SRIW1())\nplot(sol)","category":"page"},{"location":"jump_types/#jump_problem_type","page":"Jump types and JumpProblem","title":"Jump Problems","text":"","category":"section"},{"location":"jump_types/#Mathematical-Specification-of-a-problem-with-jumps","page":"Jump types and JumpProblem","title":"Mathematical Specification of a problem with jumps","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Jumps (or point) processes are stochastic processes with discrete state changes driven by a rate function. The homogeneous Poisson process is the canonical point process with a constant rate of change. Processes involving multiple jumps are known as compound jump (or point) processes.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"A compound Poisson process is a continuous-time Markov Chain where the time to the next jump is exponentially distributed as determined by the rate. Simulation algorithms for these types of processes are known in biology and chemistry as Gillespie methods or Stochastic Simulation Algorithms (SSA), with the time evolution that the probability these processes are in a given state at a given time satisfying the Chemical Master Equation (CME). In the statistics literature, the composition of Poisson processes is described by the superposition theorem.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Any differential equation can be extended by jumps. For example, we have an ODE with jumps, denoted by","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"fracdudt = f(upt) + sum_ic_i(upt)p_i(t)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"where p_i is a Poisson counter of rate lambda_i(upt). Extending a stochastic differential equation to have jumps is commonly known as a Jump Diffusion, and is denoted by","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"du(t) = f(upt)dt + sum_jg_j(ut)dW_j(t) + sum_ic_i(upt)dp_i(t)","category":"page"},{"location":"jump_types/#Types-of-Jumps:-Constant-Rate,-Mass-Action,-Variable-Rate-and-Regular","page":"Jump types and JumpProblem","title":"Types of Jumps: Constant Rate, Mass Action, Variable Rate and Regular","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Exact jump process simulation algorithms tend to describe the realization of each jump event chronologically. Individual jumps are usually associated with changes to the state variable u, which in turn changes the rates at which jump events occur. These jumps can be specified as a ConstantRateJump, MassActionJump, or a VariableRateJump.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Each individual type of jump that can occur is represented through (implicitly or explicitly) specifying two pieces of information; a rate function (i.e., intensity or propensity) for the jump and an affect! function for the jump. The former gives the probability per time a particular jump can occur given the current state of the system, and hence determines the time at which jumps can happen. The latter specifies the instantaneous change in the state of the system when the jump occurs.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"A specific jump type is a VariableRateJump if its rate function is dependent on values which may change between the occurrence of any two jump events of the process. Examples include jumps where the rate is an explicit function of time, or depends on a state variable that is modified via continuous dynamics such as an ODE or SDE. Such \"general\" VariableRateJumps can be expensive to simulate because it is necessary to consider the (possibly continuous) changes in the rate function when calculating the next jump time.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Bounded VariableRateJumps represent a special subset of VariableRateJumps where one can specify functions that calculate a time window over which the rate is bounded by a constant (presuming the state u is unchanged due to another ConstantRateJump, MassActionJump or bounded VariableRateJump). They can be simulated more efficiently using rejection-sampling based approaches that leverage this upper bound.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"ConstantRateJumps are more restricted in that they assume the rate functions are constant at all times between two consecutive jumps of the system. That is, any states or parameters that a rate function depends on must not change between the times at which two consecutive jumps occur.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"A MassActionJumps is a specialized representation for a collection of ConstantRateJump jumps that can each be interpreted as a standard mass action reaction. For systems comprised of many mass action reactions, using the MassActionJump type will offer improved performance compared to using multiple ConstantRateJumps. Note, only one MassActionJump should be defined per JumpProblem; it is then responsible for handling all mass action reaction type jumps. For systems with both mass action jumps and non-mass action jumps, one can create one MassActionJump to handle the mass action jumps, and create a number of ConstantRateJumps or VariableRateJumps to handle the non-mass action jumps.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Since exact methods simulate each individual jump, they may become computationally expensive to simulate processes over timescales that involve many jump occurrences. As an alternative, inexact τ-leaping methods take discrete steps through time, over which they simultaneously execute many jumps. These methods can be much faster as they do not need to simulate the realization of every individual jump event. τ-leaping methods trade accuracy for speed, and are best used when a set of jumps do not make significant changes to the processes' state and/or rates over the course of one time-step (i.e., during a leap interval). A single RegularJump is used to encode jumps for τ-leaping algorithms. While τ-leaping methods can be proven to converge in the limit that the time-step approaches zero, their accuracy can be highly dependent on the chosen time-step. As a rule of thumb, if changes to the state variable u during a time-step (i.e., leap interval) are \"minimal\" compared to the size of the system, an τ-leaping method can often provide reasonable solution approximations.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Currently, ConstantRateJumps, MassActionJumps, and VariableRateJumps can be coupled to standard SciML ODE/SDE solvers since they are internally handled via callbacks. For ConstantRateJumps, MassActionJumps, and bounded VariableRateJump the determination of the next jump time and type is handled by a user-selected aggregator algorithm. RegularJumps currently require their own special time integrators.","category":"page"},{"location":"jump_types/#Defining-a-Constant-Rate-Jump","page":"Jump types and JumpProblem","title":"Defining a Constant Rate Jump","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"The constructor for a ConstantRateJump is:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"ConstantRateJump(rate, affect!)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"rate(u, p, t) is a function which calculates the rate given the current state u, parameters p, and time t.\naffect!(integrator) is the effect on the equation using the integrator interface. It encodes how the state should change due to one occurrence of the jump.","category":"page"},{"location":"jump_types/#Defining-a-Mass-Action-Jump","page":"Jump types and JumpProblem","title":"Defining a Mass Action Jump","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"The constructor for a MassActionJump is:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"MassActionJump(reactant_stoich, net_stoich; scale_rates = true, param_idxs = nothing)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"reactant_stoich is a vector whose kth entry is the reactant stoichiometry of the kth reaction. The reactant stoichiometry for an individual reaction is assumed to be represented as a vector of Pairs, mapping species integer id to stoichiometric coefficient.\nnet_stoich is assumed to have the same type as reactant_stoich; a vector whose kth entry is the net stoichiometry of the kth reaction. The net stoichiometry for an individual reaction is again represented as a vector of Pairs, mapping species id to the net change in the species when the reaction occurs.\nscale_rates is an optional parameter that specifies whether the rate constants correspond to stochastic rate constants in the sense used by Gillespie, and hence need to be rescaled. The default, scale_rates = true, corresponds to rescaling the passed in rate constants. See below.\nparam_idxs is a vector of the indices within the parameter vector, p, that correspond to the rate constant for each jump.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Notes for Mass Action Jumps","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"When using MassActionJump the default behavior is to assume rate constants correspond to stochastic rate constants in the sense used by Gillespie (J. Comp. Phys., 1976, 22 (4)). This means that for a reaction such as 2A oversetkrightarrow B, the jump rate function constructed by MassActionJump would be k*A*(A-1)/2!. For a trimolecular reaction like 3A oversetkrightarrow B the rate function would be k*A*(A-1)*(A-2)/3!. To avoid having the reaction rates rescaled (by 1/2 and 1/6 for these two examples), one can pass the MassActionJump constructor the optional named parameter scale_rates = false, i.e., use\nMassActionJump(reactant_stoich, net_stoich; scale_rates = false, param_idxs)\nZero order reactions can be passed as reactant_stoichs in one of two ways. Consider the varnothing oversetkrightarrow A reaction with rate k=1:\np = [1.0]\nreactant_stoich = [[0 => 1]]\nnet_stoich = [[1 => 1]]\njump = MassActionJump(reactant_stoich, net_stoich; param_idxs = [1])\nAlternatively, one can create an empty vector of pairs to represent the reaction:\np = [1.0]\nreactant_stoich = [Vector{Pair{Int, Int}}()]\nnet_stoich = [[1 => 1]]\njump = MassActionJump(reactant_stoich, net_stoich; param_idxs = [1])\nFor performance reasons, it is recommended to order species indices in stoichiometry vectors from smallest to largest. That is\nreactant_stoich = [[1 => 2, 3 => 1, 4 => 2], [2 => 2, 3 => 2]]\nis preferred over\nreactant_stoich = [[3 => 1, 1 => 2, 4 => 2], [3 => 2, 2 => 2]]","category":"page"},{"location":"jump_types/#Defining-a-Variable-Rate-Jump","page":"Jump types and JumpProblem","title":"Defining a Variable Rate Jump","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"The constructor for a VariableRateJump is:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"VariableRateJump(rate, affect!;\n                 lrate = nothing, urate = nothing, rateinterval = nothing,\n                 idxs = nothing, rootfind = true, save_positions = (true, true),\n                 interp_points = 10, abstol = 1e-12, reltol = 0)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"rate(u, p, t) is a function which calculates the rate given the current state u, parameters p, and time t.\naffect!(integrator) is the effect on the equation using the integrator interface. It encodes how the state should change due to one occurrence of the jump.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"To define a bounded VariableRateJump, which can be simulated more efficiently with bounded VariableRateJump supporting aggregators such as Coevolve, one must also specify","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"urate(u, p, t), a function which computes an upper bound for the rate in the interval t to t + rateinterval(u, p, t) at time t given state u and parameters p.\nrateinterval(u, p, t), a function which computes a time interval t to t + rateinterval(u, p, t) given state u and parameters p over which the urate bound will hold (and lrate bound if provided, see below).","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"For increased performance, one can also specify a lower bound that should be valid over the same rateinterval","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"lrate(u, p, t), a function which computes a lower bound for the rate in the interval t to t + rateinterval(u, p, t) at time t given state u and parameters p. lrate should remain valid under the same conditions as urate.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Note that","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"It is currently only possible to simulate VariableRateJumps with SSAStepper when using systems with bounded VariableRateJumps and the Coevolve aggregator.\nAny JumpProblem with VariableRateJump that does not use the Coevolve aggregator  must be coupled to a continuous problem type such as an ODEProblem to handle time-stepping. Continuous time-stepper will ignore the provided aggregator and treat all VariableRateJumps as ContinuousCallbacks, using the rate(u, p, t) function to construct the condition function that triggers a callback.\nWhen using Coevolve with a JumpProblem coupled to a continuous problem such as an ODEProblem, the aggregator will handle the jumps in same way that it does with SSAStepper. However, ensure that given t the bounds will hold for the duration of rateinterval(t) for the full coupled system's dynamics or the algorithm will not give correct samples. Numerical and analytical solutions are generally not guaranteed to satisfy the same bounds, especially in large complicated models. Consider adding some slack on the bounds and approach complex models with care. In most simple cases the bounds should be close enough. For debugging purposes one might want to add safety checks in the bound functions.\nIn some circumstances with complex model of many variables it can be difficult to determine good a priori bounds on the ODE variables. For some discussion on the bound setting problem see [1].","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"[1] V. Lemaire, M. Thieullen and N. Thomas, Exact Simulation of the Jump Times of a Class of Piecewise Deterministic Markov Processes, Journal of Scientific Computing, 75 (3), 1776-1807 (2018). doi:10.1007/s10915-017-0607-4.","category":"page"},{"location":"jump_types/#Defining-a-Regular-Jump","page":"Jump types and JumpProblem","title":"Defining a Regular Jump","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"The constructor for a RegularJump is:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"RegularJump(rate, c, numjumps; mark_dist = nothing)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"rate(out, u, p, t) is the function which computes the rate for every regular jump process\nc(du, u, p, t, counts, mark) calculates the update given counts number of jumps for each jump process in the interval.\nnumjumps is the number of jump processes, i.e., the number of rate equations and the number of counts.\nmark_dist is the distribution for a mark.","category":"page"},{"location":"jump_types/#Defining-a-Jump-Problem","page":"Jump types and JumpProblem","title":"Defining a Jump Problem","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"To define a JumpProblem, one must first define the basic problem. This can be a DiscreteProblem if there is no differential equation, or an ODE/SDE/DDE/DAE if you would like to augment a differential equation with jumps. Denote this previously defined problem as prob. Then the constructor for the jump problem is:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"JumpProblem(prob, aggregator, jumps::JumpSet;\n            save_positions = typeof(prob) <: AbstractDiscreteProblem ? (false, true) :\n                             (true, true))","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"The aggregator is the method for simulating ConstantRateJumps, MassActionJumps, and bounded VariableRateJumps (if supported by the aggregator). They are called aggregators since they resolve all these jumps in a single discrete simulation algorithm. The possible aggregators are given below. jumps is a JumpSet which is just a collection of jumps. Instead of passing a JumpSet, one may just pass a list of jumps as trailing positional arguments. For example:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"JumpProblem(prob, aggregator, jump1, jump2)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"and the internals will automatically build the JumpSet. save_positions determines whether to save the state of the system just before and/or after jumps occur.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Note that a JumpProblem/JumpSet can only have 1 RegularJump (since a RegularJump itself describes multiple processes together). Similarly, it can only have one MassActionJump (since it also describes multiple processes together).","category":"page"},{"location":"jump_types/#Jump-Aggregators-for-Exact-Simulation","page":"Jump types and JumpProblem","title":"Jump Aggregators for Exact Simulation","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Jump aggregators are methods for simulating ConstantRateJumps, MassActionJumps, and bounded VariableRateJumps (if supported) exactly. They are called aggregators since they combine all jumps to handle within a single discrete simulation algorithm. Aggregators combine jumps in different ways and offer different trade-offs. However, all aggregators describe the realization of each and every individual jump chronologically. Since they do not skip any jumps, they are considered exact methods. Note that none of the aggregators discussed in this section can be used with RegularJumps which are used for time-step based (inexact) τ-leaping methods.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"The current aggregators are (note that an italicized name indicates the aggregator requires various types of dependency graphs, see the next section):","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Direct: The Gillespie Direct method SSA [1].\nDirectFW: the Gillespie Direct method SSA [1] with FunctionWrappers. This aggregator uses a different internal storage format for collections of ConstantRateJumps.\nDirectCR: The Composition-Rejection Direct method of Slepoy et al [2]. For large networks and linear chain-type networks, it will often give better performance than Direct.\nSortingDirect: The Sorting Direct Method of McCollum et al [3]. It will usually offer performance as good as Direct, and for some systems can offer substantially better performance.\nRSSA: The Rejection SSA (RSSA) method of Thanh et al [4,5]. With RSSACR, for very large reaction networks, it often offers the best performance of all methods.\nRSSACR: The Rejection SSA (RSSA) with Composition-Rejection method of Thanh et al [6]. With RSSA, for very large reaction networks, it often offers the best performance of all methods.\nRDirect: A variant of Gillespie's Direct method [1] that uses rejection to sample the next reaction.\nFRM: The Gillespie first reaction method SSA [1]. Direct should generally offer better performance and be preferred to FRM.\nFRMFW: The Gillespie first reaction method SSA [1] with FunctionWrappers.\nNRM: The Gibson-Bruck Next Reaction Method [7]. For some reaction network structures, this may offer better performance than Direct (for example, large, linear chains of reactions).\nCoevolve: An improvement of the COEVOLVE algorithm of Farajtabar et al [8]. Currently the only aggregator that also supports bounded VariableRateJumps. As opposed to COEVOLVE, this method syncs the thinning procedure with the stepper which allows it to handle dependencies on continuous dynamics. Essentially reduces to NRM in handling ConstantRateJumps and MassActionJumps.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"To pass the aggregator, pass the instantiation of the type. For example:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"JumpProblem(prob, Direct(), jump1, jump2)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"will build a problem where the jumps are simulated using Gillespie's Direct SSA method.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"[1] D. T. Gillespie, A general method for numerically simulating the stochastic time evolution of coupled chemical reactions, Journal of Computational Physics, 22 (4), 403–434 (1976). doi:10.1016/0021-9991(76)90041-3.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"[2] A. Slepoy, A.P. Thompson and S.J. Plimpton, A constant-time kinetic Monte Carlo algorithm for simulation of large biochemical reaction networks, Journal of Chemical Physics, 128 (20), 205101 (2008). doi:10.1063/1.2919546.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"[3] J. M. McCollum, G. D. Peterson, C. D. Cox, M. L. Simpson and N. F. Samatova, The sorting direct method for stochastic simulation of biochemical systems with varying reaction execution behavior, Computational Biology and Chemistry, 30 (1), 39049 (2006). doi:10.1016/j.compbiolchem.2005.10.007.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"[4] V. H. Thanh, C. Priami and R. Zunino, Efficient rejection-based simulation of biochemical reactions with stochastic noise and delays, Journal of Chemical Physics, 141 (13), 134116 (2014). doi:10.1063/1.4896985.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"[5] V. H. Thanh, R. Zunino and C. Priami, On the rejection-based algorithm for simulation and analysis of large-scale reaction networks, Journal of Chemical Physics, 142 (24), 244106 (2015). doi:10.1063/1.4922923.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"[6] V. H. Thanh, R. Zunino, and C. Priami, Efficient constant-time complexity algorithm for stochastic simulation of large reaction networks, IEEE/ACM Transactions on Computational Biology and Bioinformatics, 14 (3), 657-667 (2017). doi:10.1109/TCBB.2016.2530066.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"[7] M. A. Gibson and J. Bruck, Efficient exact stochastic simulation of chemical systems with many species and many channels, Journal of Physical Chemistry A, 104 (9), 1876-1889 (2000). doi:10.1021/jp993732q.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"[8] M. Farajtabar, Y. Wang, M. Gomez-Rodriguez, S. Li, H. Zha, and L. Song, COEVOLVE: a joint point process model for information diffusion and network evolution, Journal of Machine Learning Research 18(1), 1305–1353 (2017). doi: 10.5555/3122009.3122050.","category":"page"},{"location":"jump_types/#Jump-Aggregators-Requiring-Dependency-Graphs","page":"Jump types and JumpProblem","title":"Jump Aggregators Requiring Dependency Graphs","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Italicized constant rate jump aggregators above require the user to pass a dependency graph to JumpProblem. Coevolve, DirectCR, NRM, and SortingDirect require a jump-jump dependency graph, passed through the named parameter dep_graph. i.e.,","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"JumpProblem(prob, DirectCR(), jump1, jump2; dep_graph = your_dependency_graph)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"For systems with only MassActionJumps, or those generated from a Catalyst reaction_network, this graph will be auto-generated. Otherwise, you must construct the dependency graph whenever the set of jumps include ConstantRateJumps and/or bounded VariableRateJumps.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Dependency graphs are represented as a Vector{Vector{Int}}, with the ith vector containing the indices of the jumps for which rates must be recalculated when the ith jump occurs. Internally, all MassActionJumps are ordered before ConstantRateJumps and bounded VariableRateJumps. General VariableRateJumps are not handled by aggregators, and so not included in the jump ordering for dependency graphs. Note that the relative order between ConstantRateJumps and relative order between bounded VariableRateJumps is preserved. In this way, one can precalculate the jump order to manually construct dependency graphs.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"RSSA and RSSACR require two different types of dependency graphs, passed through the following JumpProblem kwargs:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"vartojumps_map - A Vector{Vector{Int}} mapping each variable index, i, to a set of jump indices. The jump indices correspond to jumps with rate functions that depend on the value of u[i].\njumptovars_map - A Vector{Vector{Int}}  mapping each jump index to a set of variable indices. The corresponding variables are those that have their value, u[i], altered when the jump occurs.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"For systems generated from a Catalyst reaction_network these will be auto-generated. Otherwise, you must explicitly construct and pass in these mappings.","category":"page"},{"location":"jump_types/#Recommendations-for-exact-methods","page":"Jump types and JumpProblem","title":"Recommendations for exact methods","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"For representing and aggregating jumps","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"Use a MassActionJump to handle all jumps that can be represented as mass action reactions with constant rate between jumps. This will generally offer the fastest performance.\nUse ConstantRateJumps for any remaining jumps with a constant rate between jumps.\nUse VariableRateJumps for any remaining jumps with variable rate between jumps. If possible, construct a bounded VariableRateJump as described above and in the doc string. The tighter and easier to compute the bounds are, the faster the resulting simulation will be. Use the Coevolve aggregator to ensure such jumps are handled via the more efficient aggregator interface. Coevolve handles continuous steppers so can be coupled with a continuous problem type such as an ODEProblem as long as the bounds are satisfied given changes in u over rateinterval.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"For systems with only ConstantRateJumps and MassActionJumps,","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"For a small number of jumps, < ~10, Direct will often perform as well as the other aggregators.\nFor > ~10 jumps SortingDirect will often offer better performance than Direct.\nFor large numbers of jumps with sparse chain like structures and similar jump rates, for example continuous time random walks, RSSACR, DirectCR and then NRM often have the best performance.\nFor very large networks, with many updates per jump, RSSA and RSSACR will often substantially outperform the other methods.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"For pure jump systems, time-step using SSAStepper() with a DiscreteProblem unless one has general (i.e., non-bounded) VariableRateJumps.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"In general, for systems with sparse dependency graphs if Direct is slow, one of SortingDirect, RSSA or RSSACR will usually offer substantially better performance. See DiffEqBenchmarks.jl for benchmarks on several example networks.","category":"page"},{"location":"jump_types/#Remaking-JumpProblems","page":"Jump types and JumpProblem","title":"Remaking JumpProblems","text":"","category":"section"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"When running many simulations, it can often be convenient to update the initial condition or simulation parameters without having to create and initialize a new JumpProblem. In such situations remake can be used to change the initial condition, time span, and the parameter vector. Note, the new JumpProblem will alias internal data structures from the old problem, including core components of the SSA aggregators. As such, only the new problem generated by remake should be used for subsequent simulations.","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"As an example, consider the following SIR model:","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"rate1(u, p, t) = p[1] * u[1] * u[2]\nfunction affect1!(integrator)\n    integrator.u[1] -= 1\n    integrator.u[2] += 1\nend\njump = ConstantRateJump(rate1, affect1!)\n\nrate2(u, p, t) = p[2] * u[2]\nfunction affect2!(integrator)\n    integrator.u[2] -= 1\n    integrator.u[3] += 1\nend\njump2 = ConstantRateJump(rate2, affect2!)\nu0 = [999, 1, 0]\np = (0.1 / 1000, 0.01)\ntspan = (0.0, 250.0)\ndprob = DiscreteProblem(u0, tspan, p)\njprob = JumpProblem(dprob, Direct(), jump, jump2)\nsol = solve(jprob, SSAStepper())","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"We can change any of u0, p and/or tspan by either making a new DiscreteProblem","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"u02 = [10, 1, 0]\np2 = (0.1 / 1000, 0.0)\ntspan2 = (0.0, 2500.0)\ndprob2 = DiscreteProblem(u02, tspan2, p2)\njprob2 = remake(jprob, prob = dprob2)\nsol2 = solve(jprob2, SSAStepper())","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"or by directly remaking with the new parameters","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"jprob2 = remake(jprob, u0 = u02, p = p2, tspan = tspan2)\nsol2 = solve(jprob2, SSAStepper())","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"To avoid ambiguities, the following will give an error","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"jprob2 = remake(jprob, prob = dprob2, u0 = u02)","category":"page"},{"location":"jump_types/","page":"Jump types and JumpProblem","title":"Jump types and JumpProblem","text":"as will trying to update either p or tspan while passing a new DiscreteProblem using the prob kwarg.","category":"page"},{"location":"tutorials/spatial/#Spatial-SSAs-with-JumpProcesses.jl","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"","category":"section"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"This tutorial shows how to use spatial solvers.","category":"page"},{"location":"tutorials/spatial/#Reversible-binding-model-on-a-grid","page":"Spatial SSAs with JumpProcesses.jl","title":"Reversible binding model on a grid","text":"","category":"section"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"A 5 by 5 Cartesian grid:","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"<!– –> <!– –> <!– –> <!– –> <!– –>\n. . . . B\n. . . . .\n. . . . .\n. . . . .\nA . . . .","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"Suppose we have a reversible binding system described by A+B to C at rate k_1 and C to A+B at rate k_2. Further, suppose that all A molecules start in the lower-left corner, while all B molecules start in the upper-right corner of a 5 by 5 grid. There are no C molecules at the start.","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"We first create the grid:","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"using JumpProcesses\ndims = (5, 5)\nnum_nodes = prod(dims) # number of sites\ngrid = CartesianGrid(dims) # or use Graphs.grid(dims)","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"Now we set the initial state of the simulation. It has to be a matrix with entry (si) being the number of species s at site i (with the standard column-major ordering of the grid).","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"num_species = 3\nstarting_state = zeros(Int, num_species, num_nodes)\nstarting_state[1, 1] = 25\nstarting_state[2, end] = 25\nstarting_state","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"We now set the time-span of the simulation and the reaction rates. These can be chosen arbitrarily.","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"tspan = (0.0, 3.0)\nrates = [6.0, 0.05] # k_1 = rates[1], k_2 = rates[2]","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"Now we can create the DiscreteProblem:","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"prob = DiscreteProblem(starting_state, tspan, rates)","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"Since both reactions are massaction reactions, we put them together in a MassActionJump. In order to do that, we create two stoichiometry vectors. The net stoichiometry vector describes which molecules change in number and how much after each reaction; for example, [1 => -1] is the first molecule disappearing. The reaction stoichiometry vector describes what the reactants of each reaction are; for example, [1 => 1, 2 => 1] would mean that the reactants are one molecule of type 1, and one molecule of type 2.","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"netstoch = [[1 => -1, 2 => -1, 3 => 1], [1 => 1, 2 => 1, 3 => -1]]\nreactstoch = [[1 => 1, 2 => 1], [3 => 1]]\nmajumps = MassActionJump(rates, reactstoch, netstoch)","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"The last thing to set up is the hopping constants – the probability per time of an individual molecule of each species hopping from one site to another site. In practice, this parameter, as well as reaction rates, are obtained empirically. Suppose that molecule C cannot diffuse, while molecules A and B diffuse at probability per time 1 (i.e., the time of the diffusive hop is exponentially distributed with mean 1). Entry (si) of hopping_constants is the hopping rate of species s at site i to any of its neighboring sites (diagonal hops are not allowed).","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"hopping_constants = ones(num_species, num_nodes)\nhopping_constants[3, :] .= 0.0\nhopping_constants","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"We are now ready to set up the JumpProblem with the Next Subvolume Method.","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"alg = NSM()\njump_prob = JumpProblem(prob, alg, majumps, hopping_constants = hopping_constants,\n                        spatial_system = grid, save_positions = (true, false))","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"The save_positions keyword tells the solver to save the positions just before the jumps. To solve the jump problem do","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"solution = solve(jump_prob, SSAStepper())","category":"page"},{"location":"tutorials/spatial/#Animation","page":"Spatial SSAs with JumpProcesses.jl","title":"Animation","text":"","category":"section"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"Visualizing solutions of spatial jump problems is best done with animations.","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"using Plots\nis_static(spec) = (spec == 3) # true if spec does not hop\n\"\"\"\nget frame k\n\"\"\"\nfunction get_frame(k, sol, linear_size, labels, title)\n    num_species = length(labels)\n    h = 1 / linear_size\n    t = sol.t[k]\n    state = sol.u[k]\n    xlim = (0, 1 + 3h / 2)\n    ylim = (0, 1 + 3h / 2)\n    plt = plot(xlim = xlim, ylim = ylim, title = \"$title, $(round(t, sigdigits=3)) seconds\")\n\n    species_seriess_x = [[] for i in 1:num_species]\n    species_seriess_y = [[] for i in 1:num_species]\n    CI = CartesianIndices((linear_size, linear_size))\n    for ci in CartesianIndices(state)\n        species, site = Tuple(ci)\n        x, y = Tuple(CI[site])\n        num_molecules = state[ci]\n        sizehint!(species_seriess_x[species], num_molecules)\n        sizehint!(species_seriess_y[species], num_molecules)\n        if !is_static(species)\n            randsx = rand(num_molecules)\n            randsy = rand(num_molecules)\n        else\n            randsx = zeros(num_molecules)\n            randsy = zeros(num_molecules)\n        end\n        for k in 1:num_molecules\n            push!(species_seriess_x[species], x * h - h / 4 + 0.5h * randsx[k])\n            push!(species_seriess_y[species], y * h - h / 4 + 0.5h * randsy[k])\n        end\n    end\n    for species in 1:num_species\n        scatter!(plt, species_seriess_x[species], species_seriess_y[species],\n                 label = labels[species], marker = 6)\n    end\n    xticks!(plt, range(xlim..., length = linear_size + 1))\n    yticks!(plt, range(ylim..., length = linear_size + 1))\n    xgrid!(plt, 1, 0.7)\n    ygrid!(plt, 1, 0.7)\n    return plt\nend\n\n\"\"\"\nmake an animation of solution sol in 2 dimensions\n\"\"\"\nfunction animate_2d(sol, linear_size; species_labels, title, verbose = true)\n    num_frames = length(sol.t)\n    anim = @animate for k in 1:num_frames\n        verbose && println(\"Making frame $k\")\n        get_frame(k, sol, linear_size, species_labels, title)\n    end\n    anim\nend\n# animate\nanim = animate_2d(solution, 5, species_labels = [\"A\", \"B\", \"C\"], title = \"A + B <--> C\",\n                  verbose = false)\nfps = 5\ngif(anim, fps = fps)","category":"page"},{"location":"tutorials/spatial/#Making-changes-to-the-model","page":"Spatial SSAs with JumpProcesses.jl","title":"Making changes to the model","text":"","category":"section"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"Now suppose we want to make some changes to the reversible binding model above. There are three \"dimensions\" that can be changed: the topology of the system, the structure of hopping rates and the solver. The supported topologies are CartesianGrid – used above, and any AbstractGraph from Graphs. The supported forms of hopping rates are D_si D_sij D_s * L_ij, and D_si * L_ij, where s denotes the species, i – the source site, and j – the destination. The supported solvers are NSM, DirectCRDirect and any of the standard non-spatial solvers.","category":"page"},{"location":"tutorials/spatial/#Topology","page":"Spatial SSAs with JumpProcesses.jl","title":"Topology","text":"","category":"section"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"If our mesh is a grid (1D, 2D and 3D are supported), we can create the mesh as follows.","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"dims = (2, 3, 4) # can pass in a 1-Tuple, a 2-Tuple or a 3-Tuple\nnum_nodes = prod(dims)\ngrid = CartesianGrid(dims)","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"The interface is the same as for Graphs.grid. If we want to use an unstructured mesh, we can simply use any AbstractGraph from Graphs as follows:","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"using Graphs\ngraph = cycle_digraph(5) # directed cyclic graph on 5 nodes","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"Now, either graph or grid can be used as spatial_system in creation of the JumpProblem.","category":"page"},{"location":"tutorials/spatial/#Hopping-rates","page":"Spatial SSAs with JumpProcesses.jl","title":"Hopping rates","text":"","category":"section"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"The most general form of hopping rates that is supported is D_sij – each (species, source, destination) triple gets its own independent hopping rate. To use this, hopping_constants must be of type Matrix{Vector{F}} where F <: Number (usually F is Float64) with hopping_constants[s,i][j] being the hopping rate of species s at site i to neighbor at index j. Note that neighbors are in ascending order, like in Graphs. Here is an example where only hopping up and left is allowed.","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"hopping_constants = Matrix{Vector{Float64}}(undef, num_species, num_nodes)\nfor ci in CartesianIndices(hopping_constants)\n    (species, site) = Tuple(ci)\n    hopping_constants[species, site] = zeros(outdegree(grid, site))\n    for (n, nb) in enumerate(neighbors(grid, site))\n        if nb < site\n            hopping_constants[species, site][n] = 1.0\n        end\n    end\nend","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"To pass in hopping_constants of form D_s * L_ij we need two vectors – one for D_s and one for L_ij. Here is an example.","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"species_hop_constants = ones(num_species)\nsite_hop_constants = Vector{Vector{Float64}}(undef, num_nodes)\nfor site in 1:num_nodes\n    site_hop_constants[site] = ones(outdegree(grid, site))\nend\nhopping_constants = Pair(species_hop_constants, site_hop_constants)","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"We must combine both vectors into a pair, as in the last line above.","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"Finally, to use in hopping_constants of form D_si * L_ij we construct a matrix instead of a vector for D_sj.","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"species_hop_constants = ones(num_species, num_nodes)\nsite_hop_constants = Vector{Vector{Float64}}(undef, num_nodes)\nfor site in 1:num_nodes\n    site_hop_constants[site] = ones(outdegree(grid, site))\nend\nhopping_constants = Pair(species_hop_constants, site_hop_constants)","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"We can use either of the four versions of hopping_constants to construct a JumpProblem with the same syntax as in the original example. The different forms of hopping rates are supported not only for convenience, but also for better memory usage and performance. So it is recommended that the most specialized form of hopping rates is used.","category":"page"},{"location":"tutorials/spatial/#Solvers","page":"Spatial SSAs with JumpProcesses.jl","title":"Solvers","text":"","category":"section"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"There are currently two specialized \"spatial\" solvers: NSM and DirectCRDirect. The former stands for Next Subvolume Method [1]. The latter employs Composition-Rejection to sample the next site to fire, similar to the ordinary DirectCR method. For larger networks DirectCRDirect is expected to be faster. Both methods can be used interchangeably.","category":"page"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"Additionally, all standard solvers are supported as well, although they are expected to use more memory and be slower. They \"flatten\" the problem, i.e., turn all hops into reactions, resulting in a much larger system. For example, to use the Next Reaction Method (NRM), simply pass in NRM() instead of NSM() in the construction of the JumpProblem. Importantly, you must pass in hopping_constants in the D_{s,i,j} or D_{s,i} form to use any of the non-specialized solvers.","category":"page"},{"location":"tutorials/spatial/#References","page":"Spatial SSAs with JumpProcesses.jl","title":"References","text":"","category":"section"},{"location":"tutorials/spatial/","page":"Spatial SSAs with JumpProcesses.jl","title":"Spatial SSAs with JumpProcesses.jl","text":"[1]: Elf, Johan and Ehrenberg, Mäns. “Spontaneous separation of bi-stable biochemical systems into spatial domains of opposite phases”. In: Systems biology 1.2 (2004), pp. 230–236.","category":"page"},{"location":"jump_solve/#jump_solve","page":"Jump solvers","title":"Jump Problem and Jump Diffusion Solvers","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"solve(prob::JumpProblem, alg; kwargs)","category":"page"},{"location":"jump_solve/#Recommended-Methods","page":"Jump solvers","title":"Recommended Methods","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"JumpProblems can be solved with two classes of methods, exact and inexact. Exact algorithms currently sample realizations of the jump processes in chronological order, executing individual jumps sequentially at randomly sampled times. In contrast, inexact (τ-leaping) methods are time-step based, executing multiple occurrences of jumps during each time-step. These methods can be much faster as they only simulate the total number of jumps over each leap interval, and thus do not need to simulate the realization of every single jump. Jumps for use with exact simulation methods can be defined as ConstantRateJumps, MassActionJumps, and/or VariableRateJump. Jumps for use with inexact τ-leaping methods should be defined as RegularJumps.","category":"page"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"There are special algorithms available for efficiently simulating an exact, pure JumpProblem (i.e., a JumpProblem over a DiscreteProblem).  SSAStepper() is an efficient streamlined integrator for time stepping such problems from individual jump to jump. This integrator is named after Stochastic Simulation Algorithms (SSAs), commonly used naming in chemistry and biology applications for the class of exact jump process simulation algorithms. In turn, we denote by \"aggregators\" the algorithms that SSAStepper calls to calculate the next jump time and to execute a jump (i.e., change the system state appropriately). All JumpProcesses aggregators can be used with ConstantRateJumps and MassActionJumps, with a subset of aggregators also working with bounded VariableRateJumps (see the first tutorial for the definition of bounded VariableRateJumps). Although SSAStepper() is usually faster, it only supports discrete events (DiscreteCallbacks), for pure jump problems requiring continuous events (ContinuousCallbacks) the less performant FunctionMap time-stepper can be used.","category":"page"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"If there is a RegularJump, then inexact τ-leaping methods must be used. The current recommended method is TauLeaping if one needs adaptivity, events, etc. If one only needs the most barebones fixed time-step leaping method, then SimpleTauLeaping can have performance benefits.","category":"page"},{"location":"jump_solve/#Special-Methods-for-Pure-Jump-Problems","page":"Jump solvers","title":"Special Methods for Pure Jump Problems","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"If you are using jumps with a differential equation, use the same methods as in the case of the differential equation solving. However, the following algorithms are optimized for pure jump problems.","category":"page"},{"location":"jump_solve/#JumpProcesses.jl","page":"Jump solvers","title":"JumpProcesses.jl","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"SSAStepper: a stepping integrator for JumpProblems defined over DiscreteProblems involving ConstantRateJumps, MassActionJumps, and/or bounded VariableRateJumps . Supports handling of DiscreteCallbacks and saving controls like saveat. Note that DifferentialEquations.jl treats jumps as similar to callbacks, and hence SSAStepper only implements a subset of ODE/SDE solver saving controls. In particular, save_everystep is not supported as saving jumps each step is controlled via the save_positions argument to JumpProblems. Note, in contrast to when JumpProblems are coupled with ODE and SDE timesteppers, with SSAStepper, setting save_positions = (false, true), save_positions = (true, false) or save_positions = (true, true) are equivalent and save only after the jump has occurred (as opposed to saving the state both before and after a jump). This is because the underlying SSAStepper generated-solution uses piecewise constant interpolation, and can therefore exactly evaluate the sampled solution path at any time when only saving the post-jump state for each jump.","category":"page"},{"location":"jump_solve/#RegularJump-Compatible-Methods","page":"Jump solvers","title":"RegularJump Compatible Methods","text":"","category":"section"},{"location":"jump_solve/#StochasticDiffEq.jl","page":"Jump solvers","title":"StochasticDiffEq.jl","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"These methods support mixing with event handling, other jump types, and all of the features of the normal differential equation solvers.","category":"page"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"TauLeaping: an adaptive tau-leaping algorithm with post-leap estimates.","category":"page"},{"location":"jump_solve/#JumpProcesses.jl-2","page":"Jump solvers","title":"JumpProcesses.jl","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"SimpleTauLeaping: a tau-leaping algorithm for pure RegularJump JumpProblems. Requires a choice of dt.\nRegularSSA: a version of SSA for pure RegularJump JumpProblems.","category":"page"},{"location":"jump_solve/#Regular-Jump-Diffusion-Compatible-Methods","page":"Jump solvers","title":"Regular Jump Diffusion Compatible Methods","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"Regular jump diffusions are JumpProblems where the internal problem is an SDEProblem and the jump process has designed a regular jump.","category":"page"},{"location":"jump_solve/#StochasticDiffEq.jl-2","page":"Jump solvers","title":"StochasticDiffEq.jl","text":"","category":"section"},{"location":"jump_solve/","page":"Jump solvers","title":"Jump solvers","text":"EM: Explicit Euler-Maruyama.\nImplicitEM: Implicit Euler-Maruyama. See the SDE solvers page for more details.","category":"page"},{"location":"#JumpProcesses.jl:-Stochastic-Simulation-Algorithms-for-Jump-Processes,-Jump-ODEs,-and-Jump-Diffusions","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"","category":"section"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"JumpProcesses.jl, formerly DiffEqJump.jl, provides methods for simulating jump (or point) processes. Across different fields of science, such methods are also known as stochastic simulation algorithms (SSAs), Doob's method, Gillespie methods, or Kinetic Monte Carlo methods. It also enables the incorporation of jump processes into hybrid jump-ODE and jump-SDE models, including jump diffusions.","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"JumpProcesses is a component package in the SciML ecosystem, and one of the core solver libraries included in DifferentialEquations.jl.","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"The documentation includes","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"a tutorial on simulating basic Poisson processes\na tutorial and details on using JumpProcesses to simulate jump processes via SSAs (i.e., Gillespie methods),\na tutorial on simulating jump-diffusion processes,\na reference on the types of jumps and available simulation methods,\na reference on jump time stepping methods\na FAQ with information on changing parameters between simulations and using callbacks.\nthe JumpProcesses.jl API documentation.","category":"page"},{"location":"#Installation","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"Installation","text":"","category":"section"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"There are two ways to install JumpProcesses.jl. First, users may install the meta DifferentialEquations.jl package, which installs and wraps OrdinaryDiffEq.jl for solving ODEs, StochasticDiffEq.jl for solving SDEs, and JumpProcesses.jl, along with a number of other useful packages for solving models involving ODEs, SDEs and/or jump process. This single install will provide the user with all the facilities for developing and solving Jump problems.","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"To install the DifferentialEquations.jl package, refer to the following link for complete installation details.","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"If the user wishes to install the JumpProcesses.jl library separately, which is a lighter dependency than DifferentialEquations.jl, then the following code will install JumpProcesses.jl using the Julia package manager:","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"using Pkg\nPkg.add(\"JumpProcesses\")","category":"page"},{"location":"#Contributing-and-Getting-Help","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"Contributing and Getting Help","text":"","category":"section"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums for getting help and asking questions:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nThe Julia Discourse forums\nSee also the SciML Community page","category":"page"},{"location":"#Reproducibility","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"</details>","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"</details>","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"</details>","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"You can also download the\n<a href=\"","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"using TOML\nprojtoml = joinpath(\"..\", \"..\", \"Project.toml\")\nversion = TOML.parse(read(projtoml, String))[\"version\"]\nname = TOML.parse(read(projtoml, String))[\"name\"]\nlink = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n       \"/assets/Manifest.toml\"","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"\">manifest</a> file and the\n<a href=\"","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"using TOML\nprojtoml = joinpath(\"..\", \"..\", \"Project.toml\")\nversion = TOML.parse(read(projtoml, String))[\"version\"]\nname = TOML.parse(read(projtoml, String))[\"name\"]\nlink = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n       \"/assets/Project.toml\"","category":"page"},{"location":"","page":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","title":"JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions","text":"\">project</a> file.","category":"page"},{"location":"faq/#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"faq/#My-simulation-is-really-slow-and/or-using-a-lot-of-memory,-what-can-I-do?","page":"FAQ","title":"My simulation is really slow and/or using a lot of memory, what can I do?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Exact methods simulate every jump, and by default save the state before and after each jump. To reduce memory use, use save_positions = (false, false) in the JumpProblem constructor as described earlier to turn off saving the system state before and after every jump. Combined with use of saveat in the call to solve, to specify the specific times at which to save the state, this can dramatically reduce memory usage.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"While Direct is often fastest for systems with 10 or less ConstantRateJumps and/or MassActionJumps, if your system has many jumps or one jump occurs most frequently, other stochastic simulation algorithms may be faster. See Jump Aggregators for Exact Simulation and the subsequent sections there for guidance on choosing different SSAs (called aggregators in JumpProcesses). For systems with bounded VariableRateJumps using Coevolve with SSAStepper instead of an ODE/SDE time stepper can give a significant performance boost.","category":"page"},{"location":"faq/#When-running-many-consecutive-simulations,-for-example-within-an-EnsembleProblem-or-loop,-how-can-I-update-JumpProblems?","page":"FAQ","title":"When running many consecutive simulations, for example within an EnsembleProblem or loop, how can I update JumpProblems?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In Remaking JumpProblems we show how to modify parameters, the initial condition, and other components of a generated JumpProblem. This can be useful when trying to call solve many times while avoiding reallocations of the internal aggregators for each new parameter value or initial condition.","category":"page"},{"location":"faq/#How-can-I-define-collections-of-many-different-jumps-and-pass-them-to-JumpProblem?","page":"FAQ","title":"How can I define collections of many different jumps and pass them to JumpProblem?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"We can use JumpSets to collect jumps together, and then pass them into JumpProblems directly. For example, using a MassActionJump and ConstantRateJump defined in the second tutorial, we can write","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"jset = JumpSet(mass_act_jump, birth_jump)\njump_prob = JumpProblem(prob, Direct(), jset)\nsol = solve(jump_prob, SSAStepper())","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you have many jumps in tuples or vectors, it is easiest to use the keyword argument-based constructor:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"cj1 = ConstantRateJump(rate1, affect1!)\ncj2 = ConstantRateJump(rate2, affect2!)\ncjvec = [cj1, cj2]\n\nvj1 = VariableRateJump(rate3, affect3!)\nvj2 = VariableRateJump(rate4, affect4!)\nvjtuple = (vj1, vj2)\n\njset = JumpSet(; constant_jumps = cjvec, variable_jumps = vjtuple,\n               massaction_jumps = mass_act_jump)","category":"page"},{"location":"faq/#How-can-I-set-the-random-number-generator-used-in-the-jump-process-sampling-algorithms-(SSAs)?","page":"FAQ","title":"How can I set the random number generator used in the jump process sampling algorithms (SSAs)?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Random number generators can be passed to JumpProblem via the rng keyword argument. Continuing the previous example:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"#] add RandomNumbers\nusing RandomNumbers\njprob = JumpProblem(dprob, Direct(), maj,\n                    rng = Xorshifts.Xoroshiro128Star(rand(UInt64)))","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"uses the Xoroshiro128Star generator from RandomNumbers.jl.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"On version 1.7 and up, JumpProcesses uses Julia's built-in random number generator by default. On versions below 1.7 it uses Xoroshiro128Star.","category":"page"},{"location":"faq/#What-are-these-aggregators-and-aggregations-in-JumpProcesses?","page":"FAQ","title":"What are these aggregators and aggregations in JumpProcesses?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"JumpProcesses provides a variety of methods for sampling the time the next ConstantRateJump, MassActionJump, or VariableRateJump occurs, and which jump type happens at that time. These methods are examples of stochastic simulation algorithms (SSAs), also known as Gillespie methods, Doob's method, or Kinetic Monte Carlo methods. These are all names for jump (or point) processes simulation methods used across the biology, chemistry, engineering, mathematics, and physics literature. In the JumpProcesses terminology, we call such methods \"aggregators\", and the cache structures that hold their basic data \"aggregations\". See Jump Aggregators for Exact Simulation for a list of the available SSA aggregators.","category":"page"},{"location":"faq/#How-should-jumps-be-ordered-in-dependency-graphs?","page":"FAQ","title":"How should jumps be ordered in dependency graphs?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Internally, JumpProcesses SSAs (aggregators) order all MassActionJumps first, then all ConstantRateJumps and/or VariableRateJumps. i.e., in the example","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"using JumpProcesses\nrs = [[1 => 1], [2 => 1]]\nns = [[1 => -1, 2 => 1], [1 => 1, 2 => -1]]\np = [1.0, 0.0]\nmaj = MassActionJump(rs, ns; param_idxs = [1, 2])\nrate1(u, p, t) = u[1]\nfunction affect1!(integrator)\n    u[1] -= 1\nend\ncj1 = ConstantRateJump(rate1, affect1)\nrate2(u, p, t) = u[2]\nfunction affect2!(integrator)\n    u[2] -= 1\nend\ncj2 = ConstantRateJump(rate2, affect2)\njset = JumpSet(; constant_jumps = [cj1, cj2], massaction_jump = maj)","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The four jumps would be ordered by the first jump in maj, the second jump in maj, cj1, and finally cj2. Any user-generated dependency graphs should then follow this ordering when assigning an integer id to each jump.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"See also Jump Aggregators Requiring Dependency Graphs for more on dependency graphs needed for the various SSAs.","category":"page"},{"location":"faq/#How-do-I-use-callbacks-with-jump-simulations?","page":"FAQ","title":"How do I use callbacks with jump simulations?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Callbacks can be used with ConstantRateJumps, MassActionJumps, and VariableRateJumps. When solving a pure jump system with SSAStepper, only discrete callbacks can be used (otherwise a different time stepper is needed). When using an ODE or SDE time stepper, any callback should work.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Note, when modifying u or p within a callback, you must call reset_aggregated_jumps! after making updates. This ensures that the underlying jump simulation algorithms know to reinitialize their internal data structures. Omitting this call will lead to incorrect behavior!","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"A simple example that uses a MassActionJump and changes the parameters at a specified time in the simulation using a DiscreteCallback is","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"using JumpProcesses\nrs = [[1 => 1], [2 => 1]]\nns = [[1 => -1, 2 => 1], [1 => 1, 2 => -1]]\np = [1.0, 0.0]\nmaj = MassActionJump(rs, ns; param_idxs = [1, 2])\nu₀ = [100, 0]\ntspan = (0.0, 40.0)\ndprob = DiscreteProblem(u₀, tspan, p)\njprob = JumpProblem(dprob, Direct(), maj)\npcondit(u, t, integrator) = t == 20.0\nfunction paffect!(integrator)\n    integrator.p[1] = 0.0\n    integrator.p[2] = 1.0\n    reset_aggregated_jumps!(integrator)\n    nothing\nend\nsol = solve(jprob, SSAStepper(), tstops = [20.0],\n            callback = DiscreteCallback(pcondit, paffect!))","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Here at time 20.0 we turn off production of u[2] while activating production of u[1], giving","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"(Image: callback_gillespie)","category":"page"},{"location":"faq/#How-can-I-access-earlier-solution-values-in-callbacks?","page":"FAQ","title":"How can I access earlier solution values in callbacks?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"When using an ODE or SDE time-stepper that conforms to the integrator interface, one can simply use integrator.uprev. For efficiency reasons, the pure jump SSAStepper integrator does not have such a field. If one needs solution components at earlier times, one can save them within the callback condition by making a functor:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"# stores the previous value of u[2] and represents the callback functions\nmutable struct UprevCondition{T}\n    u2::T\nend\n\n# condition\nfunction (upc::UprevCondition)(u, t, integrator)\n    # condition for the callback is that the new value of u[2]\n    # is smaller than the previous value\n    condit = u[2] - upc.u2 < 0\n\n    # save the new value as the previous value\n    upc.u2 = u[2]\n\n    condit\nend\n\n# affect!\nfunction (upc::UprevCondition)(integrator)\n    integrator.u[4] -= 1\n    nothing\nend\n\nupc = UprevCondition(u0[2])\ncb = DiscreteCallback(upc, upc)","category":"page"}]
}
