<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · DiffEqJump.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://diffeqjump.sciml.ai/stable/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DiffEqJump.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/discrete_stochastic_example/">Continuous-Time Jump Processes and Gillespie Methods</a></li><li><a class="tocitem" href="../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li></ul></li><li><a class="tocitem" href="../faq/">FAQ</a></li><li><span class="tocitem">Type Documentation</span><ul><li><a class="tocitem" href="../jump_types/">Jump types and JumpProblem</a></li><li><a class="tocitem" href="../jump_solve/">Jump solvers</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Core-Types"><span>Core Types</span></a></li><li><a class="tocitem" href="#Types-of-Jumps"><span>Types of Jumps</span></a></li><li><a class="tocitem" href="#Aggregators"><span>Aggregators</span></a></li><li class="toplevel"><a class="tocitem" href="#Private-API-Functions"><span>Private API Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqJump.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DiffEqJump.jl-API"><a class="docs-heading-anchor" href="#DiffEqJump.jl-API">DiffEqJump.jl API</a><a id="DiffEqJump.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#DiffEqJump.jl-API" title="Permalink"></a></h1><h2 id="Core-Types"><a class="docs-heading-anchor" href="#Core-Types">Core Types</a><a id="Core-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DiffEqJump.JumpProblem" href="#DiffEqJump.JumpProblem"><code>DiffEqJump.JumpProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct JumpProblem{iip, P, A, C, J&lt;:Union{Nothing, DiffEqJump.AbstractJumpAggregator}, J2, J3, J4, R} &lt;: SciMLBase.AbstractJumpProblem{P, J&lt;:Union{Nothing, DiffEqJump.AbstractJumpAggregator}}</code></pre><p>Defines a collection of jump processes to associate with another problem type.</p><ul><li><a href="https://diffeq.sciml.ai/stable/types/jump_types/">Documentation Page</a> </li><li><a href="https://diffeq.sciml.ai/stable/tutorials/discrete_stochastic_example/">Tutorial Page</a></li><li><a href="https://diffeq.sciml.ai/stable/tutorials/discrete_stochastic_example/#FAQ">FAQ Page</a></li></ul><p><strong>Constructors</strong></p><p><code>JumpProblem</code>s can be constructed by first building another problem type to which the jumps will be associated. For example, to  simulate a collection of jump processes for which the transition rates do not explicitly depend on time (called <code>ConstantRateJump</code>s or <code>MassActionJump</code>s), we must first construct a <code>DiscreteProblem</code></p><pre><code class="language-julia hljs">prob = DiscreteProblem(u0, p, tspan)</code></pre><p>where <code>u0</code> is the initial condition, <code>p</code> the parameters and <code>tspan</code> the time span. If we wanted to have the jumps coupled with a system of ODEs, or have transition rates with explicit time dependence, we would use an <code>ODEProblem</code> instead that defines the ODE portion of the dynamics. </p><p>Given <code>prob</code> we define the jumps via</p><ul><li><code>JumpProblem(prob, aggregator::AbstractAggregatorAlgorithm, jumps::JumpSet ; kwargs...)</code></li><li><code>JumpProblem(prob, aggregator::AbstractAggregatorAlgorithm, jumps...; kwargs...)</code></li></ul><p>Here <code>aggregator</code> specifies the underlying algorithm for calculating next jump times and types, for example <code>Direct</code>. The collection of different <code>AbstractJump</code> types can then be passed within a single <code>JumpSet</code> or as subsequent sequential arguments. </p><p><strong>Fields</strong></p><ul><li><p><code>prob</code></p><p>The type of problem to couple the jumps to. For a pure jump process use <code>DiscreteProblem</code>, to couple to ODEs, <code>ODEProblem</code>, etc.</p></li><li><p><code>aggregator</code></p><p>The aggregator algorithm that determines the next jump times and types for <code>ConstantRateJump</code>s and <code>MassActionJump</code>s. Examples include <code>Direct</code>.</p></li><li><p><code>discrete_jump_aggregation</code></p><p>The underlying state data associated with the chosen aggregator.</p></li><li><p><code>jump_callback</code></p><p><code>CallBackSet</code> with the underlying <code>ConstantRate</code> and <code>VariableRate</code> jumps.</p></li><li><p><code>variable_jumps</code></p><p>The <code>VariableRateJump</code>s.</p></li><li><p><code>regular_jump</code></p><p>The <code>RegularJump</code>s.</p></li><li><p><code>massaction_jump</code></p><p>The <code>MassActionJump</code>s.</p></li><li><p><code>rng</code></p><p>The random number generator to use.</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>rng</code>, the random number generator to use. On 1.7 and up defaults to Julia&#39;s builtin generator, below 1.7 uses RandomNumbers.jl&#39;s <code>Xorshifts.Xoroshiro128Star(rand(UInt64))</code>.</li><li><code>save_positions=(true,true)</code>, specifies whether to save the system&#39;s state (before,after) the jump occurs. </li><li><code>spatial_system</code>, for spatial problems the underlying spatial structure.</li><li><code>hopping_constants</code>, for spatial problems the spatial transition rate coefficients.</li></ul><p>Please see the <a href="https://diffeq.sciml.ai/stable/tutorials/discrete_stochastic_example/">tutorial page</a> in the DifferentialEquations.jl <a href="https://diffeq.sciml.ai/stable/">docs</a> for usage examples and commonly asked questions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqJump.jl/blob/f5ec8558a95f31a0fa2cac181c200e85ff144d2e/src/problem.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqJump.SSAStepper" href="#DiffEqJump.SSAStepper"><code>DiffEqJump.SSAStepper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SSAStepper &lt;: SciMLBase.DEAlgorithm</code></pre><p>Highly efficient integrator for pure jump problems that involve only <code>ConstantRateJump</code>s and/or <code>MassActionJump</code>s.</p><p><strong>Notes</strong></p><ul><li>Only works with <code>JumProblem</code>s defined from <code>DiscreteProblem</code>s.</li><li>Only works with collections of <code>ConstantRateJump</code>s and <code>MassActionJump</code>s.</li><li>Only supports <code>DiscreteCallback</code>s for events.</li></ul><p><strong>Examples</strong></p><p>SIR model:</p><pre><code class="language-julia hljs">using DiffEqJump
β = 0.1 / 1000.0; ν = .01;
p = (β,ν)
rate1(u,p,t) = p[1]*u[1]*u[2]  # β*S*I
function affect1!(integrator)
  integrator.u[1] -= 1         # S -&gt; S - 1
  integrator.u[2] += 1         # I -&gt; I + 1
end
jump = ConstantRateJump(rate1,affect1!)

rate2(u,p,t) = p[2]*u[2]      # ν*I
function affect2!(integrator)
  integrator.u[2] -= 1        # I -&gt; I - 1
  integrator.u[3] += 1        # R -&gt; R + 1
end
jump2 = ConstantRateJump(rate2,affect2!)
u₀    = [999,1,0]
tspan = (0.0,250.0)
prob = DiscreteProblem(u₀, tspan, p)
jump_prob = JumpProblem(prob, Direct(), jump, jump2)
sol = solve(jump_prob, SSAStepper())</code></pre><p>see the <a href="https://diffeq.sciml.ai/stable/tutorials/discrete_stochastic_example/">tutorial</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqJump.jl/blob/f5ec8558a95f31a0fa2cac181c200e85ff144d2e/src/SSA_stepper.jl#L1">source</a></section></article><h2 id="Types-of-Jumps"><a class="docs-heading-anchor" href="#Types-of-Jumps">Types of Jumps</a><a id="Types-of-Jumps-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-Jumps" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DiffEqJump.MassActionJump" href="#DiffEqJump.MassActionJump"><code>DiffEqJump.MassActionJump</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MassActionJump{T, S, U, V} &lt;: DiffEqJump.AbstractMassActionJump</code></pre><p>Optimized representation for <code>ConstantRateJump</code>s that can be represented in mass action form, offering improved performance within jump algorithms compared to <code>ConstantRateJump</code>. For detailed examples and usage information see the</p><ul><li><a href="https://diffeq.sciml.ai/stable/types/jump_types/#Defining-a-Mass-Action-Jump">Main Docs</a></li><li><a href="https://diffeq.sciml.ai/stable/tutorials/discrete_stochastic_example/">Tutorial</a></li></ul><p><strong>Constructors</strong></p><ul><li><code>MassActionJump(reactant_stoich, net_stoich; scale_rates=true, param_idxs=nothing)</code></li></ul><p>Here <code>reactant_stoich</code> denotes the reactant stoichiometry for each reaction and <code>net_stoich</code> the net stoichiometry for each reaction. </p><p><strong>Fields</strong></p><ul><li><p><code>scaled_rates</code></p><p>The (scaled) reaction rate constants.</p></li><li><p><code>reactant_stoch</code></p><p>The reactant stoichiometry vectors.</p></li><li><p><code>net_stoch</code></p><p>The net stoichiometry vectors.</p></li><li><p><code>param_mapper</code></p><p>Parameter mapping functor to identify reaction rate constants with parameters in <code>p</code> vectors.</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>scale_rates=true</code>, whether to rescale the reaction rate constants according to the stoichiometry. </li><li><code>nocopy=false</code>, whether the <code>MassActionJump</code> can alias the <code>scaled_rates</code> and <code>reactant_stoch</code> from the input. Note, if <code>scale_rates=true</code> this will potentially modify both of these.</li><li><code>param_idxs=nothing</code>, indexes in the parameter vector, <code>JumpProblem.prob.p</code>, that correspond to each reaction&#39;s rate.</li></ul><p>See the tutorial and main docs for details.</p><p><strong>Examples</strong></p><p>An SIR model with <code>S + I --&gt; 2I</code> at rate β as the first reaction and <code>I --&gt; R</code> at rate ν as the second reaction can be encoded by</p><pre><code class="language-julia hljs">p        = (β=1e-4, ν=.01)
u0       = [999, 1, 0]       # (S,I,R)
tspan    = (0.0, 250.0)
rateidxs = [1, 2]           # i.e. [β,ν]
reactant_stoich =
[
  [1 =&gt; 1, 2 =&gt; 1],         # 1*S and 1*I
  [2 =&gt; 1]                  # 1*I
]
net_stoich =
[
  [1 =&gt; -1, 2 =&gt; 1],        # -1*S and 1*I
  [2 =&gt; -1, 3 =&gt; 1]         # -1*I and 1*R
]
maj = MassActionJump(reactant_stoich, net_stoich; param_idxs=rateidxs)
prob = DiscreteProblem(u0, tspan, p)
jprob = JumpProblem(prob, Direct(), maj)</code></pre><p><strong>Notes</strong></p><ul><li>By default reaction rates are rescaled when constructing the <code>MassActionJump</code> as explained in the <a href="https://diffeq.sciml.ai/stable/types/jump_types/#Defining-a-Mass-Action-Jump">main docs</a>. Disable this with the kwarg <code>scale_rates=false</code>.</li><li>Also see the <a href="https://diffeq.sciml.ai/stable/types/jump_types/#Defining-a-Mass-Action-Jump">main docs</a> for how to specify reactions with no products or no reactants.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqJump.jl/blob/f5ec8558a95f31a0fa2cac181c200e85ff144d2e/src/jumps.jl#L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqJump.ConstantRateJump" href="#DiffEqJump.ConstantRateJump"><code>DiffEqJump.ConstantRateJump</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConstantRateJump{F1, F2} &lt;: DiffEqJump.AbstractJump</code></pre><p>Defines a jump process with a rate (i.e. hazard, intensity, or propensity) that does not <em>explicitly</em> depend on time. More precisely, one where the rate function is constant <em>between</em> the occurrence of jumps. For detailed examples and usage information see the</p><ul><li><a href="https://diffeq.sciml.ai/stable/tutorials/discrete_stochastic_example/">Tutorial</a></li></ul><p><strong>Fields</strong></p><ul><li><p><code>rate</code></p><p>Function <code>rate(u,p,t)</code> that returns the jump&#39;s current rate.</p></li><li><p><code>affect!</code></p><p>Function <code>affect(integrator)</code> that updates the state for one occurrence of the jump.</p></li></ul><p><strong>Examples</strong></p><p>Suppose <code>u[1]</code> gives the amount of particles and <code>p[1]</code> the probability per time each particle can decay away. A corresponding <code>ConstantRateJump</code> for this jump process is</p><pre><code class="language-julia hljs">rate(u,p,t) = p[1]*u[1]
affect!(integrator) = integrator.u[1] -= 1
crj = ConstantRateJump(rate, affect!)</code></pre><p>Notice, here that <code>rate</code> changes in time, but is constant between the occurrence of jumps (when <code>u[1]</code> will decrease).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqJump.jl/blob/f5ec8558a95f31a0fa2cac181c200e85ff144d2e/src/jumps.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqJump.VariableRateJump" href="#DiffEqJump.VariableRateJump"><code>DiffEqJump.VariableRateJump</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct VariableRateJump{R, F, I, T, T2} &lt;: DiffEqJump.AbstractJump</code></pre><p>Defines a jump process with a rate (i.e. hazard, intensity, or propensity) that may explicitly depend on time. More precisely, one where the rate function is allowed to change <em>between</em> the occurrence of jumps. For detailed examples and usage information see the</p><ul><li><a href="https://diffeq.sciml.ai/stable/tutorials/discrete_stochastic_example/">Tutorial</a></li></ul><p><strong>Fields</strong></p><ul><li><p><code>rate</code></p><p>Function <code>rate(u,p,t)</code> that returns the jump&#39;s current rate.</p></li><li><p><code>affect!</code></p><p>Function <code>affect(integrator)</code> that updates the state for one occurrence of the jump.</p></li><li><p><code>idxs</code></p></li><li><p><code>rootfind</code></p></li><li><p><code>interp_points</code></p></li><li><p><code>save_positions</code></p></li><li><p><code>abstol</code></p></li><li><p><code>reltol</code></p></li></ul><p><strong>Examples</strong></p><p>Suppose <code>u[1]</code> gives the amount of particles and <code>t*p[1]</code> the probability per time each particle can decay away. A corresponding <code>VariableRateJump</code> for this jump process is</p><pre><code class="language-julia hljs">rate(u,p,t) = t*p[1]*u[1]
affect!(integrator) = integrator.u[1] -= 1
crj = VariableRateJump(rate, affect!)</code></pre><p><strong>Notes</strong></p><ul><li><strong><code>VariableRateJump</code>s result in <code>integrator</code>s storing an effective state type that wraps the main state vector.</strong> See <a href="#DiffEqJump.ExtendedJumpArray"><code>ExtendedJumpArray</code></a> for details on using this object. Note that the presence of <em>any</em> <code>VariableRateJump</code>s will result in all <code>ConstantRateJump</code>, <code>VariableRateJump</code> and callback <code>affect!</code> functions receiving an integrator with <code>integrator.u</code> an <a href="#DiffEqJump.ExtendedJumpArray"><code>ExtendedJumpArray</code></a>.</li><li>Must be used with <code>ODEProblem</code>s or <code>SDEProblem</code>s to be correctly simulated (i.e. can not currently be used with <code>DiscreteProblem</code>s).</li><li>Salis H., Kaznessis Y.,  Accurate hybrid stochastic simulation of a system of coupled chemical or biochemical reactions, Journal of Chemical Physics, 122 (5), DOI:10.1063/1.1835951 is used for calculating jump times with <code>VariableRateJump</code>s within ODE/SDE integrators.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqJump.jl/blob/f5ec8558a95f31a0fa2cac181c200e85ff144d2e/src/jumps.jl#L33">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>RegularJump</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Aggregators"><a class="docs-heading-anchor" href="#Aggregators">Aggregators</a><a id="Aggregators-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregators" title="Permalink"></a></h2><p>Aggregators are the underlying algorithms used for sampling <a href="#DiffEqJump.MassActionJump"><code>MassActionJump</code></a>s and <a href="#DiffEqJump.ConstantRateJump"><code>ConstantRateJump</code></a>s.</p><article class="docstring"><header><a class="docstring-binding" id="DiffEqJump.Direct" href="#DiffEqJump.Direct"><code>DiffEqJump.Direct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Gillespie&#39;s Direct method. <code>ConstantRateJump</code> rates and affects are stored in tuples. Fastest for a small (total) number of <code>ConstantRateJump</code>s or <code>MassActionJump</code>s (~10). For larger numbers of possible jumps use other methods.</p><p>Gillespie, Daniel T. (1976). A General Method for Numerically Simulating the Stochastic Time Evolution of Coupled Chemical Reactions. Journal of Computational Physics. 22 (4): 403–434. doi:10.1016/0021-9991(76)90041-3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqJump.jl/blob/f5ec8558a95f31a0fa2cac181c200e85ff144d2e/src/aggregators/aggregators.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqJump.DirectCR" href="#DiffEqJump.DirectCR"><code>DiffEqJump.DirectCR</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Composition-Rejection Direct method. Performs best relative to other methods for systems with large numbers of jumps with special structure (for example a linear chain of reactions, or jumps corresponding to particles hopping on a grid or graph).</p><ul><li><p>A. Slepoy, A.P. Thompson and S.J. Plimpton, A constant-time kinetic Monte Carlo algorithm for simulation of large biochemical reaction networks, Journal of Chemical Physics, 128 (20), 205101 (2008). doi:10.1063/1.2919546</p></li><li><p>S. Mauch and M. Stalzer, Efficient formulations for exact stochastic simulation of chemical systems, ACM Transactions on Computational Biology and Bioinformatics, 8 (1), 27-35 (2010). doi:10.1109/TCBB.2009.47</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqJump.jl/blob/f5ec8558a95f31a0fa2cac181c200e85ff144d2e/src/aggregators/aggregators.jl#L30-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqJump.FRM" href="#DiffEqJump.FRM"><code>DiffEqJump.FRM</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Gillespie&#39;s First Reaction Method. Should not be used for practical applications due to slow performance relative to all other methods.</p><p>Gillespie, Daniel T. (1976). A General Method for Numerically Simulating the Stochastic Time Evolution of Coupled Chemical Reactions. Journal of Computational Physics. 22 (4): 403–434. doi:10.1016/0021-9991(76)90041-3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqJump.jl/blob/f5ec8558a95f31a0fa2cac181c200e85ff144d2e/src/aggregators/aggregators.jl#L90-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqJump.NRM" href="#DiffEqJump.NRM"><code>DiffEqJump.NRM</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Next Reaction Method. Can significantly outperform Direct for systems with large numbers of jumps and sparse dependency graphs, but is usually slower than one of <code>DirectCR</code>, <code>RSSA</code>, or <code>RSSACR</code> for such systems.</p><p>M. A. Gibson and J. Bruck, Efficient exact stochastic simulation of chemical systems with many species and many channels, Journal of Physical Chemistry A, 104 (9), 1876-1889 (2000). doi:10.1021/jp993732q</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqJump.jl/blob/f5ec8558a95f31a0fa2cac181c200e85ff144d2e/src/aggregators/aggregators.jl#L111-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqJump.RDirect" href="#DiffEqJump.RDirect"><code>DiffEqJump.RDirect</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A rejection-based direct method. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqJump.jl/blob/f5ec8558a95f31a0fa2cac181c200e85ff144d2e/src/aggregators/aggregators.jl#L83-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqJump.RSSA" href="#DiffEqJump.RSSA"><code>DiffEqJump.RSSA</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Rejection SSA method. One of the best methods for systems with hundreds to many thousands of jumps (along with <code>RSSACR</code>) and sparse dependency graphs.</p><ul><li><p>V. H. Thanh, C. Priami and R. Zunino, Efficient rejection-based simulation of biochemical reactions with stochastic noise and delays, Journal of Chemical Physics, 141 (13), 134116 (2014). doi:10.1063/1.4896985</p></li><li><p>V. H. Thanh, R. Zunino and C. Priami, On the rejection-based algorithm for simulation and analysis of large-scale reaction networks, Journal of Chemical Physics, 142 (24), 244106 (2015). doi:10.1063/1.4922923</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqJump.jl/blob/f5ec8558a95f31a0fa2cac181c200e85ff144d2e/src/aggregators/aggregators.jl#L58-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqJump.RSSACR" href="#DiffEqJump.RSSACR"><code>DiffEqJump.RSSACR</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Rejection SSA Composition-Rejection method. Often the best performer for systems with tens of thousands of jumps and sparse depedency graphs.</p><p>V. H. Thanh, R. Zunino, and C. Priami, Efficient Constant-Time Complexity Algorithm for Stochastic Simulation of Large Reaction Networks, IEEE/ACM Transactions on Computational Biology and Bioinformatics, Vol. 14, No. 3, 657-667 (2017).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqJump.jl/blob/f5ec8558a95f31a0fa2cac181c200e85ff144d2e/src/aggregators/aggregators.jl#L72-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqJump.SortingDirect" href="#DiffEqJump.SortingDirect"><code>DiffEqJump.SortingDirect</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Sorting Direct method. Often the fastest algorithm for smaller to moderate sized systems (tens of jumps), or systems where a few jumps occur much more frequently than others.</p><p>J. M. McCollum, G. D. Peterson, C. D. Cox, M. L. Simpson and N. F. Samatova, The   sorting direct method for stochastic simulation of biochemical systems with   varying reaction execution behavior, Computational Biology and Chemistry, 30   (1), 39049 (2006). doi:10.1016/j.compbiolchem.2005.10.007</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqJump.jl/blob/f5ec8558a95f31a0fa2cac181c200e85ff144d2e/src/aggregators/aggregators.jl#L46-L55">source</a></section></article><h1 id="Private-API-Functions"><a class="docs-heading-anchor" href="#Private-API-Functions">Private API Functions</a><a id="Private-API-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Private-API-Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="DiffEqJump.ExtendedJumpArray" href="#DiffEqJump.ExtendedJumpArray"><code>DiffEqJump.ExtendedJumpArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExtendedJumpArray{T3&lt;:Number, T1, T&lt;:AbstractArray{T3&lt;:Number, T1}, T2} &lt;: AbstractArray{T3&lt;:Number, 1}</code></pre><p>Extended state definition used within integrators when there are <code>VariableRateJump</code>s in a system. For detailed examples and usage information see the</p><ul><li><a href="https://diffeq.sciml.ai/stable/tutorials/discrete_stochastic_example/">Tutorial</a></li></ul><p><strong>Fields</strong></p><ul><li><p><code>u</code></p><p>The current state.</p></li><li><p><code>jump_u</code></p><p>The current rate (i.e. hazard, intensity, or propensity) values for the <code>VariableRateJump</code>s.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using DiffEqJump, OrdinaryDiffEq
f(du,u,p,t) = du .= 0
rate(u,p,t) = (1+t)*u[1]*u[2]

# suppose we wish to decrease each of the two variables by one
# when a jump occurs
function affect!(integrator) 
   # Method 1, direct indexing works like normal
   integrator.u[1] -= 1
   integrator.u[2] -= 1

   # Method 2, if we want to broadcast or use array operations we need
   # to access integrator.u.u which is the actual state object. 
   # So equivalently to above we could have said:
   # integrator.u.u .-= 1
end

u0 = [10.0, 10.0]
vrj = VariableRateJump(rate, affect!)
oprob = ODEProblem(f, u0, (0.0,2.0))
jprob = JumpProblem(oprob, Direct(), vrj)
sol = solve(jprob,Tsit5())</code></pre><p><strong>Notes</strong></p><ul><li><p>If <code>ueja isa ExtendedJumpArray</code> with <code>ueja.u</code> of size <code>N</code> and <code>ueja.jump_u</code> of size <code>num_variableratejumps</code> then</p><pre><code class="language-julia hljs"># for 1 &lt;= i &lt;= N
ueja[i] == ueja.u[i]       

# for N &lt; i &lt;= (N+num_variableratejumps)
ueja[i] == ueja.jump_u[i]  </code></pre></li><li><p>In a system with <code>VariableRateJump</code>s all callback, <code>ConstantRateJump</code>, and <code>VariableRateJump</code> <code>affect!</code> functions will receive integrators with <code>integrator.u</code> an <code>ExtendedJumpArray</code>.</p></li><li><p>As such, <code>affect!</code> functions that wish to modify the state via vector operations should use <code>ueja.u.u</code> to obtain the aliased state object.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqJump.jl/blob/f5ec8558a95f31a0fa2cac181c200e85ff144d2e/src/extended_jump_array.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffEqJump.SSAIntegrator" href="#DiffEqJump.SSAIntegrator"><code>DiffEqJump.SSAIntegrator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct SSAIntegrator{F, uType, tType, tdirType, P, S, CB, SA, OPT, TS} &lt;: SciMLBase.DEIntegrator{SSAStepper, Nothing, uType, tType}</code></pre><p>Solution objects for pure jump problems solved via <code>SSAStepper</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>f</code></p><p>The underlying <code>prob.f</code> function. Not currently used.</p></li><li><p><code>u</code></p><p>The current solution values.</p></li><li><p><code>t</code></p><p>The current solution time.</p></li><li><p><code>tprev</code></p><p>The previous time a jump occured.</p></li><li><p><code>tdir</code></p><p>The direction time is changing in (must be positive indicating time is increasing)</p></li><li><p><code>p</code></p><p>The current parameters.</p></li><li><p><code>sol</code></p><p>The current solution object.</p></li><li><p><code>i</code></p></li><li><p><code>tstop</code></p><p>The next jump time.</p></li><li><p><code>cb</code></p><p>The jump aggregator callback.</p></li><li><p><code>saveat</code></p><p>Times to save the solution at.</p></li><li><p><code>save_everystep</code></p><p>Whether to save everytime a jump occurs.</p></li><li><p><code>save_end</code></p><p>Whether to save at the final step.</p></li><li><p><code>cur_saveat</code></p><p>Index of the next <code>saveat</code> time.</p></li><li><p><code>opts</code></p><p>Tuple storing callbacks.</p></li><li><p><code>tstops</code></p><p>User supplied times to step to, useful with callbacks.</p></li><li><p><code>tstops_idx</code></p></li><li><p><code>u_modified</code></p></li><li><p><code>keep_stepping</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqJump.jl/blob/f5ec8558a95f31a0fa2cac181c200e85ff144d2e/src/SSA_stepper.jl#L43">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../jump_solve/">« Jump solvers</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Thursday 23 June 2022 16:21">Thursday 23 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
