<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Continuous-Time Jump Processes and Gillespie Methods · JumpProcesses.jl</title><meta name="title" content="Continuous-Time Jump Processes and Gillespie Methods · JumpProcesses.jl"/><meta property="og:title" content="Continuous-Time Jump Processes and Gillespie Methods · JumpProcesses.jl"/><meta property="twitter:title" content="Continuous-Time Jump Processes and Gillespie Methods · JumpProcesses.jl"/><meta name="description" content="Documentation for JumpProcesses.jl."/><meta property="og:description" content="Documentation for JumpProcesses.jl."/><meta property="twitter:description" content="Documentation for JumpProcesses.jl."/><meta property="og:url" content="https://docs.sciml.ai/JumpProcesses/tutorials/discrete_stochastic_example/"/><meta property="twitter:url" content="https://docs.sciml.ai/JumpProcesses/tutorials/discrete_stochastic_example/"/><link rel="canonical" href="https://docs.sciml.ai/JumpProcesses/tutorials/discrete_stochastic_example/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JumpProcesses.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JumpProcesses.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../simple_poisson_process/">Simple Poisson Processes in JumpProcesses</a></li><li class="is-active"><a class="tocitem" href>Continuous-Time Jump Processes and Gillespie Methods</a><ul class="internal"><li><a class="tocitem" href="#Illustrative-Model:-SIR-Disease-Dynamics"><span>Illustrative Model: SIR Disease Dynamics</span></a></li><li><a class="tocitem" href="#Specifying-the-SIR-Model-with-Chemical-Reactions"><span>Specifying the SIR Model with Chemical Reactions</span></a></li><li><a class="tocitem" href="#Building-and-Simulating-the-Jump-Processes-from-Catalyst-Models"><span>Building and Simulating the Jump Processes from Catalyst Models</span></a></li><li><a class="tocitem" href="#Building-and-Simulating-the-Jump-Process-Using-the-JumpProcesses-Low-Level-Interface"><span>Building and Simulating the Jump Process Using the JumpProcesses Low-Level Interface</span></a></li><li><a class="tocitem" href="#ConstantRateJumpSect"><span>Defining the Jumps Directly: <code>ConstantRateJump</code></span></a></li><li><a class="tocitem" href="#SSAStepper"><span>SSAStepper</span></a></li><li><a class="tocitem" href="#MassActionJumpSect"><span>Defining the Jumps Directly: <code>MassActionJump</code></span></a></li><li><a class="tocitem" href="#VariableRateJumpWithBnds"><span>Defining the Jumps Directly using a bounded <code>VariableRateJump</code></span></a></li><li><a class="tocitem" href="#save_positions_docs"><span>Reducing Memory Use: Controlling Saving Behavior</span></a></li><li><a class="tocitem" href="#Defining-the-Jumps-Directly:-Mixing-ConstantRateJump/VariableRateJump-and-MassActionJump"><span>Defining the Jumps Directly: Mixing <code>ConstantRateJump</code>/<code>VariableRateJump</code> and <code>MassActionJump</code></span></a></li><li><a class="tocitem" href="#Adding-Jumps-to-a-Differential-Equation"><span>Adding Jumps to a Differential Equation</span></a></li><li><a class="tocitem" href="#VariableRateJumpSect"><span>Adding a general VariableRateJump that Depends on a Continuously Evolving Variable</span></a></li><li><a class="tocitem" href="#RegularJumps-and-τ-Leaping"><span>RegularJumps and τ-Leaping</span></a></li></ul></li><li><a class="tocitem" href="../point_process_simulation/">Temporal Point Process (TPP) Simulation</a></li><li><a class="tocitem" href="../jump_diffusion/">Piecewise Deterministic Markov Processes and Jump Diffusion Equations</a></li><li><a class="tocitem" href="../spatial/">Spatial SSAs with JumpProcesses.jl</a></li></ul></li><li><span class="tocitem">Applications</span><ul><li><a class="tocitem" href="../../applications/advanced_point_process/">Temporal Point Processes (TPP) with JumpProcesses and PointProcesses</a></li></ul></li><li><span class="tocitem">Type Documentation</span><ul><li><a class="tocitem" href="../../jump_types/">Jumps, JumpProblem, and Aggregators</a></li><li><a class="tocitem" href="../../jump_solve/">Jump solvers</a></li></ul></li><li><a class="tocitem" href="../../faq/">FAQ</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Continuous-Time Jump Processes and Gillespie Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Continuous-Time Jump Processes and Gillespie Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/JumpProcesses.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/JumpProcesses.jl/blob/master/docs/src/tutorials/discrete_stochastic_example.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ssa_tutorial"><a class="docs-heading-anchor" href="#ssa_tutorial">Continuous-Time Jump Processes and Gillespie Methods</a><a id="ssa_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#ssa_tutorial" title="Permalink"></a></h1><p>In this tutorial, we will describe how to define and simulate continuous-time jump (or point) processes, also known in biological fields as stochastic chemical kinetics (i.e., Gillespie) models. It is not necessary to have read the <a href="../simple_poisson_process/#poisson_proc_tutorial">first tutorial</a>. We will illustrate:</p><ul><li>The different types of jumps that can be represented in JumpProcesses and their use cases.</li><li>How to speed up pure-jump simulations with only <a href="../../api/#JumpProcesses.ConstantRateJump"><code>ConstantRateJump</code></a>s, <a href="../../api/#JumpProcesses.MassActionJump"><code>MassActionJump</code></a>s, and bounded <code>VariableRateJump</code>s by using the <a href="#SSAStepper"><code>SSAStepper</code></a> time stepper.</li><li>How to define and use <a href="../../api/#JumpProcesses.MassActionJump"><code>MassActionJump</code></a>s, a more specialized type of <a href="../../api/#JumpProcesses.ConstantRateJump"><code>ConstantRateJump</code></a> that offers improved computational performance.</li><li>How to define and use bounded <a href="../../api/#JumpProcesses.VariableRateJump"><code>VariableRateJump</code></a>s in pure-jump simulations.</li><li>How to use saving controls to reduce memory use per simulation.</li><li>How to use general <a href="../../api/#JumpProcesses.VariableRateJump"><code>VariableRateJump</code></a>s and when they should be preferred over the other jump types.</li><li>How to create hybrid problems, mixing the various jump types with ODEs or SDEs.</li><li>How to use <code>RegularJump</code>s to enable faster, but approximate, time stepping via τ-leaping methods.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This tutorial assumes you have read the <a href="https://docs.sciml.ai/DiffEqDocs/stable/getting_started/">Ordinary Differential Equations tutorial</a> in <a href="https://docs.sciml.ai/DiffEqDocs/stable"><code>DifferentialEquations.jl</code></a>.</p></div></div><p>We begin by demonstrating how to build jump processes using <a href="https://docs.sciml.ai/JumpProcesses/stable/">JumpProcesses.jl</a>&#39;s different jump types, which encode the rate functions (i.e., transition rates, intensities, or propensities) and state changes when a given jump occurs.</p><p>Note, the SIR model considered here is a type of stochastic chemical kinetics jump process model, and as such the biological modeling functionality of <a href="https://docs.sciml.ai/Catalyst/stable/">Catalyst.jl</a> can be used to easily specify the model and automatically calculate inputs needed for JumpProcesses&#39;s optimized simulation algorithms. We summarize this alternative approach at the beginning for users who may be interested in modeling chemical systems, but note this tutorial is intended to explain the general jump process formulation of JumpProcesses for all users. However, for those users constructing models that can be represented as a collection of chemical reactions we strongly recommend using Catalyst, which should ensure optimal jump types are selected to represent each reaction, and necessary data structures for the simulation algorithms, such as dependency graphs, are automatically calculated.</p><p>We&#39;ll make use of the <a href="https://docs.sciml.ai/DiffEqDocs/stable/">DifferentialEquations.jl</a> meta package, which includes JumpProcesses and ODE/SDE solvers, Plots.jl, and (optionally) Catalyst.jl in this tutorial. If not already installed, they can be added as follows:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;DifferentialEquations&quot;)
Pkg.add(&quot;Plots&quot;)
Pkg.add(&quot;Catalyst&quot;)                # optional</code></pre><p>Let&#39;s now load the required packages and set some default plot settings</p><pre><code class="language-julia hljs">using DifferentialEquations, Plots, LinearAlgebra
default(; lw = 2)</code></pre><h2 id="Illustrative-Model:-SIR-Disease-Dynamics"><a class="docs-heading-anchor" href="#Illustrative-Model:-SIR-Disease-Dynamics">Illustrative Model: SIR Disease Dynamics</a><a id="Illustrative-Model:-SIR-Disease-Dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Illustrative-Model:-SIR-Disease-Dynamics" title="Permalink"></a></h2><p>To illustrate the jump process solvers, we will build an SIR model which matches the tutorial from <a href="https://github.com/sdwfrost/Gillespie.jl">Gillespie.jl</a>. SIR stands for susceptible, infected, and recovered, and is a model of disease spread. When a susceptible person comes in contact with an infected person, the disease has a chance of infecting the susceptible person. This &quot;chance&quot; is determined by the number of susceptible persons and the number of infected persons, since in larger populations there is a greater chance that two people come into contact. Every infected person will in turn have a rate at which they recover. In our model, we&#39;ll assume there are no births or deaths, and a recovered individual is protected from reinfection.</p><p>We&#39;ll begin by giving the mathematical equations for the jump processes of the number of susceptible (<span>$S(t)$</span>), number of infected (<span>$I(t)$</span>), and number of recovered (<span>$R(t)$</span>). In the next section, we give a more intuitive and biological description of the model for users that are less familiar with jump processes. Let <span>$Y_i(t)$</span>, <span>$i = 1,2$</span>, denote independent unit Poisson processes. Our basic mathematical model for the evolution of <span>$(S(t),I(t),R(t))$</span>, written using Kurtz&#39;s time-change representation, is then</p><p class="math-container">\[\begin{aligned}
S(t) &amp;= S(0) - Y_1\left(  \int_0^t \beta S(s^{-}) I(s^{-}) \, ds\right) \\
I(t) &amp;= I(0) + Y_1\left(  \int_0^t \beta S(s^{-}) I(s^{-}) \, ds\right)
        - Y_2 \left( \int_0^t \nu I(s^-)  \, ds \right) \\
R(t) &amp;= R(0) + Y_2 \left( \int_0^t \nu I(s^-)  \, ds \right)
\end{aligned}\]</p><p>Notice, our model involves two jump processes with rate functions, also known as intensities or propensities, given by <span>$\beta S(t) I(t)$</span> and <span>$\nu I(t)$</span> respectively. These give the probability per time a new infected individual is created, and the probability per time some infected individual recovers.</p><p>For those less-familiar with the time-change representation, we next give a more intuitive explanation of the model as a collection of chemical reactions, and then demonstrate how these reactions can be written in <a href="https://docs.sciml.ai/Catalyst/stable/">Catalyst.jl</a> and seamlessly converted into a form that can be used with the <a href="https://docs.sciml.ai/JumpProcesses/stable/">JumpProcesses.jl</a> solvers. Users interested in how to directly define jumps using the lower-level JumpProcesses interface can skip to <a href="#Building-and-Simulating-the-Jump-Process-Using-the-JumpProcesses-Low-Level-Interface">Building and Simulating the Jump Process Using the JumpProcesses Low-Level Interface</a>.</p><h2 id="Specifying-the-SIR-Model-with-Chemical-Reactions"><a class="docs-heading-anchor" href="#Specifying-the-SIR-Model-with-Chemical-Reactions">Specifying the SIR Model with Chemical Reactions</a><a id="Specifying-the-SIR-Model-with-Chemical-Reactions-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-the-SIR-Model-with-Chemical-Reactions" title="Permalink"></a></h2><p>The SIR model described above involves two basic chemical reactions,</p><p class="math-container">\[\begin{aligned}
S + I &amp;\overset{\beta}{\to} 2 I \\
I &amp;\overset{\nu}{\to} R,
\end{aligned}\]</p><p>where <span>$\beta$</span> and <span>$\nu$</span> are the rate constants of the reactions (with units of probability per time). In a jump process (stochastic chemical kinetics) model, we keep track of the non-negative integer number of each species at each time (i.e., <span>$(S(t), I(t), R(t))$</span> above). Each reaction has an associated rate function (i.e., intensity or propensity) giving the probability per time it can occur when the system is in state <span>$(S(t),I(t),R(t))$</span>:</p><p class="math-container">\[\begin{matrix}
\text{Reaction} &amp; \text{Rate Functions} \\
\hline
S + I \overset{\beta}{\to} 2 I &amp; \beta S(t) I(t) \\
I \overset{\nu}{\to} R &amp; \nu I(t).
\end{matrix}\]</p><p><span>$\beta$</span> is determined by factors like the type of the disease. It can be interpreted as the probability per time one pair of susceptible and infected people encounter each other, with the susceptible person becoming sick. The overall rate (i.e., probability per time) that some susceptible person gets sick is then given by the rate constant multiplied by the number of possible pairs of susceptible and infected people. This formulation is known as the <a href="https://en.wikipedia.org/wiki/Law_of_mass_action">law of mass action</a>. Similarly, we have that each individual infected person is assumed to recover with probability per time <span>$\nu$</span>, so that the probability per time <em>some</em> infected person recovers is <span>$\nu$</span> times the number of infected people, i.e., <span>$\nu I(t)$</span>.</p><p>Rate functions give the probability per time for each of the two types of jumps to occur, and hence determine when the state of our system changes. To fully specify our model, we also need to specify how the state changes when a jump occurs, giving what are called <code>affect!</code> functions in JumpProcesses. For example, when the <span>$S + I \to 2 I$</span> reaction occurs, and some susceptible person becomes infected, the subsequent (instantaneous) state change is that</p><p class="math-container">\[\begin{aligned}
S &amp;\to S - 1 &amp; I &amp;\to I + 1.
\end{aligned}\]</p><p>Likewise, when the <span>$I \to R$</span> reaction occurs so that some infected person becomes recovered, the state change is</p><p class="math-container">\[\begin{aligned}
I &amp;\to I - 1 &amp; R \to R + 1.
\end{aligned}\]</p><p>In summary, our model is described by two chemical reactions, which each in turn correspond to a jump process determined by a <code>rate</code> function specifying how frequently jumps should occur, and an <code>affect!</code> function for how the state should change when that jump type occurs.</p><h2 id="Building-and-Simulating-the-Jump-Processes-from-Catalyst-Models"><a class="docs-heading-anchor" href="#Building-and-Simulating-the-Jump-Processes-from-Catalyst-Models">Building and Simulating the Jump Processes from Catalyst Models</a><a id="Building-and-Simulating-the-Jump-Processes-from-Catalyst-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Building-and-Simulating-the-Jump-Processes-from-Catalyst-Models" title="Permalink"></a></h2><p>Using <a href="https://docs.sciml.ai/Catalyst/stable/">Catalyst.jl</a> we can input our full reaction network in a form that can be easily used with JumpProcesses&#39;s solvers</p><pre><code class="language-julia hljs">using Catalyst
sir_model = @reaction_network begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{S} + \mathrm{I} &amp;\xrightarrow{\beta} 2 \mathrm{I} \\
\mathrm{I} &amp;\xrightarrow{\nu} \mathrm{R}  
 \end{align*}
 \]</p><p>To build a pure jump process model of the reaction system, where the state is constant between jumps, we will use a <a href="https://docs.sciml.ai/DiffEqDocs/stable/types/discrete_types/"><code>DiscreteProblem</code></a>. This encodes that the state only changes at the jump times. We do this by giving the constructor <code>u₀</code>, the initial condition, and <code>tspan</code>, the timespan. Here, we will start with <span>$990$</span> susceptible people, <span>$10$</span> infected person, and <code>0</code> recovered people, and solve the problem from <code>t=0.0</code> to <code>t=250.0</code>. We use the parameters <code>β = 0.1/1000</code> and <code>ν = 0.01</code>. Thus, we build the problem via:</p><pre><code class="language-julia hljs">p = (:β =&gt; 0.1 / 1000, :ν =&gt; 0.01)
u₀ = [:S =&gt; 990, :I =&gt; 10, :R =&gt; 0]
tspan = (0.0, 250.0)
prob = DiscreteProblem(sir_model, u₀, tspan, p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">DiscreteProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Int64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
timespan: (0.0, 250.0)
u0: 3-element Vector{Int64}:
 990
  10
   0</code></pre><p><em>Notice, the initial populations are integers, since we want the exact number of people in the different states.</em></p><p>The Catalyst reaction network can be converted into various DifferentialEquations.jl problem types, including <code>JumpProblem</code>s, <code>ODEProblem</code>s, or <code>SDEProblem</code>s. To turn it into a <a href="../../api/#JumpProcesses.JumpProblem"><code>JumpProblem</code></a> representing the SIR jump process model, we simply write</p><pre><code class="language-julia hljs">jump_prob = JumpProblem(sir_model, prob, Direct())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">JumpProblem</span> with problem <span class="sgr38_2" style="color:#56b6c2">DiscreteProblem</span> with aggregator <span class="sgr38_2" style="color:#56b6c2">Direct
Number of jumps with discrete aggregation: 0
Number of jumps with continuous aggregation: 0
Number of mass action jumps: 2
</span></code></pre><p>Here <code>Direct()</code> indicates that we will determine the random times and types of reactions using <a href="https://doi.org/10.1016/0021-9991(76)90041-3">Gillespie&#39;s Direct stochastic simulation algorithm (SSA)</a>, also known as Doob&#39;s method or Kinetic Monte Carlo. See <a href="../../jump_types/#Jump-Aggregators-for-Exact-Simulation">Jump Aggregators for Exact Simulation</a> for other supported SSAs.</p><p>We now have a problem that can be evolved in time using the JumpProcesses solvers. Since our model is a pure jump process (no continuously-varying components), we will use <code>SSAStepper()</code> to handle time-stepping the <code>Direct</code> method from jump to jump:</p><pre><code class="language-julia hljs">sol = solve(jump_prob, SSAStepper())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: Piecewise constant interpolation
t: 1859-element Vector{Float64}:
   0.0
   0.195283834098839
   0.7687612600825953
   2.0165284468970244
   2.5505978503215725
   3.5061577891626503
   3.51954889507254
   4.472406254420325
   4.581701581338265
   4.653207068671664
   ⋮
 243.76710902312465
 244.82761178758494
 247.58932232733312
 247.67753357904067
 247.733029998828
 248.23510005727132
 248.2884435078044
 249.1970861311922
 250.0
u: 1859-element Vector{Vector{Int64}}:
 [990, 10, 0]
 [989, 11, 0]
 [988, 12, 0]
 [987, 13, 0]
 [986, 14, 0]
 [986, 13, 1]
 [985, 14, 1]
 [984, 15, 1]
 [983, 16, 1]
 [982, 17, 1]
 ⋮
 [0, 140, 860]
 [0, 139, 861]
 [0, 138, 862]
 [0, 137, 863]
 [0, 136, 864]
 [0, 135, 865]
 [0, 134, 866]
 [0, 133, 867]
 [0, 133, 867]</code></pre><p>This solve command takes the standard commands of the common interface, and the solution object acts just like any other differential equation solution. Thus, there exists a plot recipe, which we can plot with:</p><pre><code class="language-julia hljs">plot(sol)</code></pre><img src="ad25c514.svg" alt="Example block output"/><h2 id="Building-and-Simulating-the-Jump-Process-Using-the-JumpProcesses-Low-Level-Interface"><a class="docs-heading-anchor" href="#Building-and-Simulating-the-Jump-Process-Using-the-JumpProcesses-Low-Level-Interface">Building and Simulating the Jump Process Using the JumpProcesses Low-Level Interface</a><a id="Building-and-Simulating-the-Jump-Process-Using-the-JumpProcesses-Low-Level-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Building-and-Simulating-the-Jump-Process-Using-the-JumpProcesses-Low-Level-Interface" title="Permalink"></a></h2><p>We now show how to directly use JumpProcesses&#39;s low-level interface to construct and solve our jump process model for <span>$(S(t),I(t),R(t))$</span>. Each individual jump that can occur is represented through specifying two pieces of information; a <code>rate</code> function (i.e., intensity or propensity) for the jump and an <code>affect!</code> function for the jump. The former gives the probability per time a particular jump can occur given the current state of the system, and hence determines the time at which jumps can happen. The latter specifies the instantaneous change in the state of the system when the jump occurs.</p><p>In our SIR model, we have two possible jumps that can occur (one for susceptibles becoming infected and one for infected becoming recovered), with the corresponding (mathematical) rates and affects given by</p><p class="math-container">\[\begin{matrix}
\text{Rates} &amp; \text{Affects}\\
\hline
\beta S(t) I(t) &amp; S \to S - 1,\, I \to I + 1 \\
\nu I(t) &amp; I \to I - 1, \, R \to R + 1.
\end{matrix}\]</p><p>JumpProcesses offers three different ways to (exactly) represent jumps: <code>MassActionJump</code>, <code>ConstantRateJump</code>, and <code>VariableRateJump</code>. Choosing which to use is a trade-off between the desired generality of the <code>rate</code> and <code>affect!</code> functions vs. the computational performance of the resulting simulated system. In general</p><table><tr><th style="text-align: center">Jump Type</th><th style="text-align: center">Performance</th><th style="text-align: center">Generality</th></tr><tr><td style="text-align: center"><a href="#MassActionJumpSect"><code>MassActionJump</code></a></td><td style="text-align: center">Fastest</td><td style="text-align: center">Restrictive rates/affects</td></tr><tr><td style="text-align: center"><a href="#ConstantRateJumpSect"><code>ConstantRateJump</code></a></td><td style="text-align: center">Somewhat Slower than <code>MassActionJump</code></td><td style="text-align: center">Rate function must be constant between jumps</td></tr><tr><td style="text-align: center"><a href="#VariableRateJumpWithBnds"><code>VariableRateJump</code> with rate bounds</a></td><td style="text-align: center">Somewhat Slower than <code>ConstantRateJump</code></td><td style="text-align: center">Rate functions can explicitly depend on time, but require an upper bound that is guaranteed constant between jumps over some time interval</td></tr><tr><td style="text-align: center"><a href="#VariableRateJumpSect"><code>VariableRateJump</code></a></td><td style="text-align: center">Slowest</td><td style="text-align: center">Completely general</td></tr></table><p>It is recommended to try to encode jumps using the most performant option that supports the desired generality of the underlying <code>rate</code> and <code>affect!</code> functions. Below we describe the different jump types, and show how the SIR model can be formulated using first <code>ConstantRateJump</code>s, then more performant <code>MassActionJump</code>s, and finally with <code>VariableRateJump</code>s using rate bounds. We conclude by presenting several completely general models that use <code>VariableRateJump</code>s without rate bounds, and which require an ODE solver to handle time-stepping.</p><p>We note, in the remainder we will refer to <em>bounded</em> <code>VariableRateJump</code>s as those for which we can specify functions calculating a time window over which the rate is bounded by a constant (as long as the state is unchanged), see <a href="#VariableRateJumpWithBnds">the section on bounded <code>VariableRateJump</code>s for details</a>. <code>VariableRateJump</code>s or <em>general</em> <code>VariableRateJump</code>s will refer to those for which such functions are not available.</p><h2 id="ConstantRateJumpSect"><a class="docs-heading-anchor" href="#ConstantRateJumpSect">Defining the Jumps Directly: <code>ConstantRateJump</code></a><a id="ConstantRateJumpSect-1"></a><a class="docs-heading-anchor-permalink" href="#ConstantRateJumpSect" title="Permalink"></a></h2><p>The constructor for a <code>ConstantRateJump</code> is:</p><pre><code class="language-julia hljs">jump = ConstantRateJump(rate, affect!)</code></pre><p>where <code>rate</code> is a function <code>rate(u,p,t)</code> and <code>affect!</code> is a function of the integrator <code>affect!(integrator)</code> (for details on the integrator, see the <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/integrator/">integrator interface docs</a>). Here <code>u</code> corresponds to the current state vector of the system; for our SIR model <code>u[1] = S(t)</code>, <code>u[2] = I(t)</code> and <code>u[3] = R(t)</code>. <code>p</code> corresponds to the parameters of the model, just as used for passing parameters to derivative functions in ODE solvers. Thus, to define the two possible jumps for our model, we take (with <code>β = .1/1000.0</code> and <code>ν = .01</code>).</p><pre><code class="language-julia hljs">β = 0.1 / 1000.0
ν = 0.01;
p = (β, ν)
rate1(u, p, t) = p[1] * u[1] * u[2]  # β*S*I
function affect1!(integrator)
    integrator.u[1] -= 1         # S -&gt; S - 1
    integrator.u[2] += 1         # I -&gt; I + 1
    nothing
end
jump = ConstantRateJump(rate1, affect1!)

rate2(u, p, t) = p[2] * u[2]         # ν*I
function affect2!(integrator)
    integrator.u[2] -= 1        # I -&gt; I - 1
    integrator.u[3] += 1        # R -&gt; R + 1
    nothing
end
jump2 = ConstantRateJump(rate2, affect2!)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstantRateJump{typeof(Main.rate2), typeof(Main.affect2!)}(Main.rate2, Main.affect2!)</code></pre><p>We will start with <code>990</code> susceptible people, <code>10</code> infected people, and <code>0</code> recovered people, and solve the problem from <code>t=0.0</code> to <code>t=250.0</code> so that</p><pre><code class="language-julia hljs">u₀ = [999, 10, 0]
tspan = (0.0, 250.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.0, 250.0)</code></pre><p><em>Notice, the initial populations are integers, since we want the exact number of people in the different states.</em></p><p>Since we want the system state to change only at the discrete jump times, we will build a <a href="https://docs.sciml.ai/DiffEqDocs/stable/types/discrete_types/"><code>DiscreteProblem</code></a></p><pre><code class="language-julia hljs">prob = DiscreteProblem(u₀, tspan, p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">DiscreteProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Int64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
timespan: (0.0, 250.0)
u0: 3-element Vector{Int64}:
 999
  10
   0</code></pre><p>We can then use <a href="../../api/#JumpProcesses.JumpProblem"><code>JumpProblem</code></a> from JumpProcesses to augment the discrete problem with jumps and select the stochastic simulation algorithm (SSA) to use in sampling the jump processes. To create a <code>JumpProblem</code> we would simply do:</p><pre><code class="language-julia hljs">jump_prob = JumpProblem(prob, Direct(), jump, jump2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">JumpProblem</span> with problem <span class="sgr38_2" style="color:#56b6c2">DiscreteProblem</span> with aggregator <span class="sgr38_2" style="color:#56b6c2">Direct
Number of jumps with discrete aggregation: 2
Number of jumps with continuous aggregation: 0
Number of mass action jumps: 0
</span></code></pre><p>Here <a href="../../api/#JumpProcesses.Direct"><code>Direct()</code></a> indicates that we will determine the random times and types of jumps that occur using <a href="https://doi.org/10.1016/0021-9991(76)90041-3">Gillespie&#39;s Direct stochastic simulation algorithm (SSA)</a>, also known as Doob&#39;s method or Kinetic Monte Carlo. See <a href="../../jump_types/#Jump-Aggregators-for-Exact-Simulation">Jump Aggregators for Exact Simulation</a> for other supported SSAs.</p><p>We now have a problem that can be evolved in time using the JumpProcesses solvers. Since our model is a pure jump process with all rates being constant in between jumps (i.e., no continuously-varying components), we will use <a href="#SSAStepper"><code>SSAStepper</code></a> to handle time-stepping the <code>Direct</code> method from jump to jump:</p><pre><code class="language-julia hljs">sol = solve(jump_prob, SSAStepper())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: Piecewise constant interpolation
t: 1879-element Vector{Float64}:
   0.0
   0.5735493314877204
   0.6587118516353072
   1.4354051139046295
   1.5037410910655968
   1.8686150486054596
   2.9534217280547743
   3.630532374236835
   3.728689638684086
   4.181929882913999
   ⋮
 244.53536026622342
 244.7994887148367
 244.89030972569861
 245.29285916753966
 245.4712808264952
 246.1065095654621
 246.4260349246759
 246.67728486563752
 250.0
u: 1879-element Vector{Vector{Int64}}:
 [999, 10, 0]
 [998, 11, 0]
 [997, 12, 0]
 [996, 13, 0]
 [995, 14, 0]
 [994, 15, 0]
 [993, 16, 0]
 [992, 17, 0]
 [991, 18, 0]
 [990, 19, 0]
 ⋮
 [0, 138, 871]
 [0, 137, 872]
 [0, 136, 873]
 [0, 135, 874]
 [0, 134, 875]
 [0, 133, 876]
 [0, 132, 877]
 [0, 131, 878]
 [0, 131, 878]</code></pre><p>This solve command takes the standard commands of the common interface, and the solution object acts just like any other differential equation solution. Thus there exists a plot recipe, which we can plot with:</p><pre><code class="language-julia hljs">plot(sol, label = [&quot;S(t)&quot; &quot;I(t)&quot; &quot;R(t)&quot;])</code></pre><img src="35402ada.svg" alt="Example block output"/><p>Note, in systems with more than a few jumps (more than ~10), it can be advantageous to use more sophisticated SSAs than <code>Direct</code>. For such systems it is recommended to use <a href="../../api/#JumpProcesses.SortingDirect"><code>SortingDirect</code></a>, <a href="../../api/#JumpProcesses.RSSA"><code>RSSA</code></a> or <a href="../../api/#JumpProcesses.RSSACR"><code>RSSACR</code></a>, see the list of JumpProcesses SSAs at <a href="../../jump_types/#Jump-Aggregators-for-Exact-Simulation">Jump Aggregators for Exact Simulation</a>.</p><h2 id="SSAStepper"><a class="docs-heading-anchor" href="#SSAStepper">SSAStepper</a><a id="SSAStepper-1"></a><a class="docs-heading-anchor-permalink" href="#SSAStepper" title="Permalink"></a></h2><p>Any common interface algorithm can be used to perform the time-stepping, since it is implemented over the callback interface. This allows for hybrid systems that mix ODEs, SDEs and jumps. In many cases, we may have a pure jump system that only involves <code>ConstantRateJump</code>s, <code>MassActionJump</code>s, and/or bounded <code>VariableRateJump</code>s (see below). In those cases, a substantial performance benefit may be gained by using <a href="#SSAStepper"><code>SSAStepper</code></a>. Note, <code>SSAStepper</code> is a more limited time-stepper which only supports discrete events, and does not allow simultaneous coupled ODEs/SDEs, or general <code>VariableRateJump</code>s. It is, however, very efficient for pure jump problems involving only <code>ConstantRateJump</code>s, <code>MassActionJump</code>s, and bounded <code>VariableRateJump</code>s.</p><h2 id="MassActionJumpSect"><a class="docs-heading-anchor" href="#MassActionJumpSect">Defining the Jumps Directly: <code>MassActionJump</code></a><a id="MassActionJumpSect-1"></a><a class="docs-heading-anchor-permalink" href="#MassActionJumpSect" title="Permalink"></a></h2><p>For <code>ConstantRateJump</code>s that can be represented as mass action reactions a further specialization of the jump type is possible that offers improved computational performance; <a href="../../api/#JumpProcesses.MassActionJump"><code>MassActionJump</code></a>. Suppose the system has <span>$N$</span> chemical species <span>$\{S_1,\dots,S_N\}$</span>. A general mass action reaction has the form</p><p class="math-container">\[R_1 S_1 + R_2 S_2 + \dots + R_N S_N \overset{k}{\rightarrow} P_1 S_1 + P_2 S_2 + \dots + P_N S_N\]</p><p>where the non-negative integers <span>$(R_1,\dots,R_N)$</span> denote the <em>reactant stoichiometry</em> of the reaction, and the non-negative integers <span>$(P_1,\dots,P_N)$</span> the <em>product stoichiometry</em>. The <em>net stoichiometry</em> is the net change in each chemical species from the reaction occurring one time, given by <span>$\mathbf{\nu} = (P_1-R_1,\dots,P_N-R_N)$</span>. As such, the <code>affect!</code> function associated with a <code>MassActionJump</code> simply changes the state, <span>$\mathbf{u}(t) = (u_1(t),\dots,u_N(t))$</span>, by updating</p><p class="math-container">\[\mathbf{u}(t) \to \mathbf{u}(t) + \mathbf{\nu}.\]</p><p>The default rate function, <code>ρ = rate(u,p,t)</code>, is based on stochastic chemical kinetics and given by</p><p class="math-container">\[ρ(\mathbf{u}(t)) = k \prod_{i=1}^N \begin{pmatrix} u_i \\ R_i \end{pmatrix}
= k \prod_{i=1}^N \frac{u_i!}{R_i! (u_i - R_i)!}
= k \prod_{i=1}^N \frac{u_i (u_i - 1) \cdots (u_i - R_i + 1)}{R_i!}\]</p><p>where <span>$k$</span> denotes the rate constant of the reaction (in units of per time).</p><p>As an example, consider again the SIR model. The species are <code>u = (S,I,R)</code>. The first reaction has rate <code>β</code>, reactant stoichiometry <code>(1, 1, 0)</code>, product stoichiometry <code>(0, 2, 0)</code>, and net stoichiometry <code>(-1, 1, 0)</code>. The second reaction has rate <code>ν</code>, reactant stoichiometry <code>(0, 1, 0)</code>, product stoichiometry <code>(0, 0, 1)</code>, and net stoichiometry <code>(0, -1, 1)</code>.</p><p>We can manually encode this system as a mass action jump by specifying the indexes of the rate constants in <code>p</code>, the reactant stoichiometry, and the net stoichiometry. We note that the first two determine the rate function, with the latter determining the affect function.</p><pre><code class="language-julia hljs">rateidxs = [1, 2]           # i.e., [β, ν]
reactant_stoich = [
    [1 =&gt; 1, 2 =&gt; 1],         # 1*S and 1*I
    [2 =&gt; 1]                  # 1*I
]
net_stoich = [
    [1 =&gt; -1, 2 =&gt; 1],        # -1*S and 1*I
    [2 =&gt; -1, 3 =&gt; 1]         # -1*I and 1*R
]
mass_act_jump = MassActionJump(reactant_stoich, net_stoich; param_idxs = rateidxs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MassActionJump{Nothing, Vector{Vector{Pair{Int64, Int64}}}, Vector{Vector{Pair{Int64, Int64}}}, JumpProcesses.MassActionJumpParamMapper{Vector{Int64}}}(nothing, [[1 =&gt; 1, 2 =&gt; 1], [2 =&gt; 1]], [[1 =&gt; -1, 2 =&gt; 1], [2 =&gt; -1, 3 =&gt; 1]], JumpProcesses.MassActionJumpParamMapper{Vector{Int64}}([1, 2]))</code></pre><p>Notice, one typically should define <em>one</em> <code>MassActionJump</code> that encodes each possible jump that can be represented via a mass action reaction. This contrasts with <code>ConstantRateJump</code>s or <code>VariableRateJump</code>s where separate instances are created for each distinct jump type.</p><p>Just like for <code>ConstantRateJumps</code>, to then simulate the system we create a <code>JumpProblem</code> and call <code>solve</code>:</p><pre><code class="language-julia hljs">jump_prob = JumpProblem(prob, Direct(), mass_act_jump)
sol = solve(jump_prob, SSAStepper())
plot(sol; label = [&quot;S(t)&quot; &quot;I(t)&quot; &quot;R(t)&quot;])</code></pre><img src="02aa0268.svg" alt="Example block output"/><p>For more details about MassActionJumps see <a href="../../jump_types/#Defining-a-Mass-Action-Jump">Defining a Mass Action Jump</a>. We note that one could include the factors of <span>$1 / R_i!$</span> directly in the rate constant passed into a <a href="../../api/#JumpProcesses.MassActionJump"><code>MassActionJump</code></a>, so that the desired rate function that gets evaluated is</p><p class="math-container">\[\hat{k} \prod_{i=1}^N u_i (u_i - 1) \cdots (u_i - R_i + 1)\]</p><p>with <span>$\hat{k} = k / \prod_{i=1}^{N} R_i!$</span> the renormalized rate constant. Passing the keyword argument <code>scale_rates = false</code> will disable <code>MassActionJump</code>s internally rescaling the rate constant by <span>$(\prod_{i=1}^{N} R_i!)^{-1}$</span>.</p><p>For chemical reaction systems Catalyst.jl automatically groups reactions into their optimal jump representation.</p><h3 id="*Caution-about-ConstantRateJumps-and-MassActionJumps*"><a class="docs-heading-anchor" href="#*Caution-about-ConstantRateJumps-and-MassActionJumps*"><em>Caution about ConstantRateJumps and MassActionJumps</em></a><a id="*Caution-about-ConstantRateJumps-and-MassActionJumps*-1"></a><a class="docs-heading-anchor-permalink" href="#*Caution-about-ConstantRateJumps-and-MassActionJumps*" title="Permalink"></a></h3><p><code>ConstantRateJump</code>s and <code>MassActionJump</code>s are restricted in that they assume the rate functions are constant at all times between two consecutive jumps of the system. That is, any species/states or parameters that a rate function depends on must not change between the times at which two consecutive jumps occur. Such conditions are violated if one has a time-dependent parameter like <span>$\beta(t)$</span> or if some solution components, say <code>u[2]</code>, may also evolve through a coupled ODE, SDE, or a general <a href="../../api/#JumpProcesses.VariableRateJump"><code>VariableRateJump</code></a> (see below for examples). For problems where the rate function may change between consecutive jumps, bounded or general <a href="../../api/#JumpProcesses.VariableRateJump"><code>VariableRateJump</code></a>s must be used.</p><p>Thus, in the examples above,</p><pre><code class="language-julia hljs">rate1(u, p, t) = p[1] * u[1] * u[2]
rate2(u, p, t) = p[2] * u[2]</code></pre><p>both must be constant, besides changes due to some other <code>ConstantRateJump</code> or <code>MassActionJump</code> (the same restriction applies to <code>MassActionJump</code>s). Since these rates only change when <code>u[1]</code> or <code>u[2]</code> is changed, and <code>u[1]</code> and <code>u[2]</code> only change when one of the jumps occur, this setup is valid. However, a rate of <code>t*p[1]*u[1]*u[2]</code> would not be valid because the rate would change in between jumps, as would <code>p[2]*u[1]*u[4]</code> when <code>u[4]</code> is the solution to a continuous problem such as an ODE/SDE, or can be changed by a general <code>VariableRateJump</code>. Thus, one must be careful to follow this rule when choosing rates.</p><p>In summary, if a particular jump process has a rate function that depends explicitly or implicitly on a continuously changing quantity, you need to use a <a href="../../api/#JumpProcesses.VariableRateJump"><code>VariableRateJump</code></a>.</p><h2 id="VariableRateJumpWithBnds"><a class="docs-heading-anchor" href="#VariableRateJumpWithBnds">Defining the Jumps Directly using a bounded <code>VariableRateJump</code></a><a id="VariableRateJumpWithBnds-1"></a><a class="docs-heading-anchor-permalink" href="#VariableRateJumpWithBnds" title="Permalink"></a></h2><p>Assume that the infection rate is now decreasing over time. That is, when individuals get infected, they immediately reach peak infectivity. The force of infection then decreases exponentially to a basal level. In this case, we must keep track of the time of infection events. Let the history <span>$H(t)$</span> contain the timestamps of all <span>$I(t)$</span> active infections. The rate of infection is then</p><p class="math-container">\[\beta_1 S(t) I(t) + \alpha S(t) \sum_{t_i \in H(t)} \exp(-\gamma (t - t_i))\]</p><p>where <span>$\beta_1$</span> is the basal rate of infection, <span>$\alpha$</span> is the spike in the rate of infection, and <span>$\gamma$</span> is the rate at which the spike decreases. Here, we choose parameters such that infectivity rate due to a single infected individual returns to the basal rate after spiking to <span>$\beta_1 + \alpha$</span>. In other words, we are modelling a situation in which infected individuals gradually become less infectious prior to recovering. Finally, the vector parameters will include a structure of active infections <span>$H$</span> which is initialized with <span>$10$</span> random infections. We use a dictionary to ensure insertions and deletions are <span>$\mathcal{O}(1)$</span>. Our parameters are then</p><pre><code class="language-julia hljs">β1 = 0.001 / 1000.0
α = 0.1 / 1000.0
γ = 0.05
H = Dict(zip(1:10, zeros(Float64, 10)))
sizehint!(H, 1000)
p1 = (β1, ν, α, γ, H)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1.0e-6, 0.01, 0.0001, 0.05, Dict(1 =&gt; 0.0, 5 =&gt; 0.0, 7 =&gt; 0.0, 4 =&gt; 0.0, 10 =&gt; 0.0, 3 =&gt; 0.0, 6 =&gt; 0.0, 2 =&gt; 0.0, 9 =&gt; 0.0, 8 =&gt; 0.0…))</code></pre><p>We define an infection reaction as a bounded <code>VariableRateJump</code>, requiring us to again provide <code>rate</code> and <code>affect</code> functions, but also give functions that calculate an upper-bound on the rate (<code>urate(u,p,t)</code>), an optional lower-bound on the rate (<code>lrate(u,p,t)</code>), and a time window over which the bounds are valid as long as any states these three rates depend on are unchanged (<code>rateinterval(u,p,t)</code>). The lower- and upper-bounds of the rate should be valid from the time they are computed <code>t</code> until <code>t + rateinterval(u, p, t)</code>:</p><pre><code class="language-julia hljs">function rate3(u, p, t)
    p[1] * u[1] * u[2] + p[3] * u[1] * sum(exp(-p[4] * (t - _t)) for _t in values(p[5]))
end
lrate = rate1              # β*S*I
urate = rate3
rateinterval(u, p, t) = 1 / (2 * urate(u, p, t))
function affect3!(integrator)
    integrator.u[1] -= 1     # S -&gt; S - 1
    integrator.u[2] += 1     # I -&gt; I + 1
    integrator.p[5][integrator.u[2] + integrator.u[3] + 1] = integrator.t # S + R + 1
    nothing
end
jump3 = VariableRateJump(rate3, affect3!; lrate, urate, rateinterval)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VariableRateJump{typeof(Main.rate3), typeof(Main.affect3!), typeof(Main.rate1), typeof(Main.rate3), typeof(Main.rateinterval), Nothing, Float64, Int64}(Main.rate3, Main.affect3!, Main.rate1, Main.rate3, Main.rateinterval, nothing, true, 10, (false, true), 1.0e-12, 0)</code></pre><p>Note that here we set the lower bound rate to be the normal SIR infection rate, and set the upper bound rate equal to the new rate of infection (<code>rate3</code>). As required for bounded <code>VariableRateJump</code>s, we have for any <code>s</code> in <code>[t,t + rateinterval(u,p,t)]</code> the bound <code>lrate(u,p,t) &lt;= rate3(u,p,s) &lt;= urate(u,p,t)</code> will hold provided the dependent states <code>u[1]</code> and <code>u[2]</code> have not changed.</p><p>Next, we redefine the recovery jump&#39;s <code>affect!</code> such that a random infection is removed from <code>p[5]</code> for every recovery.</p><pre><code class="language-julia hljs">rate4(u, p, t) = p[2] * u[2]         # ν*I
function affect4!(integrator)
    integrator.u[2] -= 1
    integrator.u[3] += 1
    length(integrator.p[5]) &gt; 0 &amp;&amp;
        delete!(integrator.p[5], rand(integrator.p[5]))
    nothing
end
jump4 = ConstantRateJump(rate4, affect4!)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstantRateJump{typeof(Main.rate4), typeof(Main.affect4!)}(Main.rate4, Main.affect4!)</code></pre><p>With the jumps defined, we can build a <a href="https://docs.sciml.ai/DiffEqDocs/stable/types/discrete_types/"><code>DiscreteProblem</code></a>. Bounded <code>VariableRateJump</code>s over a <code>DiscreteProblem</code> can currently only be simulated with <code>Coevolve</code>. The aggregator requires a dependency graph to indicate when a given jump occurs and which other jumps in the system should have their rate recalculated (i.e., their rate depends on states modified by one occurrence of the first jump). This ensures that rates, rate bounds, and rate intervals are recalculated when invalidated due to changes in <code>u</code>. For the current example, both processes mutually affect each other, so we have</p><pre><code class="language-julia hljs">dep_graph = [[1, 2], [1, 2]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 2]</code></pre><p>Here <code>dep_graph[2] = [1,2]</code> indicates that when the second jump occurs, both the first and second jumps need to have their rates recalculated. We can then construct our <code>JumpProblem</code> as before, specifying the <code>Coevolve</code> aggregator:</p><pre><code class="language-julia hljs">prob = DiscreteProblem(u₀, tspan, p1)
jump_prob = JumpProblem(prob, Coevolve(), jump3, jump4; dep_graph)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">JumpProblem</span> with problem <span class="sgr38_2" style="color:#56b6c2">DiscreteProblem</span> with aggregator <span class="sgr38_2" style="color:#56b6c2">Coevolve
Number of jumps with discrete aggregation: 2
Number of jumps with continuous aggregation: 0
Number of mass action jumps: 0
</span></code></pre><p>We now have a problem that can be solved with <code>SSAStepper</code> to handle time-stepping the <code>Coevolve</code> aggregator from jump to jump:</p><pre><code class="language-julia hljs">sol = solve(jump_prob, SSAStepper())
plot(sol, label = [&quot;S(t)&quot; &quot;I(t)&quot; &quot;R(t)&quot;])</code></pre><img src="c353de71.svg" alt="Example block output"/><p>We see that the time-dependent infection rate leads to a lower peak of the infection throughout the population.</p><p>Note that bounded <code>VariableRateJump</code>s over <code>DiscreteProblem</code>s can be quite general. However, when handling rates that change according to an ODE/SDE modified variable we will need a continuous integrator. One example is discussed <a href="#VariableRateJumpSect">below</a> in which we have a new reaction added to the model with rate <code>p[2]*u[1]*u[4]</code> where <code>u[4]</code> is the solution of an ODE. In such models, you will also need to be more careful in setting rate bounds as they must be valid for the full coupled system&#39;s dynamics.</p><h2 id="save_positions_docs"><a class="docs-heading-anchor" href="#save_positions_docs">Reducing Memory Use: Controlling Saving Behavior</a><a id="save_positions_docs-1"></a><a class="docs-heading-anchor-permalink" href="#save_positions_docs" title="Permalink"></a></h2><p>Note that jumps act via DifferentialEquations.jl&#39;s <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/">callback interface</a>, which defaults to saving the state vector <code>u</code> at each event. This is required in order to accurately resolve every discontinuity exactly (and this is what allows for perfectly vertical lines in plots!). However, in many cases when using jump problems, you may wish to decrease the saving pressure given by large numbers of jumps. To do this, you set the <code>save_positions</code> keyword argument to <code>JumpProblem</code>. Just like for other <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/">callbacks</a>, this is a tuple <code>(bool1, bool2)</code> which sets whether to save <code>u</code> before and/or after a jump. If we do not want to save at every jump, we would thus pass:</p><pre><code class="language-julia hljs">prob = DiscreteProblem(u₀, tspan, p)
jump_prob = JumpProblem(prob, Direct(), jump, jump2; save_positions = (false, false))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">JumpProblem</span> with problem <span class="sgr38_2" style="color:#56b6c2">DiscreteProblem</span> with aggregator <span class="sgr38_2" style="color:#56b6c2">Direct
Number of jumps with discrete aggregation: 2
Number of jumps with continuous aggregation: 0
Number of mass action jumps: 0
</span></code></pre><p>Now the saving controls associated with the integrator should be specified, see the main <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/common_solver_opts/">SciML Docs</a> for saving options. For example, we can use <code>saveat = 10.0</code> to save at an evenly spaced grid:</p><pre><code class="language-julia hljs">sol = solve(jump_prob, SSAStepper(); saveat = 10.0)
plot(sol, label = [&quot;S(t)&quot; &quot;I(t)&quot; &quot;R(t)&quot;], marker = :o)</code></pre><img src="c70bad99.svg" alt="Example block output"/><p>Notice that our plot is now defined at precisely the specified time points, and for time values in between those points piecewise-linear interpolation is used in graphing the solution. Note, however, that evaluation of the solution object still treats the solution as piecewise constant, and so <code>sol</code> should not be explicitly evaluated at any times besides the times at which it was saved, i.e. notice that <code>sol(15.0)</code> does not interpolate the solution vectors at times <code>10</code> and <code>20</code> below, but is instead the same as the solution at time <code>10</code>:</p><pre><code class="language-julia hljs">sol(10.0), sol(15.0), sol(20.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([986, 22, 1], [986, 22, 1], [950, 56, 3])</code></pre><p><em>It is important to keep in mind that neither plotting or evaluation of the solution object will be exact for a pure jump process when using <code>saveat</code> except for the times given via <code>saveat</code>. This is because the solution values at jump times have not been stored. i.e for <code>t</code> a time for which we did not save the state, <code>sol(t)</code> will no longer give the exact value of the solution at <code>t</code>.</em></p><p>In summary, the jump callback will save the state variable <code>u</code> before and after the jump whenever <code>save_positions = (true, true)</code>. All other saving behavior is delegated to the integrator and controlled via keyword arguments to <code>solve</code> such as <code>saveat</code>.</p><h2 id="Defining-the-Jumps-Directly:-Mixing-ConstantRateJump/VariableRateJump-and-MassActionJump"><a class="docs-heading-anchor" href="#Defining-the-Jumps-Directly:-Mixing-ConstantRateJump/VariableRateJump-and-MassActionJump">Defining the Jumps Directly: Mixing <code>ConstantRateJump</code>/<code>VariableRateJump</code> and <code>MassActionJump</code></a><a id="Defining-the-Jumps-Directly:-Mixing-ConstantRateJump/VariableRateJump-and-MassActionJump-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Jumps-Directly:-Mixing-ConstantRateJump/VariableRateJump-and-MassActionJump" title="Permalink"></a></h2><p>Suppose we now want to add in to the original SIR model another jump that cannot be represented as a mass action reaction. We can create a new <code>ConstantRateJump</code> and simulate a hybrid system using both the <code>MassActionJump</code> for the two original reactions, and the new <code>ConstantRateJump</code>. Let&#39;s suppose we want to let susceptible people be born with the following jump rate:</p><pre><code class="language-julia hljs">birth_rate(u, p, t) = 10.0 * u[1] / (200.0 + u[1]) + 10.0
function birth_affect!(integrator)
    integrator.u[1] += 1
    nothing
end
birth_jump = ConstantRateJump(birth_rate, birth_affect!)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstantRateJump{typeof(Main.birth_rate), typeof(Main.birth_affect!)}(Main.birth_rate, Main.birth_affect!)</code></pre><p>We can then simulate the hybrid system as</p><pre><code class="language-julia hljs">jump_prob = JumpProblem(prob, Direct(), mass_act_jump, birth_jump)
sol = solve(jump_prob, SSAStepper())
plot(sol; label = [&quot;S(t)&quot; &quot;I(t)&quot; &quot;R(t)&quot;])</code></pre><img src="dff43d3c.svg" alt="Example block output"/><p>Note that we can combine <code>MassActionJump</code>s, <code>ConstantRateJump</code>s and bounded <code>VariableRateJump</code>s using the <code>Coevolve</code> aggregators.</p><h2 id="Adding-Jumps-to-a-Differential-Equation"><a class="docs-heading-anchor" href="#Adding-Jumps-to-a-Differential-Equation">Adding Jumps to a Differential Equation</a><a id="Adding-Jumps-to-a-Differential-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Jumps-to-a-Differential-Equation" title="Permalink"></a></h2><p>If we instead used some form of differential equation via an <code>ODEProblem</code> instead of a <code>DiscreteProblem</code>, we can couple the jumps/reactions to the differential equation. Let&#39;s define an ODE problem, where the continuous part only acts on some new 4th component:</p><pre><code class="language-julia hljs">using OrdinaryDiffEq
function f(du, u, p, t)
    du[4] = u[2] * u[3] / 1e5 - u[1] * u[4] / 1e5
    nothing
end
u₀ = [990.0, 10.0, 0.0, 100.0]
prob = ODEProblem(f, u₀, tspan, p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">ODEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Float64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
timespan: (0.0, 250.0)
u0: 4-element Vector{Float64}:
 990.0
  10.0
   0.0
 100.0</code></pre><p>Notice we gave the 4th component a starting value of 100.0, and used floating-point numbers for the initial condition, since some solution components now evolve continuously. The same steps as above will allow us to solve this hybrid equation when using <code>ConstantRateJump</code>s, <code>MassActionJump</code>s, or <code>VariableRateJump</code>s. For example, we can solve it using the <code>Tsit5()</code> method via:</p><pre><code class="language-julia hljs">jump_prob = JumpProblem(prob, Direct(), jump, jump2)
sol = solve(jump_prob, Tsit5())
plot(sol; label = [&quot;S(t)&quot; &quot;I(t)&quot; &quot;R(t)&quot; &quot;u₄(t)&quot;])</code></pre><img src="9f54cc65.svg" alt="Example block output"/><p>Note that in general, the ODE derivative <code>f(du, u, p, t)</code> could modify any element in <code>du</code> which the jump rate functions depend on. In this section, <code>f(du, u, p, t)</code> does not modify the jump rates so it is safe to couple them with any type of jump and use any type of aggregator. However, the implementation does not enforce this requirement, so one must be careful. Alternatively, when <code>f(du, u, p, t)</code> <em>does</em> modify variables that affect the jump rate, we have to implement another strategy as described in the next <a href="#VariableRateJumpSect">next Section</a>.</p><h2 id="VariableRateJumpSect"><a class="docs-heading-anchor" href="#VariableRateJumpSect">Adding a general VariableRateJump that Depends on a Continuously Evolving Variable</a><a id="VariableRateJumpSect-1"></a><a class="docs-heading-anchor-permalink" href="#VariableRateJumpSect" title="Permalink"></a></h2><p>Now let&#39;s consider adding a reaction whose rate changes continuously with the differential equation. To continue our example, let there be a new reaction with rate depending on <code>u[4]</code> of the form <span>$u_4 \to u_4 + \textrm{I}$</span>, with a rate constant of <code>1e-2</code>:</p><pre><code class="language-julia hljs">rate5(u, p, t) = 1e-2 * u[4]
function affect5!(integrator)
    integrator.u[2] += 1    # I -&gt; I + 1
    nothing
end
jump5 = VariableRateJump(rate5, affect5!)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VariableRateJump{typeof(Main.rate5), typeof(Main.affect5!), Nothing, Nothing, Nothing, Nothing, Float64, Int64}(Main.rate5, Main.affect5!, nothing, nothing, nothing, nothing, true, 10, (false, true), 1.0e-12, 0)</code></pre><p>Notice, since <code>rate5</code> depends on a variable that evolves continuously, and hence is not constant between jumps, <em>we must either use a general <code>VariableRateJump</code> without upper/lower bounds or a bounded <code>VariableRateJump</code></em>.</p><p>In the general case, solving the equation is exactly the same:</p><pre><code class="language-julia hljs">u₀ = [990.0, 10.0, 0.0, 1.0]
prob = ODEProblem(f, u₀, tspan, p)
jump_prob = JumpProblem(prob, Direct(), jump, jump2, jump5)
sol = solve(jump_prob, Tsit5())
plot(sol; label = [&quot;S(t)&quot; &quot;I(t)&quot; &quot;R(t)&quot; &quot;u₄(t)&quot;])</code></pre><img src="84a38a03.svg" alt="Example block output"/><p><em>Note that general <code>VariableRateJump</code>s require using a continuous problem, like an ODE/SDE/DDE/DAE problem, and using floating point initial conditions.</em></p><p>Alternatively, the case of bounded <code>VariableRateJump</code> requires some maths. First, we need to obtain the upper bounds of <code>rate5</code> at time <code>t</code> given <code>u</code>. Note that <code>rate5</code> evolves according to <code>u[4]</code> which is a separable first order differential equation of the form <span>$x&#39; = b - a x$</span> with general solution:</p><p class="math-container">\[x(t) = - \frac{e^{-a t - c_1 a}}{a} + \frac{b}{a}\]</p><p>This is bounded by <span>$b / a$</span> which is too high for our purposes since it would lead to a high rate of rejection during sampling. However, since the function is increasing we can compute the upper bound given an interval <span>$\Delta t$</span> as following:</p><p class="math-container">\[\bar{x}(s) = x(t) \, e^{-a (t + \Delta t)} + \frac{b}{a} (1 - e^{- a (t + \Delta t)}) \text{ , } \forall s \in [t, t + \Delta t]\]</p><p>However, when <span>$a = 0$</span> the differential equation becomes <span>$x&#39; = b$</span> whose solution is <span>$x(t) = b t$</span>. In which case, we obtain a different upper bound given by:</p><p class="math-container">\[\bar{x}(s) = x(t) + b * (t + \Delta t) \text{ , } \forall s \in [t, t + \Delta t]\]</p><p>These expressions allow us to write the upper-bound and the rate interval in Julia. In this example we use analytical boundaries for <em>illustration purposes</em>. However, in some circumstances with complex model of many variables it can be difficult to determine good a priori bounds on the ODE variables. Moreover, numerical and analytical solutions are generally not guaranteed to strictly satisfy the same bounds. In most cases the bounds should be close enough. Thus, consider adding some slack on the bounds and approach complex models with care.</p><pre><code class="language-julia hljs">function urate2(u, p, t)
    if u[1] &gt; 0
        1e-2 * max(u[4],
            (u[4] * exp(-1 * u[1] / 1e5) +
             (u[2] * u[3] / u[1]) * (1 - exp(-1 * u[1] / 1e5))))
    else
        1e-2 * (u[4] + 1 * u[2] * u[3] / 1e5)
    end
end
rateinterval2(u, p, t) = 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">rateinterval2 (generic function with 1 method)</code></pre><p>We can then formulate the jump problem. The only aggregator that supports bounded <code>VariableRateJump</code>s is <code>Coevolve</code>. We formulate and solve the jump problem with this aggregator. <code>Coevolve</code> can be formulated as either a discrete or continuous problem. In this case, we must formulate the problem as continuous as it depends on a continuous variable.</p><pre><code class="language-julia hljs">jump6 = VariableRateJump(rate5, affect5!; urate = urate2, rateinterval = rateinterval2)
dep_graph2 = [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
jump_prob = JumpProblem(prob, Coevolve(), jump, jump2, jump6; dep_graph = dep_graph2)
sol = solve(jump_prob, Tsit5())
plot(sol; label = [&quot;S(t)&quot; &quot;I(t)&quot; &quot;R(t)&quot; &quot;u₄(t)&quot;])</code></pre><img src="51d22706.svg" alt="Example block output"/><p>We obtain the same solution as with <code>Direct</code>, but <code>Coevolve</code> runs faster because it doesn&#39;t need to compute the derivative of <code>rate5</code>. Each aggregator faces a different trade-off, so the the choice of best aggregator will depend on the problem at hand. <code>Coevolve</code> requires a good understanding of the equations involved, passing a wrong boundary can result in silent bugs.</p><p>Lastly, we are not restricted to ODEs. For example, we can solve the same jump problem except with multiplicative noise on <code>u[4]</code> by using an <code>SDEProblem</code> instead:</p><pre><code class="language-julia hljs">using StochasticDiffEq
function g(du, u, p, t)
    du[4] = 0.1u[4]
end
prob = SDEProblem(f, g, [999.0, 1.0, 0.0, 1.0], (0.0, 250.0), p)
jump_prob = JumpProblem(prob, Direct(), jump, jump2, jump5)
sol = solve(jump_prob, SRIW1())
plot(sol; label = [&quot;S(t)&quot; &quot;I(t)&quot; &quot;R(t)&quot; &quot;u₄(t)&quot;])</code></pre><img src="86704513.svg" alt="Example block output"/><p>For more details about general <code>VariableRateJump</code>s see <a href="../../jump_types/#Defining-a-Variable-Rate-Jump">Defining a Variable Rate Jump</a>.</p><h2 id="RegularJumps-and-τ-Leaping"><a class="docs-heading-anchor" href="#RegularJumps-and-τ-Leaping">RegularJumps and τ-Leaping</a><a id="RegularJumps-and-τ-Leaping-1"></a><a class="docs-heading-anchor-permalink" href="#RegularJumps-and-τ-Leaping" title="Permalink"></a></h2><p>The previous parts described how to use <code>ConstantRateJump</code>s, <code>MassActionJump</code>s, and <code>VariableRateJump</code>s. However, in many cases one does not require the exactness of stepping to every jump time. Instead, regular jumping (i.e., τ-leaping) allows pooling jumps together, and performing larger updates in a statistically-correct but more efficient manner. The trade-off is the introduction of a time-discretization error due to the time-stepping, but one that is controlled and convergent as the time-step is reduced to zero.</p><p>Let&#39;s see how to define the SIR model in terms of a <code>RegularJump</code>. We need two functions, <code>rate</code> and <code>change!</code>. <code>rate</code> is a vector equation which computes the rates of each jump process</p><pre><code class="language-julia hljs">function rate(out, u, p, t)
    out[1] = p[1] * u[1] * u[2]   # β * S * I
    out[2] = p[2] * u[2]          # ν * I
    nothing
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">rate (generic function with 1 method)</code></pre><p>We then define a function that given a vector storing the number of times each jump occurs during a time-step, <code>counts</code>, calculates the change in the state, <code>du</code>. For the SIR example, we do this by multiplying <code>counts</code> by a matrix that encodes the change in the state due to one occurrence of each reaction (i.e., the net stoichiometry matrix). Below <code>c[i,j]</code> gives the change in <code>u[i]</code> due to the <code>j</code>th jump:</p><pre><code class="language-julia hljs">c = zeros(3, 2)
# S + I --&gt; I
c[1, 1] = -1    # S -&gt; S - 1
c[2, 1] = 1     # I -&gt; I + 1

# I --&gt; R
c[2, 2] = -1    # I -&gt; I - 1
c[3, 2] = 1     # R -&gt; R + 1

function change(du, u, p, t, counts, mark)
    mul!(du, c, counts)
    nothing
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">change (generic function with 1 method)</code></pre><p>We are now ready to create our <code>RegularJump</code>, passing in the rate function, change function, and the number of jumps being encoded</p><pre><code class="language-julia hljs">rj = RegularJump(rate, change, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RegularJump{true, typeof(Main.rate), typeof(Main.change), Nothing}(Main.rate, Main.change, 2, nothing)</code></pre><p>From there we build a <code>JumpProblem</code></p><pre><code class="language-julia hljs">u₀ = [1000.0, 50.0, 0.0]
prob = DiscreteProblem(u₀, tspan, p)
jump_prob = JumpProblem(prob, Direct(), rj)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">JumpProblem</span> with problem <span class="sgr38_2" style="color:#56b6c2">DiscreteProblem</span> with aggregator <span class="sgr38_2" style="color:#56b6c2">Direct
Number of jumps with discrete aggregation: 0
Number of jumps with continuous aggregation: 0
Number of mass action jumps: 0
Have a regular jump
</span></code></pre><p>Note that when a <code>JumpProblem</code> has a <code>RegularJump</code>, τ-leaping algorithms are required for simulating it. This is detailed on the <a href="../../jump_solve/#jump_solve">jump solvers page</a>. One such algorithm is <code>TauLeaping</code> from StochasticDiffEq.jl, which we use as follows:</p><pre><code class="language-julia hljs">sol = solve(jump_prob, TauLeaping(); dt = 0.001)
plot(sol; label = [&quot;S(t)&quot; &quot;I(t)&quot; &quot;R(t)&quot;])</code></pre><img src="8ad3e313.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../simple_poisson_process/">« Simple Poisson Processes in JumpProcesses</a><a class="docs-footer-nextpage" href="../point_process_simulation/">Temporal Point Process (TPP) Simulation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 10 September 2024 21:45">Tuesday 10 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
